# 静态和动态 生存期

**生存期** ：即从诞生到消失的时间段，在生存期内，对象的值保持不变，直到被改变为止。

对象生存期分为 **静态生存期** 和 **动态生存期** 两种。

## 简介

静态生存期：指对象的生存期与程序运行期相同。

动态生存期：可理解为局部对象，诞生于声明点，结束于块执行完毕。

---

在 `namespace` 中声明的对象都具有静态生存期，被称为常量。

在函数内部作用域声明的对象具有的都是动态生存期。

## 函数 静态对象

- 函数内部创建静态对象

如果用 `static` 修饰，如 `static int a`，这个 a 变量就会具有静态生存期，它诞生于第一次执行函数时声明它的位置，然而函数结束时，a 变量并不会消失，会一直存在于函数的这个局部空间中（外部是无法调用的），但是再次执行这个函数时，a 变量并不会在声明 `static int a` 处被初始化，而是直接调用 a 变量。

示例：

```cpp
#include <iostream>
using namespace std;

void test01()
{
    int a = 10;
    a++;
    cout << "动态生存期a的值为：" << a;
}

void test02()
{
    static int a = 10;
    a++;
    cout << "静态生存期a的值为：" << a;
}


int main()
{
    for (int i = 0; i < 5; i++)
    {
        test01();
        cout << "\t";
        test02();
        cout << endl;
    }
    
    system("pause");
    return 0;
}
```

结果：

```cpp
/*
动态生存期a的值为：11   静态生存期a的值为：11
动态生存期a的值为：11   静态生存期a的值为：12
动态生存期a的值为：11   静态生存期a的值为：13
动态生存期a的值为：11   静态生存期a的值为：14
动态生存期a的值为：11   静态生存期a的值为：15
*/
```

特点：

在局部作用域中，静态变量的特点是不会随函数的每次调用而产生一个副本，同时也不会因为函数执行完毕而消失；该变量会一直保持上一个值，除非被更改。

- 函数内静态对象的实现原理

将上面的 `test02` 函数改写成如下形式：

```cpp
void test02()
{
    static int a = 10;
    a++;
    cout << "静态生存期a的值为：" << a;
    a = 20;
}
```

你会发现结果是这样的：

```cpp
动态生存期a的值为：11   静态生存期a的值为：11
动态生存期a的值为：11   静态生存期a的值为：21
动态生存期a的值为：11   静态生存期a的值为：21
动态生存期a的值为：11   静态生存期a的值为：21
动态生存期a的值为：11   静态生存期a的值为：21
```

实现原理：

当函数第一次执行时，会加载所有的 `static` 对象，比如上例，创建了一个 `int` 类型的 `a` 变量，并且这个变量是具有静态生存期的，在函数执行完毕前，将 `a=20` 重定义，会发现，`a` 变量并没有变为动态对象，因为程序并没有报错，`a`如果变成了动态对象，第二次执行函数时，`a++` 会找不到对象而报错。

结论：

1. 函数内部，`static`只会在第一次执行，后续都不会再执行 `static` 语句。
2. 函数内部的静态对象可以被赋值，但是对静态对象赋值，不会使它成为动态对象。

## 类 静态对象

类的静态对象称为静态成员，是解决同一个类的不同对象之间数据和函数的共享问题。

静态成员就是在成员变量和成员函数前加上关键字`static`，称为静态成员。

静态成员分为：

- 静态成员变量
  - 所有对象共享同一份数据
  - 在编译阶段分配内存
  - 类内声明，类外初始化
- 静态成员函数
  - 所有对象共享一个函数
  - 静态成员函数只能访问静态成员变量

如每生成一个对象，则计数+1，从而统计一共创建了多少个对象。

### 类 创建静态成员变量

和函数类似，如果类中某个属性为整个类所共享，则用 `static` 修饰为静态成员；该成员在每个类中只有一个副本，由所有对象共同维护，从而实现数据共享。

**注意：**静态数据成员必须在类定义体的外部定义，且只能定义一次。静态数据成员不能通过类的构造函数初始化，而是应该在定义时进行初始化。

保证对象正好定义一次的方法是，将static数据成员的定义放在包含类的非内联成员函数定义的源文件中。

因为静态数据成员不属于任何对象，所以有多种访问方式：

1. `类名::成员名`
2. `对象名.成员名`
3. `指针->成员名`
4. `引用.成员名`

示例：

```cpp
#include <iostream>
using namespace std;

class Dog
{
public:
    Dog(string name)
    {
        name = name;
        count ++;
    }
    static int count;
private:
    string name;
};

// 初始化类静态成员
int Dog::count = 0;

int main()
{
    Dog dog01("Sherry");
    Dog dog02("Henry");
    cout << "现在有 " << Dog::count << " 只狗：" << endl;
    
    system("pause");
    return 0;
}
```

**再次注意：** 不要将静态成员的定义放在头文件中，除非你能保证该头文件不会被两个不同的源文件包含，不然会报重复定义错误，相当于是在两个源文件中都定义了同一个变量。对于这种同一头文件被不同源文件包含的情况，使用 `#ifndef` 或者 `#pragma once` 是没用的。这种预编译宏是为了解决一个源文件两次包含同一个头文件的问题。
同时，对静态数据成员的定义也不能放在main()函数里，否则编译报错：`error C2655: “Box::height”: 当前范围内的定义或重新声明非法`。
正确的做法，就如上面所说，把它放在定义类的成员函数的源文件中。

### 类 创建静态成员函数

```cpp
#include <iostream>
using namespace std;

class Dog
{
public:
    Dog(string name)
    {
        m_name = name;
        count ++;
    }

    static void func()
    {   
        count = 0;
        // 静态函数 只能调用 静态变量
        // m_name = "Sunshine";
        cout << "static void func 调用" << endl;
    }
    static int count;
private:
    string m_name;
};

// 初始化类静态成员
int Dog::count = 0;

int main()
{
    Dog dog01("Sherry");
    Dog dog02("Henry");
    Dog::func();
    cout << "现在有 " << Dog::count << " 只狗：" << endl;
    
    system("pause");
    return 0;
}
```

**注意：**

- 静态成员函数 只能访问 静态成员变量