# float

## float格式

float 占 4个字节，也就是有32bit。俗称为 `单精度32位`。

格式：`|  阶符±  |  阶码e  |  数符±   |  尾数m  |`

![](https://img-blog.csdn.net/20180311093041713?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWVzeWVzMTIw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

- **符号位 (Sign)：**0代表正数，1代表为负数；

- **指数位 (Exponent)：**用于存储科学计数法中的指数数据，指数的数值要加上127，如果指数本来是3，那么要换成130来存储；

- **尾数部分 (Mantissa)：**采用移位存储尾数部分，因为M的值一定是1<= M <2，所以它绝对可以写成1.xxxxxxx的形式，所以规定M在存储时舍去第一个1，只存储小数点之后的数字，这样做节省了空间。

  任何一个数的科学计数法表示都为`1. xxx * 2n` ，尾数部分就可以表示为`xxx`，由于第一位都是1嘛，干嘛还要表示呀？所以将小数点前面的1省略。

示例：

​	浮点数`-3.75`，先将其转换成二进制的，则为`-11.11(b)`，可以写成`-1.111*2^1(b)`，所以符号位是`1`，加`127`等于`128`，指数位是`1000 0000`，尾数位是`111 0000 0000 0000 0000 0000`（就是3个1，然后后面20个0，一共23位）。

​	整个32位结构就是

​	`| 1 | 1000 0000 | 111 0000 0000 0000 0000 0000 |`

## 指针

`float jx = -3.75;` ，`&jx`获取的地址为：`005AFDA4(h)`；对应二进制是`101 1010 1111 1101 1010 0100`，好像和上一节内容并不能对应上，并且每次运行，这个地址都会改变，这是因为`&`是取址符，代表获取是`jx`这个对象在内存中的地址，也就是说`jx`从内存第`005AFDA4(h)`个字节开始存储。

![image-20210806162613624](https://i.loli.net/2021/08/06/IZOxtC37FiSUaAW.png)

我们知道`jx`对象占4个字节，如何获取到这4个字节所有32位的位码呢，采用`(int&)jx`，获取到的结果为：`-1066401792`，多次运行发现这个结果是不变的，然后将`-1066401792` 转为二进制结果为：`1100 0000 0111 0000 0000 0000 0000 0000` 发现是和`float -3.75` 的32位格式码是对应上的。

所以`(int&)jx`是将 `jx` 的内容以 `int`型输出，并没有对其进行转换。

补充：

- **浮点数0.0是比较特殊的，它并不按照上面说的浮点数的格式存储，浮点数0.0在内存里的存储是000.....000（全零）。**
- `int(jx)`对其进行转换并没有改变 `jx` 的首地址，可能是由于 `sizeof(int) == sizeof(float)`