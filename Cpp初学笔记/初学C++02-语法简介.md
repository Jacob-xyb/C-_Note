# C++ 注释

程序的注释是解释性语句，您可以在 C++ 代码中包含注释，这将提高源代码的可读性。所有的编程语言都允许某种形式的注释。

C++ 支持单行注释和多行注释。注释中的所有字符会被 C++ 编译器忽略。

C++ 注释一般有两种：

- **//** - 一般用于单行注释。
- /*** ... \*/** - 一般用于多行注释。

# C++ 数据类型

使用编程语言进行编程时，需要用到各种变量来存储各种信息。变量保留的是它所存储的值的内存位置。这意味着，当您创建一个变量时，就会在内存中保留一些空间。

您可能需要存储各种数据类型（比如字符型、宽字符型、整型、浮点型、双浮点型、布尔型等）的信息，操作系统会根据变量的数据类型，来分配内存和决定在保留内存中存储什么。

## 基本的内置类型

C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：

| 类型     | 关键字  |
| :------- | :------ |
| 布尔型   | bool    |
| 字符型   | char    |
| 整型     | int     |
| 浮点型   | float   |
| 双浮点型 | double  |
| 无类型   | void    |
| 宽字符型 | wchar_t |

其实 wchar_t 是这样来的：

```
typedef short int wchar_t;
```

所以 wchar_t 实际上的空间是和 short int 一样。

一些基本类型可以使用一个或多个类型修饰符进行修饰：

- signed
- unsigned
- short
- long

下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。

**注意：**不同系统会有所差异，一字节为 8 位。

**注意：**long int 8 个字节，int 都是 4 个字节，早期的 C 编译器定义了 long int 占用 4 个字节，int 占用 2 个字节，新版的 C/C++ 标准兼容了早期的这一设定。

| 类型               | 位            | 范围                                                         |
| :----------------- | :------------ | :----------------------------------------------------------- |
| char               | 1 个字节      | -128 到 127 或者 0 到 255                                    |
| unsigned char      | 1 个字节      | 0 到 255                                                     |
| signed char        | 1 个字节      | -128 到 127                                                  |
| int                | 4 个字节      | -2147483648 到 2147483647                                    |
| unsigned int       | 4 个字节      | 0 到 4294967295                                              |
| signed int         | 4 个字节      | -2147483648 到 2147483647                                    |
| short int          | 2 个字节      | -32768 到 32767（2^15）                                      |
| unsigned short int | 2 个字节      | 0 到 65,535                                                  |
| signed short int   | 2 个字节      | -32768 到 32767                                              |
| long int           | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807      |
| signed long int    | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807      |
| unsigned long int  | 8 个字节      | 0 到 18,446,744,073,709,551,615                              |
| float              | 4 个字节      | 精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个有效数字) |
| double             | 8 个字节      | 双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个有效数字) |
| long double        | 16 个字节     | 长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。 |
| wchar_t            | 2 或 4 个字节 | 1 个宽字符                                                   |

从上表可得知，变量的大小会根据编译器和所使用的电脑而有所不同。

 ## sizeof

如果记不住类型所占内存大小，可以直接用关键字`sizeof`来进行查询。

`sizeof(int)`

整型结论：**short < int <= long <= long long**

### 为什么long和int都是4字节

如果你测试过long和int内置类型的大小，当发现都为4字节时，可能都会产生疑问，如果都是4字节，long并没有提供更大的存储范围，那么还要long做什么用？本文如下内容将为你解开这些疑团。

先简要概述以下内置类型的发展，如有疏漏，还请指正。C语言开始时只有char(8位)和int(16位)两种，后来随着发展又加入了short(16位)和long(32位)，此时，int可以是16位或者32位，依赖于平台和后续的兼容性。再后来当64位出现时，long long(64位)又被添加进来，为了进行规范，对较小的一些类型的范围就有了一些调整，逐渐稳定为int32位，long可以有多种定义，可以是32位，也可以是64位。

C++标准上只是说long至少要和int一样大，所有整数类型实现时要满足如下规范：

sizeof(char)  ==  1

sizeof(char)  <=  sizeof(short) <=  sizeof(int) <=  sizeof(long) <= sizeof(long long)

sizeof(long long) == 8	

除了`char`和`long long`，其余的类型范围较灵活，都是平台相关的，与实现相关。如果要实现平台独立的话，在windows平台上，就有`__intn`可以使用，n代表位数。`__int8、__int16、__int32、__int64`。

- 编译器数据模型的区别

|Datetype（bit）|  LP64|   ILP64  | LLP64|   ILP32   | LP32|
| :--- | :--: | :--: | :--: | :--: | :--: |
|char | 8     |     8    |     8        |    8   |       8|
|short | 16 | 16  | 16  |  16 | 16 |
|int | 32 |64   |    32  |   32     |   16|
|long| 64|       64  |     32    |       32   |      32 |
|long long| 64|64|64|64|64|
|pointer |  64   |    64 |       64          | 32 |       32|

​	一般情况下windows64位一般使用LLP64模型

​	64位Unix,Linux使用的是LP64模型

## 字符型

`char ch = 'a'`

字符型每次只能创建一个字符，并且只能用单引号`''`，一个字符内存中存储的是对应的ASCII码，占用1个字节。

- 查看ASCII码

强制转化类型：`(int)ch`

需要记住的ASCII码：`a -97` ;`A - 65`。

## 转义字符

常用的转义字符：`\n \\ \t`

| 转义字符 | 含义                               | ASCII码 |
| :------- | :--------------------------------- | :------ |
| \n       | 换行(LF)，将当前位置移到下一行开头 | 010     |
| \t       | 水平制表(HT)(跳到下一个TAB位置)    | 009     |
| \\\      | 代表一个反斜线字符 \               | 092     |
| \\'      | 单引号                             | 039     |
| \\"      | 双引号                             | 034     |
| \?       | 问号                               | 063     |

## 字符串型

### C风格字符串

- `char 变量名[] = "字符串值"`

字符串名后面需要加一个`[]`；字符是单引号，字符串是双引号。

### C++风格字符串

- `string 变量名 = ""`

头文件需要加入`#include <string>`，但是VS2019不需要。

## 基础数据类型转换

```cpp
void dataType_TypeConversion()
{
	// num to string
	int numI = 100;
	double numD = 100;
	float numF = 100;
	string strI = to_string(numI);
	string strD = to_string(numD);
	string strF = to_string(numF);

	// string to num
	string str = "100";
	numI = stoi(str);
	numD = stod(str);
	numF = stof(str);
}
```

# 运算符

| 运算符类型 | 作用             |
| ---------- | ---------------- |
| 算术运算符 | 四则运算         |
| 赋值运算符 | 赋值             |
| 比较运算符 | 比较，返回真或假 |
| 逻辑运算符 | 比较，返回真或假 |

## 算术运算符

假设变量 A 的值为 10，变量 B 的值为 20，则：

| 运算符 | 描述                             | 实例             |
| :----- | :------------------------------- | :--------------- |
| +      | 把两个操作数相加                 | A + B 将得到 30  |
| -      | 从第一个操作数中减去第二个操作数 | A - B 将得到 -10 |
| *      | 把两个操作数相乘                 | A * B 将得到 200 |
| /      | 分子除以分母                     | B / A 将得到 2   |
| %      | 取模运算符，整除后的余数         | B % A 将得到 0   |
| ++     | 整数值增加 1                     | A++ 将得到 11    |
| --     | 整数值减少 1                     | A-- 将得到 9     |

- 注意：

1. `int / int` 结果依然是整数，小数部分去除（不是四舍五入！）；

2. 只能 `int % int` ，取模运算只能是整型变量间运行；

- ++ 和 --

`++a` 前置递增 ；`a++` 后置递增；前置后置都会使 a 的值加 1。

但是 `++a 前置递增` 先让变量+1，然后进行表达式运算；`a++ 后置递增` 先进行表达式的运算，后让变量+1。

```cpp
// 前置递增
int a1 = 10;
int b1 = ++a1 * 10;
// 结果：a1=11 b1=110
    
// 后置递增
int a2 = 10;
int b2 = a2++ * 10;
// 结果：a2=11 b2=100
```

## 赋值运算符

下表列出了 C++ 支持的赋值运算符：

| 运算符 | 描述                                                         | 实例                            |
| :----- | :----------------------------------------------------------- | :------------------------------ |
| =      | 简单的赋值运算符，把右边操作数的值赋给左边操作数             | C = A + B 将把 A + B 的值赋给 C |
| +=     | 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 | C += A 相当于 C = C + A         |
| -=     | 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 | C -= A 相当于 C = C - A         |
| *=     | 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 | C *= A 相当于 C = C * A         |
| /=     | 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 | C /= A 相当于 C = C / A         |
| %=     | 求模且赋值运算符，求两个操作数的模赋值给左边操作数           | C %= A 相当于 C = C % A         |
| <<=    | 左移且赋值运算符                                             | C <<= 2 等同于 C = C << 2       |
| >>=    | 右移且赋值运算符                                             | C >>= 2 等同于 C = C >> 2       |
| &=     | 按位与且赋值运算符                                           | C &= 2 等同于 C = C & 2         |
| ^=     | 按位异或且赋值运算符                                         | C ^= 2 等同于 C = C ^ 2         |
| \|=    | 按位或且赋值运算符                                           | C \|= 2 等同于 C = C \| 2       |

## 关系运算符

下表显示了 C++ 支持的关系运算符。

假设变量 A 的值为 10，变量 B 的值为 20，则：

| 运算符 | 描述                                                         | 实例              |
| :----- | :----------------------------------------------------------- | :---------------- |
| ==     | 检查两个操作数的值是否相等，如果相等则条件为真。             | (A == B) 不为真。 |
| !=     | 检查两个操作数的值是否相等，如果不相等则条件为真。           | (A != B) 为真。   |
| >      | 检查左操作数的值是否大于右操作数的值，如果是则条件为真。     | (A > B) 不为真。  |
| <      | 检查左操作数的值是否小于右操作数的值，如果是则条件为真。     | (A < B) 为真。    |
| >=     | 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 | (A >= B) 不为真。 |
| <=     | 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 | (A <= B) 为真。   |

## 逻辑运算符

下表显示了 C++ 支持的关系逻辑运算符。

假设变量 A 的值为 1，变量 B 的值为 0，则：

| 运算符 | 描述                                                         | 实例                 |
| :----- | :----------------------------------------------------------- | :------------------- |
| &&     | 称为逻辑与运算符。如果两个操作数都 true，则条件为 true。     | (A && B) 为 false。  |
| \|\|   | 称为逻辑或运算符。如果两个操作数中有任意一个 true，则条件为 true。 | (A \|\| B) 为 true。 |
| !      | 称为逻辑非运算符。用来逆转操作数的逻辑状态，如果条件为 true 则逻辑非运算符将使其为 false。 | !(A && B) 为 true。  |

# 程序流程结构

C/C++ 支持最基本的三种程序运行结构：

- 顺序结构：程序按顺序执行，不发生跳转
- 选择结构：依据条件是否满足，有选择的执行相应功能
- 循环结构：依据条件是否满足，循环多次执行某段代码

## 选择结构

- if

```cpp
if(boolean_expression)
{
   // 如果布尔表达式为真将执行的语句
}
```

- if .. else

```cpp
if(boolean_expression)
{
   // 如果布尔表达式为真将执行的语句
}
else
{
   // 如果布尔表达式为假将执行的语句
}
```

- 多条件 if 语句

```cpp
if(boolean_expression)
{
    // 判断为真时将执行的语句
}
else if(boolean_expression)  // 第二个条件
{
    // 判断为真时将执行的语句
}
else
{
    // 判断为真时将执行的语句
}
```

- if 嵌套

```cpp
if( boolean_expression 1)
{
   // 当布尔表达式 1 为真时执行
   if(boolean_expression 2)
   {
      // 当布尔表达式 2 为真时执行
   }
}
```

- 三目运算符

 [**条件运算符 ? :**](https://www.runoob.com/cplusplus/cpp-conditional-operator.html) 可以用来替代 **if...else** 语句。它的一般形式如下：

```
Exp1 ? Exp2 : Exp3;
```

其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。

? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。

```cpp
int a = 10; int b = 20; int c = 0;
c = (a > b ? a : b);  // c 就是 a b 中最大的值
```

还可以对返回的变量继续赋值

```cpp
(a > b ? a : b) = 100;  // a b 中最大值会被重新赋值为 100
cout << "a= " << a << ", b= " << b << endl;
```

- switch

一个 **switch** 语句允许测试一个变量等于多个值时的情况。每个值称为一个 case，且被测试的变量会对每个 **switch case** 进行检查。

```cpp
switch(expression){
    case constant-expression  :
       statement(s);
       break; // 可选的
    case constant-expression  :
       statement(s);
       break; // 可选的
  
    // 您可以有任意数量的 case 语句
    default : // 可选的
       statement(s);
}
```

**switch** 语句必须遵循下面的规则：

- **switch** 语句中的 **expression** 必须是一个整型或枚举类型，或者是一个 class 类型，其中 class 有一个单一的转换函数将其转换为整型或枚举类型。
- 在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。
- case 的 **constant-expression** 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。
- 当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 **break** 语句为止。
- 当遇到 **break** 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。
- 不是每一个 case 都需要包含 **break**。如果 case 语句不包含 **break**，控制流将会 *继续* 后续的 case，直到遇到 break 为止。
- 一个 **switch** 语句可以有一个可选的 **default** case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 **break** 语句不是必需的。

![](https://www.runoob.com/wp-content/uploads/2014/09/switch_statement.jpg)

- 注意：

1. `if`后面不能加分号，不然无论是否满足条件都会执行下面语句。 
2. `switch`缺点，判断时候只能是整型或者字符型，不可以是一个区间
3. `switch`优点，结构清晰，执行效率高。

## 循环结构

### while 循环

```cpp
while(condition)
{
   statement(s);
}
```

### do...while循环

**do...while** 循环是在循环的尾部检查它的条件。

```cpp
do
{
   statement(s);

}while( condition );
```

请注意，条件表达式出现在循环的尾部，所以循环中的 statement(s) 会在条件被测试之前至少执行一次。

### for 循环

```cpp
for ( init; condition; increment )
{
   statement(s);
}
```

下面是 for 循环的控制流：

1. **init** 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。
2. 接下来，会判断 **condition**。如果为真，则执行循环主体。如果为假，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。
3. 在执行完 for 循环主体后，控制流会跳回上面的 **increment** 语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。
4. 条件再次被判断。如果为真，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为假时，for 循环终止。

示例：

```cpp
int main(){
    for (int i = 0; i < 10; i++)
    {
        cout << i << endl;
    }
    system("pause");
    return 0;
}
```

### 嵌套循环

一个循环内可以嵌套另一个循环。C++ 允许至少 256 个嵌套层次。

关于嵌套循环有一点值得注意，您可以在任何类型的循环内嵌套其他任何类型的循环。比如，一个 for 循环可以嵌套在一个 while 循环内，反之亦然。

## 跳转语句

### break

C++ 中 **break** 语句有以下两种用法：

1. 当 **break** 语句出现在一个循环内时，循环会立即终止，且程序流将继续执行紧接着循环的下一条语句。
2. 它可用于终止 **switch** 语句中的一个 case。

如果您使用的是嵌套循环（即一个循环内嵌套另一个循环），break 语句会停止执行最内层的循环，然后开始执行该块之后的下一行代码。

### continue

C++ 中的 **continue** 语句有点像 **break** 语句。但它不是强迫终止，continue 会跳过当前循环中的代码，强迫开始下一次循环。

对于 **for** 循环，**continue** 语句会导致执行条件测试和循环增量部分。对于 **while** 和 **do...while** 循环，**continue** 语句会导致程序控制回到条件测试上。

### goto

**goto** 语句允许把控制无条件转移到同一函数内的被标记的语句。

**注意：**在任何编程语言中，都不建议使用 goto 语句。因为它使得程序的控制流难以跟踪，使程序难以理解和难以修改。任何使用 goto 语句的程序可以改写成不需要使用 goto 语句的写法。

```cpp
#include <iostream>
using namespace std;
 
int main ()
{
   // 局部变量声明
   int a = 10;

   // do 循环执行
   LOOP:do
   {
       if( a == 15)
       {
          // 跳过迭代
          a = a + 1;
          goto LOOP;
       }
       cout << "a 的值：" << a << endl;
       a = a + 1;
   }while( a < 20 );
 
   return 0;
}
```

**建议：**只在退出深度循环时使用：

```cpp
for(...) {
   for(...) {
      while(...) {
         if(...) goto stop;
         .
         .
         .
      }
   }
}
stop:
cout << "Error in program.\n";
```

# 数组

C++ 支持**数组**数据结构，它可以存储一个`固定大小`的`相同类型元素`的`顺序集合`。数组是用来存储一系列数据，但它往往被认为是`一系列相同类型的变量`。

数组的声明并不是声明一个个单独的变量，比如 number0、number1、...、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers[0]、numbers[1]、...、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。

所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。

## 一维数组

### 声明数组

在 C++ 中一维数组有三种方法声明一个数组：

```cpp
// 1.使用未初始化的内存，不会补0，但是可以调用
type arrayName [ arraySize ];

// 2.使用初始化的内存，会补0
type arrayName [ arraySize ] = {};	// 会有 arraySize 个 0
type arrayName [ arraySize ] = { val1, val2 ...};	// 没有定义的话会自动补 0

// 3.长度会依据输入的数据个数而定
type arrayName[] = { val1, val2 ...};
```

这叫做一维数组。**arraySize** 必须是一个大于零的整数常量，**type** 可以是任意有效的 C++ 数据类型。

> 需要注意是：C++数组标签超过上限并不会报错，而是读未初始化的内存。

### 数组名应用

- `sizeof(arr)`

  ```cpp
  sizeof(arr);	// 统计整个数组占用内存空间
  sizeof(arr)/sizeof(arr[0]);		// 统计数组长度
  ```

- 查看首地址

  ```cpp
  cout << arr << endl;	// 可以直接查看 arr数组 首地址 // 十六进制
  cout << (int)arr << endl;	// 可以直接查看 arr数组 首地址 // 十进制
  cout << &arr[0] << endl;	// 查看 arr数组 第一个数据的 首地址
  // arr数组 首地址 == arr数组 第一个数据的 首地址
  // 验证了：数组是连续的数组空间
  ```

- 注意：

  数组名一旦创建，就是一个常量，指向一个首地址，因此不能够再进行赋值，会报错。

## 二维数组

### 声明数组

在 C++ 中一维数组有三种方法声明一个数组：

```cpp
// 1.使用未初始化的内存，不会补0
type arrayName [row][col];

// 2.使用初始化的内存，会补0
type arrayName [row][col] = {};		// 会有 row*col 个 0
// 没有定义的话会自动补 0		// 更加直观，提高可读性
type arrayName [row][col] = {{ val11, val12 ...},{ val21, val22 ...}};	
// exp:
int arr[2][3] = 
{
    {1,2,3},
    {4,5,6}
};

// 3.可以写在一起自己分行列
// 这种方式数据个数不能超过 row*col,不足的会补0		// index超过了也不会报错，会获取0
type arrayName [row][col] = {val11, val12 ...};		

// 4.只写列数
// 生成 n*col 的二维数组（矩阵），不足的会补0
type arrayName [][col] = {val11, val12 ...};	
```

> 可以看出，二维数组不声明列数的都是会报错的。

### 数组名应用

- `sizeof(arr)`

  ```cpp
  sizeof(arr);	// 统计整个数组占用内存空间
  sizeof(arr[0]);	// 统计整个数组第一行占用内存空间
  sizeof(arr[0][0]);	// 统计整个数组第一个数据占用内存空间
  
  sizeof(arr)/sizeof(arr[0]);		// 计算行数
  sizeof(arr[0])/sizeof(arr[0][0]);		// 计算列数
  sizeof(arr)/sizeof(arr[0][0]);		// 统计数组数据个数
  ```

- 查看首地址

  ```cpp
  cout << arr << endl;		// 可以直接查看 arr数组 首地址 // 十六进制
  cout << (int)arr << endl;		// 可以直接查看 arr数组 首地址 // 十进制
  cout << &arr[0][0] << endl;		// 查看 arr数组 第一个数据的 首地址
  // arr数组 首地址 == arr数组 第一个数据的 首地址
  // 验证了：数组是连续的数组空间
  ```

# 函数

函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 **main()** ，所有简单的程序都可以定义其他额外的函数。

函数**声明**告诉编译器函数的名称、返回类型和参数。函数**定义**提供了函数的实际主体。

## 函数的定义

函数的定义一般主要有5个步骤：

1. 返回值类型；有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 **void**。
2. 函数名；函数名和参数列表一起构成了函数签名。
3. 参数列表；参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。
4. 函数体语句；函数主体包含一组定义函数执行任务的语句。
5. return表达式。

- 语法：

  ```cpp
  return_type function_name( parameter list )
  {
     body of the function
  }
  ```

- 实例：

  以下是 **max()** 函数的源代码。该函数有两个参数 num1 和 num2，会返回这两个数中较大的那个数：
  
  ```cpp
  // 函数返回两个数中较大的那个数
  
  int max(int num1, int num2) 
  {
      // 局部变量声明
  	int result;
  
      if (num1 > num2)
          result = num1;
      else
          result = num2;
  
      return result; 
  }
  ```

## 函数的调用

- `function (prm1,prm2..)`即可。

## 传值调用

- 传值调用：函数调用时实参将数值传入给形参；如果形参发生改变，并不会影响实参。
- 默认情况下，C++ 使用**传值调用**来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的参数。之前提到的实例，调用 max() 函数时，使用了相同的方法。

从内从层面理解：传值调用时，会在内存里面分配出传入参数的内存，相当于复制了一份实参数据。

## 函数的声明

函数**声明**会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。

函数声明包括以下几个部分：

```
return_type function_name( parameter list );
```

针对上面定义的函数 max()，以下是函数声明：

```
int max(int num1, int num2);
```

在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：

```
int max(int, int);
```

当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。

> 声明可以有多次，定义只能有一次。

## 分文件编写

- 作用：

  让结构代码更加清晰。

  函数分文件编写一般有4个步骤：

  1. 创建后缀名为`.h`的头文件；
  2. 创建后缀名为`.cpp`的源文件；
  3. 在头文件中写函数的声明；
  4. 在源文件中写函数的定义。

- 示例：

头文件：`function.h`

```cpp
#include <iostream>
using namespace std;

// function declaration
void swap(int, int);
```

函数文件: `function.cpp`

```cpp
#include "function.h"

void swap(int num1, int num2)
{
	int temp;
	temp = num1;
	num1 = num2;
	num2 = temp;

	cout << "x= " << num1 << endl;
	cout << "y= " << num2 << endl;
}
```

主函数文件: `main.cpp`

```cpp
#include <iostream>
using namespace std;
#include "function.h"

int main()
{
	int x = 10;
	int y = 20;
	swap(x, y);
}
```

# 指针

## 基本概念

**指针的作用：**可以通过指针间接访问内存

- 内存编号是从0开始记录的，一般用十六进制数字表示
- 可以利用指针变量保存地址（理解为：指针就是一个地址）

## 指针变量的定义和使用

指针变量的语法：`变量类型 * 变量名`

```cpp
#include <iostream>
using namespace std;

int main()
{
	// 1.定义指针
	int a = 10;
	// 指针定义语法： 数据类型 * 指针变量名；
	int* p;
	// 创建指针，未记录地址前是无法输出指针的会报错:	// error C4700: 使用了未初始化的局部变量“p”
	// 让指针记录变量 a 的地址
	p = &a;
	cout << "a的地址为： " << &a << endl;
	cout << "指针p的值为： " << p << endl;
	cout << "指针p的地址为： " << &p << endl;
	cout << endl;

	// 2.使用指针
	// 可以通过解引用的方式来找到指针指向的内存	// *p
	cout << "p指向的内存内容为： " << *p << endl;
	// 通过 *p 可以访问和读写 内存内容
	*p = 1000;
	cout << "改写后，a的值变为了：" << a << endl;
	cout << "此时，*p的值变为了： " << *p << endl;
	cout << "但是p的值是没有变的为： " << p << endl;
    cout << "同时，p的内存地址&p也没有变： " << &p << endl;

	return 0;
}
```

## 指针所占内存空间

**指针也是一种数据类型**，指针占据了多少内存空间来存放16进制内存地址呢？

- 无论什么数据类型的指针

  32位操作系统：4字节

  64位操作系统：8字节

## 空指针和野指针

- **空指针**

**空指针：**指针变量指向内存中编号为0的空间

**用途：**初始化指针变量

**注意：**空指针指向的内存是不可以访问的，0~255之间的内存编号是系统占用的，因此不可以访问。

```cpp
//空指针
int* p = NULL;
//	只能查看p指针所指向的地址
cout << p << endl;	//0000000000000000
//	但是不能访问和读写
//cout << *p << endl;	//引发了异常: 读取访问权限冲突。\n p 是 nullptr。
//*p = 100;	//访问都不可，那只要再出现*p就会报错了
```

- 野指针

**野指针：** 指针指向非法的内存空间

```cpp
int* p = (int *)0x1100;		// 避免出现野指针
```

## const修饰指针*

const修饰指针有三种情况：

1. const修饰指针 -- 常量指针
2. const修饰常量 -- 指针常量
3. const既修饰指针，又修饰常量

### const修饰指针 -- 常量指针

```cpp
int a = 10; int b = 20;
const int * p = &a;		// 常量指针
```

**特点：** 指针的指向可以修改，但是指针指向的值不可以修改。

```cpp
// 指针的指向可以修改
p = &b;		// 正确写法

// 指针指向的值不可以修改
*p = 20;		// 错误写法；不能修改指向的值
```

### const修饰常量 -- 指针常量

```cpp
int a = 10; int b = 20;
int * const p = &a;
```

**特点：** 指针的指向不可以修改，但是指针指向的值可以修改。

```cpp
// 指针的指向不可以修改
p = &b;		// 错误写法；不能够修改指向

// 指针指向的值可以修改
*p = 20;		// 正确写法
```

### const既修饰指针，又修饰常量

```cpp
int a = 10; int b = 20;
const int * const p = &a;
```

**特点：** 指针的指向和指向值都不可以修改。

## 指针和数组

**作用：** 利用指针访问数组中元素

### 传递数组给函数

C++ 中通过指定不带索引的数组名来传递一个指向数组的指针。

C++ 传数组给一个函数，数组类型自动转换为指针类型，因而传的实际是地址。

如果您想要在函数中传递一个一维数组作为参数，您必须以下面三种方式来声明函数形式参数，这三种声明方式的结果是一样的，**因为每种方式都会告诉编译器将要接收一个整型指针。**同样地，您也可以传递一个多维数组作为形式参数。

- 方式1：

  ​	形式参数是一个指针：

  ```cpp
  void myFunction(int *param){...}
  ```

- 方式2：

  形式参数是一个已定义大小的数组：

  ```cpp
  void myFunction(int param[10]){...}
  ```

- 方式3：

  形式参数是一个未定义大小的数组：

  ```cpp
  void myFunction(int param[]){...}
  ```

## 指针和函数

前面讲到过，以形参的形式来传递值的话，不会改变原本的值，相当于是在内存中复制了一份，但是用指针传递就可以改变实参的值了。

```cpp
void swap(int*p1,int*p2)
{
    int temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}

// 调用
int a = 10;
int b = 20;
swap(&a, &b)		// 地址传递
```

# 结构体

结构体属于用户**自定义的数据类型**，允许用户存储不同的数据类型。

## 定义和使用

**语法：** `struct 结构体名 { 结构体成员列表 } object_names；`

`object_names` 是变量的名称

**使用：**

```cpp
struct Student
{
	// 成员列表

	// 姓名
	string name;
	// 年龄
	int age;
	// 分数
	int score;
};

// 第一种：struct Student s1
struct Student s1;
s1.name = "张三"; s1.age = 18; s1.score = 100;

// 第二种：struct Student s2 = {...}
struct Student s2 = { "李四",19,80 };		// 不足的会自动补0

    // 第三种：在创建结构体时就创建一个结构体变量
struct Student {...} s3;
s3 = { "王五",20,60 }

// 结构体对象创建时：struct 关键字可以省略
```

## 结构体数组

**作用：** 将自定义的结构体放入到数组中方便维护

**语法：** `struct 结构体名 数组名[arrNum] = { {} ,{},...{}};`

## 结构体指针

**作用：** 通过指针访问结构体中的成员

- 利用操作符` ->` 可以通过结构体指针访问结构体属性

```cpp
struct Student
{
    string name; int age; int score;
};

int main()
{
    struct Student s = {"张三",18,100};
    struct Student * p = &s;
    cout << "姓名：" << p->name << endl;		// p->name == (*p).name  
}
```

## struct 嵌套 struct

```cpp
struct Student {...};
sturct Teacher
{
    struct Student stu;
};
```

## 结构体做函数参数

**作用：** 将结构体作为参数向函数中传递；分为 `值传递` 和 `地址传递`。

```cpp
// 值传递
void function(struct Student x)
{
    cout << x.name << endl;
}

// 地址传递
void function(struct Student* p)
{
    cout << p->name << endl;
}
```

## 结构体中const的应用

- **作用:**
  1.  const防止误操作
  2. 将函数中的形参改为指针，可以减少内存空间，不会复制新的副本出来

```cpp
// 使用const 常量指针可以锁定内存的值而不受改变
void function(const struct Student*p){...}
```

