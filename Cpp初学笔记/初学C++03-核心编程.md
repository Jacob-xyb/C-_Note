# C++ 核心编程

# 内存分区模型

C++程序执行时，将内存大方向划分为4个区域

- 代码区：存放函数体的二进制代码，由操作系统进行管理的
- 全局区：存放全局变量和静态变量以及常量
- 栈区：由编译器自动分配释放，存放函数的参数值、局部变量等
- 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收

内存四区意义：

​    不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程

## 程序运行前

在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域

- 代码区：

  存放CPU执行的机器指令

  代码区是`共享`的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可

  代码区是`只读`的，使其只读的原因是防止程序意外地修改了它的指令

- 全局区：

  全局变量和静态变量存放在此

  全局区还包含了常量区，字符串常量和其他常量也存放在此

  `该区域的数据在程序结束后由操作系统释放`

---

> 变量类型

```cpp
// 全局变量
int g_a = 1;

// const修饰的全局变量
const int c_g_a = 1;

int main()
{
    // 普通局部变量
    int a = 1;
    
    // 静态变量 在普通变量前面加static，属于静态变量
    static int s_a = 10;
    
    // 常量
    // 字符串常量
    "hello word";
    
    // const修饰的变量
    //	const修饰的全局变量
    //	const修饰的局部变量  // 局部的都不放在全局区
    const int c_a = 1;
    
}
```

**总结：**

**全局区：**全局变量、静态变量、常量（字符串常量、const修饰的全局变量）

**不在全局区：**局部变量、const修饰的局部变量

## 程序运行后

- 栈区：

  由编译器自动分配释放，存放函数的参数值，局部变量等；

  注意事项：不要返回局部变量的地址，栈开启的数据由编译器自动释放。、

- 堆区：

  由程序员分配释放，若程序员不释放，程序结束时由操作系统回收

  在C++中主要利用new在堆区开辟内存

## new操作符

C++中利用`new`操作符在堆区开辟数据

堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符`delete`

语法：`new 数据类型()`

利用`new`创建的数据，会返回该数据对应的类型的指针

  ```cpp
  // 堆操作
  int * func()
  {
      // 利用new关键字 可以将数据开辟到堆区
      // new 返回是 该数据类型的指针
      // 指针 本质也是局部变量，放在栈上，指针保存的数据放在了堆区
      int* p = new int(10);		
      return p;
  }
  
  int main()
  {
      // 在堆区开辟数据
      int *p = func();
      
      // delete 释放堆区的数据
      delete p;
      
      // 堆区创建数组
      //	创建10个整型数据的数组
      int * arr = new int[10];		// 10代表数组有10个元素
      
      // delete 释放堆区的数组
      delete[] arr;
  }
  ```

  # 引用

## 引用的基本使用

作用： 给变量起别名

语法： `数据类型 &别名 = 原名`

```cpp
int a = 10;
int &b = a;		// 引用 // a和b操作的是同一块内存
```

## 引用注意事项

- 引用必须初始化
- 引用在初始化后，不可以改变

```cpp
int a = 0;
// 引用必须初始化  // 错误写法 int &b；
int &b = a;
// 引用一旦初始化后，就不能更改 // 错误写法 int &b = c;
int c = 20;

b = c;		// 赋值操作，而不是更改引用
// a、b、c 结果都是20
cout << "a=" << a << endl;
cout << "b=" << b << endl;
cout << "c=" << c << endl;
```

  ## 引用做函数参数

作用：函数传参时，可以利用引用的技术让形参修饰实参

优点：可以简化指针修改实参

```cpp
// 交换函数

// 1、值传递
void mySwap01(int a, int b)
{
    int temp = a;
    a = b;
    b = temp;
}

// 2、地址传递
void mySwap02(int* a, int* b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

// 3、引用传递
void mySwap03(int &a, int &b)
{
    int temp = a;
    a = b;
    b = temp;
}
```

## 引用做函数返回值

注意：不要返回局部变量引用；函数的调用可以作为左值存在

```cpp
int& test01()
{
    int a = 10;		// 不要返回局部变量引用
    retrun a;
}

int& test02()
{
    static a = 10;		// 静态变量，存放在全局区，在程序结束后释放
    retrun a;
}

int main()
{
    test02 = 1000;		// 如果函数的返回值是引用，这个函数调用可以作为左值
}
```

## 引用的本质

本质：引用的本质在C++内部实现是一个**指针常量**。

```cpp
// 发现是引用，转换为 int* const ref = &a;
void func(int& ref)
{
    ref = 100;		// ref是引用，转换为*ref = 100
}

int main()
{
    int a = 10;
    
    // 自动转换为 int*const ref = &a; 指针常量是指针指向不可改，也说明为什么引用不可更改
    int& ref = a;
    ref = 20;		// 内部发现ref是引用，自动帮我们转换为：*ref=20;
    cout << "a:" << a << endl;
    cout << "ref" << ref << endl;
}
```

## 常量引用

```cpp
void showValue(const int & a)
{	
    val = 1000;
    cout << "val" << val << endl;
}

int main()
{
    // 常量使用
    // 使用场景；用来修饰形参，防止误操作
    
    // int a = 10；
    
    // int& ref = 10; 引用本身需要一个合法的内存空间，因此这行错误
    // 加上 const 之后 编码器将代码修改 int temp = 10； const int & ref = temp；
    const int & ref = 10;		// 引用必须引一块合法的内存空间
    
    // 防止误操作
    int v = 10;
    showValue(v);
    
    return 0;
}
```

# 函数提高

## 函数默认参数

在C++中，函数的形参列表是可以有默认值的。

语法：`返回值类型 函数名 （参数=默认值）{}` 

- 注意

1. 默认参数往后的参数都必须有默认值；

2. 如果函数声明有默认参数，函数实现就不能有默认参数。

   这种情况编译器没有红线提示，但是的确会报错

   ```cpp
   int func2(int a = 10, int b =20)
   
   int func2(int a = 10, int b = 20)
   {
       return a + b;
   }
   
   // error: 重定义默认参数
   // 二异性
   ```

   **声明和实现只能一个有默认参数！**

## 函数占位参数

C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置

语法： `返回值类型 函数名（数据类型）{}`

```cpp
void func(int a,int)
{
    cout << "this is func" << endl;
}

// 调用时必须填写占位参数
func(10, 10);

// 占位参数还可以用默认参数
void func(int a, int = 10){...}

func(10);		// 占位参数有默认值时就可以不用传占位参数了
```

## 函数重载

作用：函数名可以相同，提高复用性

**函数重载满足条件：**

- 同一作用域下
- 函数名称相同
- 函数参数 类型不同 或者 个数不同 或者 顺序不同

```cpp
// 最主要的是函数参数 类型不同 或者 个数不同 或者 顺序不同
// 参数类型不同
void func(){...}
void func(int a){...}
void func(double a){...}

// 顺序不同
void func(int a, double b){...}
void func(double a, int b){...}

// 返回值类型不同是不作为函数重载的条件
void func(int a, double b){...}
int func(int a, double b){...}
```

**函数重载注意事项：**

- 引用作为重载条件
- 函数重载碰到函数默认参数

```cpp
// 引用作为重载条件
void func(int &a){...}
void func(const int &a){...}

int a = 10;
func(a);		// 调用第一个，因为 a 可读可写
fucn(10);		// 调用第二个，因为 10 可读不可写
// const int& a = 10
// 此时会在内存给a开辟一个可读不可写的空间，所以是合法的

// 函数重载碰到函数默认参数
void func(int a, int b =10){...}
void func(int a){...}
func(10);		// 此时出现了二异性，编译器不知道应该加载哪个函数
// 尽量避免这种情况，写函数重载时不要写默认参数
```

# 类和对象

C++面向对象的三大特性：`封装、继承、多态`

C++认为万事万物皆为对象，对象上有其属性和行为

## 封装

- 意义

  将属性和行为作为一个整体，表现生活中的事物

  将属性和行为加以权限控制

### 封装

将属性和行为作为一个整体，表现事物

语法：`class 类型{ 访问权限： 属性/行为 };`

```cpp
class 类名
{
    // 访问权限
    // 属性
    // 行为
};
```

示例1：

​	设计一个圆类，求圆的周长

思路：

- 圆周长的公式： 2 * pi * radius
- 因此圆类需要一个 radius 即可

代码：

```cpp
class Circle
{
    // 访问权限
    // 	公共权限
public:
    // 属性
    //	半径
    int m_r:
     
    // 行为
    //	获取圆的周长
    double calculateZC()
    {
        return 2 * 3.14 * m_r;
    }
};

int main()
{
    // 通过圆类 创建具体的圆（对象）
    // 实例化 ： 通过一个类，创建一个对象的过程
    Circle c1;
    // 给圆对象的属性进行赋值
    c1.m_r = 10;
    // 计算周长
    ret = c1.calculateZC();
}
```

示例2：

​	设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号

代码：

```cpp
class Student
{
public:
    string m_name;
    int m_id;
    void prt()
    {
        cout << "姓名：" << m_name << endl;
        cout << "学号：" << m_id << endl;
    }
    // 通过行为给属性赋值
    void setName(string name)
    {
        m_name = name;
    }
    void setId(int id)
    {
        m_id = id;
    }
        
}
```

- 注意

  类中的属性和行为 我们统一称为 成员

  ​	属性： 成员属性 成员变量

  ​	行为： 成员函数 成员方法

### 访问权限

访问权限有三种：

- public		公共权限
  - 成员	类内可以访问	类外可以访问
- protected	保护权限
  - 成员	类内可以访问	类外不可以访问
  - 儿子可以访问  保护内容
- private		私有权限
  - 成员	类内可以访问	类外不可以访问
  - 儿子不可以访问  私有内容

### struct 和 class 区别

唯一区别在于 默认的访问权限不同

区别：

- struct 默认权限为公共
- class 默认权限为私有

### 成员属性设置为私有

优点1：将所有成员属性设置为私有，可以自己控制读写权限

有点2：对于写权限，我们可以检测数据的有效性

## 对象的初始化和清理

### 构造函数和析构函数

对象的初始化和清理也是两个非常重要的安全问题

C++利用 **构造函数** 和 **析构函数** 解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。

对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供编译器提供的构造函数和析构函数，但是是空实现。

- 构造函数：主要作用于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。
- 析构函数：主要作用于对象 **销毁前** 系统自动调用，执行一些清理工作。

**构造函数语法：** `类名(){}`

1. 构造函数，没有返回值也不写void
2. 函数名称与类名相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序在调用对象时候会自动调用构造，无需手动调用，而且只会调用一次

**析构函数语法：** `~类名(){}`

1. 析构函数，没有返回值也不写void
2. 函数名称与类名相同，在名称前加上`~`
3. 析构函数不可以有参数，因此不可以发生重载
4. 程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次

- 个人理解

  构造函数会自动调用，与python的`__init__()`很像

  ```cpp
  class Person
  {
  public:
      Person()
      {
          cout << "调用构造函数" << endl;
      }
      ~Person()
      {
          cout << "调用析构函数" << endl;
      }
  };
  ```

### 构造函数的分类及调用

两种分类方式：

​	按参数分：有参构造和无参构造

​	按类型分：普通构造和拷贝构造

三种调用方式：

​	括号法（推荐）

​	显示法

​	隐式转换法

```cpp
class Person
{
public:
    int m_age;
public:
    // 按参数分
    // 	无参构造函数（默认构造函数）
    Person()
    {
        cout << "Person无参构造函数" << endl;
    }
    // 	有参构造函数
    Person(int a)
    {
        cout << "Person有参构造函数" << endl;
        int m_age = a;
    }
    
    // 拷贝构造函数
    Person(const Person& p)
    {
        cout << "Person拷贝构造函数" << endl;
        m_age = p.m_age
    }
    ~Person()
    {
        cout << "调用析构函数" << endl;
    }
};

// 调用
void test()
{
    // 1.括号法
    Person p1;		// 默认构造函数调用
    Person p2(10);		// 有参构造函数调用
    Person p3(p2);		// 拷贝构造函数调用
    // 注意：调用默认构造函数时候，不要加()
    // 因为下面这行代码，编译器会认为是一个函数的声明,不会认为在创建对象
    // Person p1();
    
    // 2.显示法
    Person p4;
    Person p5 = Person(10);		// 有参构造
    Person p6 = Person(p5);		// 拷贝构造
    
    Person(10);		// 匿名对象	特点：当前行执行结束后，系统会立即回收掉匿名对象
    cout << "aaa" << endl;		// 测试发现会在 'aaa' 之前进行构造和析构
    // 注意：不要利用拷贝构造函数初始化匿名对象
    // 因为编译器会认为 Person(p6) == Person p6；对象重定义
    // Person(p6);
    
    // 3.隐式转换法
    Person p7 = 10;		// 相当于 Person p7 = Person(10);
    Person p8 = p7;
}
```

### 拷贝构造函数的调用时机

C++ 中拷贝构造函数调用时机

- 使用一个已经创建完毕的对象来初始化一个对象
- 值传递的方式给函数参数传值
- 以值方式返回局部对象

```cpp
class Person
{
public:
    Person(){...}		// 默认构造函数
    Person(int age){...}		//有参构造函数
    Person(const Person& p){...}		// 拷贝构造函数
    ~Person(){...}		// 析构函数
};

// 1.使用一个已经创建完毕的对象来初始化一个对象
void test01()
{
    Person p1(20);
    Person p2(p1);
    // 此时 p2 会调用 拷贝构造函数
    // 最常用的调用时机
}

// 2.值传递的方式给函数参数传值
void doWork(Person px)
{
    
}

void test02()
{
    Person p;
    doWork(p);
    // 在函数 doWork 中，实参传给形参是， Person px = p, 调用拷贝构造函数
}

// 3.以值方式返回局部对象
Person doWork2()
{
    Person p1;
    return p1;  
}

void test03()
{
    Person p = doWork2();		// return p1 时，也会返回一个拷贝对象，因为 p1 是doWork2中的局部变量
}
```

### 构造函数调用规则

