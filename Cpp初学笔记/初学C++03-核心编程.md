# C++ 核心编程

# 内存分区模型

C++程序执行时，将内存大方向划分为4个区域

- 代码区：存放函数体的二进制代码，由操作系统进行管理的
- 全局区：存放全局变量和静态变量以及常量
- 栈区：由编译器自动分配释放，存放函数的参数值、局部变量等
- 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收

内存四区意义：

​    不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程

## 程序运行前

在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域

- 代码区：

  存放CPU执行的机器指令

  代码区是`共享`的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可

  代码区是`只读`的，使其只读的原因是防止程序意外地修改了它的指令

- 全局区：

  全局变量和静态变量存放在此

  全局区还包含了常量区，字符串常量和其他常量也存放在此

  `该区域的数据在程序结束后由操作系统释放`

---

> 变量类型

```cpp
int global_a = 1;           //全局变量
int global_b = 1;           //全局变量
const int CstG_a = 1;       //const修饰的全局变量 - 全局常量
const int CstG_b = 1;       //const修饰的全局变量 - 全局常量
void ParamType_001()
{
    //局部变量
    int a = 1;
    int b = 1;

    //静态变量
    static int static_a = 1;
    static int static_b = 1;

    //常量
    //  字符串常量
    cout << "字符串常量的地址：\t\t" << (int)&"hello" << endl;
    //  const修饰的变量
    //      const修饰的全局变量 - 全局常量
    //      const修饰的局部变量 - 局部常量
    const int Cst_a = 1;
    const int Cst_b = 1;

    //输出
    cout << "全局变量 global_a 地址：\t" << (int)&global_a << endl;
    cout << "全局变量 global_b 地址：\t" << (int)&global_b << endl;
    cout << "局部变量 a 地址：\t\t" << (int)&a << endl;
    cout << "局部变量 b 地址：\t\t" << (int)&b << endl;
    cout << "静态变量 static_a 地址：\t" << (int)&static_a << endl;
    cout << "静态变量 static_b 地址：\t" << (int)&static_b << endl;
    cout << "全局常量 CstG_a 地址：\t\t" << (int)&CstG_a << endl;
    cout << "全局常量 CstG_b 地址：\t\t" << (int)&CstG_b << endl;
    cout << "局部常量 Cst_a 地址：\t\t" << (int)&Cst_a << endl;
    cout << "局部常量 Cst_b 地址：\t\t" << (int)&Cst_b << endl;

    //总结:局部不在全局区，其余(全局变量、静态变量、常量)都在全局区
}
```

输出

```cpp
字符串常量的地址：              -945122828
全局变量 global_a 地址：        -945069968
全局变量 global_b 地址：        -945069964
局部变量 a 地址：               305461044
局部变量 b 地址：               305461076
静态变量 static_a 地址：        -945069960
静态变量 static_b 地址：        -945069956
全局常量 CstG_a 地址：          -945161288
全局常量 CstG_b 地址：          -945161284
局部常量 Cst_a 地址：           305461108
局部常量 Cst_b 地址：           305461140
```

**总结：**

**全局区：**全局变量、静态变量、常量（字符串常量、const修饰的全局变量）

**不在全局区：**局部变量、const修饰的局部变量

## 程序运行后

- 栈区：

  由编译器自动分配释放，存放函数的参数值，局部变量等；

  注意事项：不要返回局部变量的地址，栈开启的数据由编译器自动释放。

```cpp
int* func_Stack_001()
{
    int a = 10; //局部变量  //存放在栈区，栈区的数据在函数执行完后自动释放
    return &a;
}
void Stack_001()
{
    /*注意事项*/
    //  不要返回局部变量的地址
    int* p = func_Stack_001();
    cout << *p << endl;     //能够正常输出10是因为编译器做了保留
}
```

- 堆区：

  由程序员分配释放，若程序员不释放，程序结束时由操作系统回收

  在C++中主要利用new在堆区开辟内存

## new操作符

C++中利用`new`操作符在堆区开辟数据

堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符`delete`

语法：`new 数据类型()`

利用`new`创建的数据，会返回该数据对应的类型的指针

  ```cpp
int* func_Heap_001()
{
    //利用new关键字 可以将数据开辟到堆区
    //  指针也是局部变量，存放在栈区
    int* p = new int(10);   //new 返回的是该类型的指针
    int* arr = new int[10]; //10代表数组有10个元素，返回数组的首地址
    delete[] arr;           //手动释放数组
    return p;
}
void Heap_001()
{
    //在堆区开辟数据
    int* p = func_Heap_001();   //程序执行完自动释放
    delete p;                   //也可以手动释放
    //cout << *p << endl;       //error:读取访问权限冲突。
}
  ```

  # 引用

## 引用的基本使用

作用： 给变量起别名

语法： `数据类型 &别名 = 原名`

```cpp
int a = 10;
int &b = a;		// 引用 // a和b操作的是同一块内存
```

## 引用注意事项

- **引用必须初始化**
- **引用在初始化后，不可以改变**

```cpp
int a = 0;
// 引用必须初始化  // 错误写法 int &b；
int &b = a;
// 引用一旦初始化后，就不能更改 // 错误写法 int &b = c;
int c = 20;

b = c;		// 赋值操作，而不是更改引用
// a、b、c 结果都是20
cout << "a=" << a << endl;
cout << "b=" << b << endl;
cout << "c=" << c << endl;
```

## 引用做函数参数

作用：函数传参时，可以利用引用的技术让形参修饰实参

优点：可以简化指针修改实参

```cpp
// 交换函数

// 1、值传递
void mySwap01(int a, int b)
{
    int temp = a;
    a = b;
    b = temp;
}

// 2、地址传递
void mySwap02(int* a, int* b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

// 3、引用传递
void mySwap03(int &a, int &b)
{
    int temp = a;
    a = b;
    b = temp;
}
```

## 引用做函数返回值

注意：不要返回局部变量引用；函数的调用可以作为左值存在

```cpp
int& test01()
{
    int a = 10;		// 不要返回局部变量引用
    retrun a;
}

int& test02()
{
    static a = 10;		// 静态变量，存放在全局区，在程序结束后释放
    retrun a;
}

int main()
{
    int& ref = test02();
    cout << ref << endl;	//10
    test02 = 1000;			// 如果函数的返回值是引用，这个函数调用可以作为左值
    cout << ref << endl;	//1000
}
```

## 引用的本质

本质：引用的本质在C++内部实现是一个**指针常量**。

```cpp
// 发现是引用，转换为 int* const ref = &a;
void func(int& ref)
{
    ref = 100;		// ref是引用，转换为*ref = 100
}

int main()
{
    int a = 10;
    
    // 自动转换为 int*const ref = &a; 指针常量是指针指向不可改，也说明为什么引用不可更改
    int& ref = a;
    ref = 20;		// 内部发现ref是引用，自动帮我们转换为：*ref=20;
    cout << "a:" << a << endl;
    cout << "ref" << ref << endl;
    
    func(a);
    return 0;
}
```

## 常量引用

```cpp
void showValue(const int & val)
{	
    val = 1000;	//不允许修改
    cout << "val" << val << endl;
}

int main()
{
    // 常量使用
    // 使用场景；用来修饰形参，防止误操作
    
    // int a = 10；
    
    // int& ref = 10; 引用本身需要一个合法的内存空间，因此这行错误
    // 加上 const 之后 编码器将代码修改 int temp = 10； const int & ref = temp；
    const int & ref = 10;		// 引用必须引一块合法的内存空间
    //因为 int& ref == int* const p 
    //所以 const int& ref == const int* const p	//p不可变，*p不可变
    
    // 防止误操作
    int v = 10;
    showValue(v);
    
    return 0;
}
```

# 函数提高

## 函数默认参数

在C++中，函数的形参列表是可以有默认值的。

语法：`返回值类型 函数名 （参数=默认值）{}` 

- 注意

1. `默认参数往后的参数都必须有默认值；`

2. 如果函数声明有默认参数，函数实现就不能有默认参数。

   这种情况编译器没有红线提示，但是的确会报错

   ```cpp
   //默认参数
   int func_DefaultParam_001(int a = 10, int b = 20)
   {
   	return a + b;
   }
   void func_DefaultParam_001t()
   {
   	//如果传入数据就用传入的数据，否则就用默认值
   	cout << func_DefaultParam_001()			<< endl;	//30
   	cout << func_DefaultParam_001(30, 40)	<< endl;	//70
	cout << func_DefaultParam_001(80)		<< endl;	//100
   }
   //声明和实现
   int func_DefaultParam_002(int a = 10, int b = 20);
   int func_DefaultParam_002(int a, int b)
   {
   	return a + b;
   }
   void func_DefaultParam_002t()
   {	
   	//函数声明中有默认参数，定义就不能有，反之亦然
   	cout << func_DefaultParam_002() << endl;	//30
   	//error C2572: “func_DefaultParam_002”: 重定义默认参数 : 参数 1s
   }
   // error: 重定义默认参数
   // 二异性
   ```
   
   **`声明和实现只能一个有默认参数！`**

## 函数占位参数

C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置

语法： `返回值类型 函数名（数据类型）{}`

```cpp
void func(int a,int)
{
    cout << "this is func" << endl;
}

// 调用时必须填写占位参数
func(10, 10);

// 占位参数还可以用默认参数
void func(int a, int = 10){...}

func(10);		// 占位参数有默认值时就可以不用传占位参数了
```

占位参数意义不大，但是高级用法中会用到

## 函数重载**

作用：函数名可以相同，提高复用性

**函数重载满足条件：**

- 同一作用域下
- 函数名称相同
- 函数参数 类型不同 或者 个数不同 或者 顺序不同

```cpp
// 最主要的是函数参数 类型不同 或者 个数不同 或者 顺序不同
// 参数类型不同
void func(){...}
void func(int a){...}
void func(double a){...}

// 顺序不同
void func(int a, double b){...}
void func(double a, int b){...}

// 返回值类型不同是不作为函数重载的条件
void func(int a, double b){...}
int func(int a, double b){...}
```

**函数重载注意事项：**

- 引用作为重载条件
- 函数重载碰到函数默认参数

```cpp
// 引用作为重载条件
void func(int &a){...}
void func(const int &a){...}

int a = 10;
func(a);		// 调用第一个，因为 a 可读可写
fucn(10);		// 调用第二个，因为 10 可读不可写
// int& a = 10 是不成立的，因为引用必须指向合法的内存空间
// const int& a = 10	//const int& a 不可读不可写 与 int& a 可以区分开来
// 此时会在内存给a开辟一个可读不可写的空间，所以是合法的

// 函数重载碰到函数默认参数
void func(int a, int b =10){...}
void func(int a){...}
func(10);		// 此时出现了二异性，编译器不知道应该加载哪个函数
// 尽量避免这种情况，写函数重载时不要写默认参数
```

# 类和对象

C++面向对象的三大特性：`封装、继承、多态`

C++认为万事万物皆为对象，对象上有其属性和行为

## 封装

封装的意义：

- 将属性和行为作为一个整体，表现生活中的事物

- 将属性和行为加以权限控制

### 封装

将属性和行为作为一个整体，表现事物

语法：`class 类型{ 访问权限： 属性/行为 };`

```cpp
class 类名
{
    // 访问权限
    // 属性
    // 行为
};
```

示例1：

​	设计一个圆类，求圆的周长

思路：

- 圆周长的公式： 2 * pi * radius
- 因此圆类需要一个 radius 即可

代码：

```cpp
class Circle
{
    // 访问权限
    // 	公共权限
public:
    // 属性
    //	半径
    int m_r:
     
    // 行为
    //	获取圆的周长
    double calculateZC()
    {
        return 2 * 3.14 * m_r;
    }
};

int main()
{
    // 通过圆类 创建具体的圆（对象）
    // 实例化 ： 通过一个类，创建一个对象的过程
    Circle c1;
    // 给圆对象的属性进行赋值
    c1.m_r = 10;
    // 计算周长
    ret = c1.calculateZC();
}
```

示例2：

​	设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号

代码：

```cpp
class Student
{
public:		//权限
	//属性
	string mName;
	int mId;
	//行为
	void showStudent()
	{
		cout << "姓名: " << this->mName << endl;
		cout << "学号: " << this->mId	<< endl;
	}
	//	赋值函数
	void setName(string& name) { this->mName = name; }
	void setId(int id) { this->mId = id; }
};
```

- 注意

  类中的`属性`和`行为` 我们统一称为 `成员`

  - `属性： 成员属性 成员变量`

  - `行为： 成员函数 成员方法`

### 访问权限

访问权限有三种：

- public		公共权限
  - 成员	类内可以访问	类外可以访问
- protected	保护权限
  - 成员	类内可以访问	类外不可以访问
  - 儿子可以访问  保护内容
- private		私有权限
  - 成员	类内可以访问	类外不可以访问
  - 儿子不可以访问  私有内容

### struct 和 class 区别

struct 和 class 的唯一区别在于 `默认的访问权限不同`

区别：

- struct 默认权限为公共
- class 默认权限为私有

### 成员属性设置为私有

优点1：将所有成员属性设置为私有，可以自己控制读写权限

优点2：对于写权限，我们可以检测数据的有效性

```cpp
class PersonPermission01
{
public:
	//写姓名
	//字符串最好不要用引用，直接输入字符串时，无法用引用传参
	void setName(string name) {this->mName = name;}
	//读姓名
	string getName() {return this->mName;}
	//只读年龄
	int getAge() { this->mAge = 18; return this->mAge; }
	//只写爱好
	void setHobby(string hobby) { this->mHobby = hobby; }
private:
	string mName;		//可读可写
	int mAge;			//只读
	string mHobby;		//只写
};
void Class_Permission01()
{
	PersonPermission01 p1;
	p1.setName("张三");
	cout << p1.getName()	<< endl;
	cout << p1.getAge()		<< endl;
	p1.setHobby("coding");
}
```

## 对象的初始化和清理

### 构造函数和析构函数*

对象的初始化和清理也是两个非常重要的安全问题

C++利用 **构造函数** 和 **析构函数** 解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。

对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，

编译器会提供编译器提供的构造函数和析构函数，但是是空实现。

- 构造函数：主要作用于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。
- 析构函数：主要作用于对象 **销毁前** 系统自动调用，执行一些清理工作。

**构造函数语法：** `类名(){}`

1. **构造函数，没有返回值也不写void**
2. 函数名称与类名相同
3. **构造函数可以有参数，因此可以发生重载**
4. 程序在调用对象时候会自动调用构造，无需手动调用，而且只会调用一次

**析构函数语法：** `~类名(){}`

1. **析构函数，没有返回值也不写void**
2. 函数名称与类名相同，在名称前加上`~`
3. **析构函数不可以有参数，因此不可以发生重载**
4. 程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次

- 个人理解

  构造函数会自动调用，与python的`__init__()`很像

  ```cpp
  class PersonJx001
  {
  public:
  	//构造函数
  	PersonJx001()
  	{
  		cout << "构造函数的调用" << endl;
  	}
  	//析构函数
  	~PersonJx001()
  	{
  		cout << "析构函数的调用" << endl;
  	}
  };
  void Class_Jx002()
  {
  	PersonJx001 p1;
  	cout << "this is a pause.." << endl;
  }
  ```

### 构造函数的分类及调用

两种分类方式：

​	按参数分：有参构造和无参构造

​	按类型分：普通构造和拷贝构造

三种调用方式：

​	括号法（推荐）

​	显示法

​	隐式转换法

```cpp
class PersonJx002
{
public:
	//无参构造函数
	PersonJx002()
	{
		cout << "无参构造函数的调用" << endl;
	}
	PersonJx002(int a)
	{
		this->mAge = a;
		cout << "有参构造函数的调用" << endl;
	}

	//拷贝构造函数
	PersonJx002(const PersonJx002& p)
	{
		mAge = p.mAge;
		cout << "拷贝构造函数的调用" << endl;
	}
	
	//析构函数
	~PersonJx002()
	{
		cout << "年龄为 " << mAge << " 的对象被析构" << endl;
	}

	int getAge() { return mAge; }
private:
	int mAge;
};
void Class_Jx003()
{
	//1.括号法
	PersonJx002 p1;		//调用无参构造函数
	cout << p1.getAge() << endl;
	PersonJx002 p2(10);	//调用有参构造函数
	cout << p2.getAge() << endl;

	PersonJx002 p3(p2);	//调用拷贝构造函数
	cout << p3.getAge() << endl;

	//2.显式法
	PersonJx002 p4;		//PersonJx002 p4();	写法错误，会认为是一个函数声明.
	PersonJx002 p5 = PersonJx002(20);
	PersonJx002 p6 = PersonJx002(p5);

	//注意事项
	PersonJx002(30);		// 匿名对象	特点：当前行执行结束后，系统会立即回收掉匿名对象
	cout << "aaa" << endl;		// 测试发现会在 'aaa' 之前进行构造和析构
	// 注意：不要利用拷贝构造函数初始化匿名对象
	// 因为编译器会认为 PersonJx002(p6) 是 PersonJx002 p6；对象重定义
	// PersonJx002(p6);

	//3.隐式转换法
	PersonJx002 p7 = 40;	//有参构造
	PersonJx002 p8 = p7;	//拷贝构造
}
```

### 拷贝构造函数的调用时机

C++ 中拷贝构造函数调用时机

- 使用一个已经创建完毕的对象来初始化一个对象
- 值传递的方式给函数参数传值
- 以值方式返回局部对象

```cpp
class Person
{
public:
    Person(){...}		// 默认构造函数
    Person(int age){...}		//有参构造函数
    Person(const Person& p){...}		// 拷贝构造函数
    ~Person(){...}		// 析构函数
};

// 1.使用一个已经创建完毕的对象来初始化一个对象
void test01()
{
    Person p1(20);
    Person p2(p1);
    // 此时 p2 会调用 拷贝构造函数
    // 最常用的调用时机
}

// 2.值传递的方式给函数参数传值
void doWork(Person px)
{
    
}

void test02()
{
    Person p;
    doWork(p);
    // 在函数 doWork 中，实参传给形参是， Person px = p, 调用拷贝构造函数
}

// 3.以值方式返回局部对象
Person doWork2()
{
    Person p1;
    return p1;  
};

void test03()
{
    Person p = doWork2();		// return p1 时，也会返回一个拷贝对象，因为 p1 是doWork2中的局部变量
}
```

### 构造函数调用规则*

默认情况下，c++编译器至少给一个类添加3个函数

1. 默认构造函数（无参，函数体为空）
2. 默认析构函数（无参，函数体为空）
3. 默认拷贝构造函数，对属性进行值拷贝

构造函数调用规则如下：

- `如果用户定义有参构造函数，c++不再提供 默认无参构造，但是会提供默认拷贝构造`
- `如果用户定义拷贝构造函数，c++不再提供其他构造函数`

```cpp
// 1.创建一个类时，c++编译器会给每个类都添加至少3个函数
// 默认构造（空实现）
// 析构函数（空实现）
// 拷贝函数（值拷贝）
class Person
{
public:
    // 默认构造函数
    Person()
    {
        cout << "Person的默认构造函数调用" << endl;
    }
    Person(int age)		// 有参构造函数
    {
        cout << "Person的有参构造函数调用" << endl;
        m_age = age;
    }
    Person(const Person& p)		// 拷贝构造函数
    {
        cout << "Person的拷贝构造函数调用" << endl;
        m_age = p.m_age;
    }
    ~Person()
    {
        cout << "Person的析构函数调用" << endl;
    }
private:
    int m_age;   
};

// 可以写个test函数来检验一下构造函数调用规则
```

### 深拷贝和浅拷贝

深浅拷贝是面试经典问题，也是个常见的坑。

浅拷贝：简单的赋值拷贝操作

深拷贝：在堆区重新申请空间，进行拷贝操作

- 错误示例

  由于默认的拷贝构造函数是浅拷贝，所以同一空间释放了两次。

```cpp
class PersonJx003
{
public:
	//无参构造函数
	PersonJx003()
	{
		cout << "无参构造函数的调用" << endl;
	}
	//有参构造函数
	PersonJx003(int age, int height)
	{
		this->mAge = age;
		this->mHeight = new int(height);
		cout << "有参构造函数的调用" << endl;
	}
	~PersonJx003()
	{
		if (mHeight)
		{
			delete mHeight;
			mHeight = NULL;
		}
		cout << "析构函数的调用" << endl;
	}
public:
	int mAge;
	int *mHeight;	//将此数据创建到堆区
};
void Class_Jx004()
{
	PersonJx003 p1(18, 160);	//有参构造
	PersonJx003 p2(p1);			//拷贝构造函数，此时属于浅拷贝函数
	cout << "p1的年龄" << p1.mAge << endl;
}
```

![image-20210908111304579](https://i.loli.net/2021/09/08/nFtLzVHIGZh8fmo.png)

- 深拷贝写法

  自己实现拷贝构造函数，解决浅拷贝带来的问题

```cpp
class PersonJx003
{
public:
	//无参构造函数
	PersonJx003()
	{
		cout << "无参构造函数的调用" << endl;
	}
	//有参构造函数
	PersonJx003(int age, int height)
	{
		this->mAge = age;
		this->mHeight = new int(height);
		cout << "有参构造函数的调用" << endl;
	}
	//用深拷贝重写拷贝构造函数	//默认拷贝构造函数是浅拷贝
	PersonJx003(const PersonJx003& p)
	{
		this->mAge = p.mAge;
		this->mHeight = new int(*p.mHeight);
		cout << "拷贝构造函数的调用" << endl;
	}
	~PersonJx003()
	{
		if (mHeight)
		{
			delete mHeight;
			mHeight = NULL;
		}
		cout << "析构函数的调用" << endl;
	}
public:
	int mAge;
	int *mHeight;	//将此数据创建到堆区
};
void Class_Jx004()
{
	PersonJx003 p1(18, 160);	//有参构造
	PersonJx003 p2(p1);			//拷贝构造函数，此时属于浅拷贝函数
	cout << "p1的年龄" << p1.mAge << endl;
}
```

### 初始化列表

**作用：** C++ 提供了初始化列表语法，用来初始化属性

**语法：** `构造函数() :属性1(值1), 属性2(值2) ... {}`

```cpp
class PersonJx004
{
public:
	//传统初始化操作
	/*PersonJx004(int a, int b, int c)
	{
		mA = a;
		mB = b;
		mC = c;
	}*/

	//初始化列表创建无参构造函数
	PersonJx004():mA(10),mB(20),mC(30){}

	//有参构造函数也可以用初始化列表改写
	PersonJx004(int a, int b, int c):mA(a), mB(b), mC(c) {}
public:
	int mA;
	int mB;
	int mC;
};
void Class_Jx005()
{
	PersonJx004 p1;
	cout << p1.mA << "\t" << p1.mB << "\t" << p1.mC << endl;
	PersonJx004 p2(11, 22, 33);
	cout << p2.mA << "\t" << p2.mB << "\t" << p2.mC << endl;
}
```

### 类对象作为类成员

C++ 类中的成员可以是另一类的对象，我们称该成员为 对象成员

例如：

```cpp
class A{};
class B
{
    A a;
};
```

如果B类中有对象A作为成员，A为对象成员

那么创建B对象时，A与B的构造和析构的顺序是谁先谁后？

**示例：**

```cpp
class Phone
{
public:
    Phone(string pName)
    {
        m_pName = pName;
        cout << "Phone构造函数调用" << endl;
    }
    string m_pName;
};
class Person
{
public:
    // Phone m_phone = pName;  // 隐式转换法
    Person(string name,string pName) :m_name(name),m_phone(pName)
    {
        cout << "Person构造函数调用" << endl;
    }
    string m_name;
    Phone m_phone;
};
```

当其他类对象作为本类成员，构造时候先构造其他类对象，再构造自身，析构的顺序相反，类在栈区，先进后出。

### 静态成员

静态成员就是在成员变量和成员函数前加上关键字`static`，称为静态成员。

可以理解为，静态对象属于独立的对象。

静态成员分为：

- 静态成员变量
  - 所有对象共享同一份数据
  - 在编译阶段分配内存
  - 类内声明，类外初始化
- 静态成员函数
  - 所有对象共享一个函数
  - 静态成员函数只能访问静态成员变量

```cpp
class PersonJx005
{
public:
	//静态成员函数
	static void func()
	{
		cout << "静态成员函数的调用" << endl;
		mA = 100;		//静态成员函数可以访问静态成员变量
		//mB = 200;		//静态成员函数不能访问非静态成员变量

	}
	//静态成员变量
	static int mA;
	//非静态成员变量
	int mB;
private:
	//静态成员函数也是有访问权限的
	static void func2()
	{
		cout << "私有的静态成员函数的调用" << endl;
	}
};
//	初始化静态成员变量
int PersonJx005::mA = 0;
void Class_Jx006()
{
	//1.通过对象访问
	PersonJx005 p1;
	p1.func();

	//2.通过类名访问
	PersonJx005::func();
}
```

## C++对象模型和this指针

### 成员变量和成员函数分开存储

在C++中，类内的成员变量和成员函数分开存储

只有非静态成员变量才属于类的对象上

- 空对象

```cpp
class Person
{
};
void test01()
{
    Person p;
    // 空对象占用内存空间为：1
    // C++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置
    // 每个空对象也应该有一个独一无二的内存地址
    cout << "size of p = " << sizeof(p) << endl;
}
```

- 非静态成员

```cpp
class Person
{
    int m_A;        // 非静态成员  // 属于类对象上的
};
void test01()
{
    Person p;
    // 非空对象占用内存空间为：4
    cout << "size of p = " << sizeof(p) << endl;
}
```

- 静态成员

```cpp
class Person
{
    int m_A;        // 非静态成员  // 属于类对象上的
    static int m_B;     // 静态成员     // 不属于类对象上的
};
int Person::m_B = 0;

void test01()
{
    Person p;
    // 类对象占用内存空间为：4
    // 类对象占用空间并没有发生改变
    cout << "size of p = " << sizeof(p) << endl;
}
```

- 成员函数

```cpp
class Person
{
    int m_A;        // 非静态成员  // 属于类对象上
    static int m_B;     // 静态成员     // 不属于类对象上
    void func(){}       // 非静态成员函数  // 不属于类对象上
};
void test01()
{
    Person p;
    // 类对象占用内存空间为：4
    // 成员函数 静态 和 非静态 都不属于类，均是独一无二的存在 
    cout << "size of p = " << sizeof(p) << endl;
}

int Person::m_B = 0;
```

- 总结

只有 非静态成员变量 属于 类对象上

### this 指针概念

上节中了解到 C++ 中成员变量和成员函数是分开存储的

每个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码

那么问题是：这一块代码是如何区分哪个对象调用自己的呢？



C++通过提供特殊的对象指针，this指针，解决上述问题。**this指针指向被调用的成员函数所属的对象**



this指针是隐含每一个非静态成员函数内的一种指针

this指针不需要定义，直接使用即可



this指针的用途：

- 当形参和成员变量同名时，可用this指针来区分
- 在类的非静态成员函数中返回对象本身，可使用 `return *this`

**示例：**

- 解决名称冲突

```cpp
class Person
{
public:
    Person(int age)
    {
        age = age;
    }
    int age;
};
void test01()
{
    Person p1(18);
    // 年龄： - 858993460
    cout << "年龄： " << p1.age << endl;
}
```

此时在类的构造函数中，3个`age`被认为是同一个对象，所以无法产生赋值操作。

解决办法，可以在定义类时，用加前缀的方式命名成员变量，以示区分；或者用this指针来告诉编译器哪个变量才是类的成员变量。

```cpp
// this指针的方式
class Person
{
public:
    Person(int age)
    {
        this->age = age;
    }
    int age;
};
void test01()
{
    Person p1(18);
    // 年龄：18 显示正常
    cout << "年龄： " << p1.age << endl;
}
```

- 返回对象本身

```cpp
class PersonJx006
{
public:
	PersonJx006() {}	//如果用户定义有参构造函数，c++不再提供默认无参构造，但是会提供默认拷贝构造
	PersonJx006(int age)
	{
		this->mAge = age;
	}
	/*无返回值*/
	//void PersonAddAge(PersonJx006& p)
	//{
	//	this->mAge += p.mAge;
	//}
	/*返回对象的引用*/
	PersonJx006& PersonAddAge(PersonJx006& p)
	{
		this->mAge += p.mAge;
		//this指向实例化对象，而*this就是解引用，也就是实例化对象本体
		return *this;
	}
	/*返回对象的拷贝*/
	//PersonJx006 PersonAddAge(PersonJx006& p)
	//	此时返回的时候会创建一个新的对象，注意区分

	int mAge;
};
void Class_Jx007()
{
	PersonJx006 p1(10);
	PersonJx006 p2(18);
	p1.PersonAddAge(p2);	//这样当然是可以的
	cout << p1.mAge << endl;
	//如果想采用链式编程，调用的函数就得返回对象本身
	p1.PersonAddAge(p2).PersonAddAge(p2).PersonAddAge(p2);
	cout << p1.mAge << endl;
}
```

### 空指针访问成员函数

C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针

如果用到this指针，需要加以判断保证代码的健壮性

```cpp
class PersonJx007
{
public:
	void showPersonClass()
	{
		cout << "This is Person class!" << endl;
	}
	void showPersonAge()
	{
		//添加一个判断
		if (this == NULL)
		{
			return;
		}
		cout << "age = " << m_Age << endl;
	}
	int m_Age;
};
void Class_Jx008()
{
	PersonJx007* p = NULL;		//创建一个类的空指针
	p->showPersonClass();		//可以正常调用
	//p->showPersonAge();		//引发了异常: 读取访问权限冲突。
								//**this** 是 nullptr。
	//报错的原因是空指针无法访问属性，因为 this指针为空。
	//在类中添加判断
	p->showPersonAge();			//这样就不会报错了

	//试试空对象
	PersonJx007 p1;
	//空对象均可以正常调用
	p1.showPersonClass();
	p1.showPersonAge();
}
// erro: this 是 nullptr。
// 但是成功执行了`showPersonClass`函数
// 如果只调用`showPersonClass`函数发现是没有报错的
// 但是只调用`showPersonAge`函数还是会报错
// 区别在于`showPersonAge`函数调用了`m_Age`
// 在类中 ：` cout << "age = " << m_Age << endl;`
//		相当于：` cout << "age = " << this->m_Age << endl;`
// 空指针是没有对象实例化的，因此是没法访问到对象里面的属性。
// 简单来说，你连对象都没有，还要问你对象的年龄？
```

因此为了防止报错，需要将代码做一个判断

```cpp
void showPersonAge()
{
    if (this == NULL)
    {
        return;
    }
    cout << "age = " << this->m_Age << endl;
}
```

### const 修饰成员函数

**常函数：**

- 成员函数后加const后我们称为这个函数为 **常函数**
- 常函数内不可以修改成员属性
- 成员属性声明时加关键字`mutable`后，在常函数中依然可以修改

**常对象：**

- 声明对象前加const称该对象对常对象
- 常对象只能调用常函数

**示例：**

```cpp
class PersonJx008
{
public:
	//在成员函数后面加 const，修饰的是this指针，
	//	this指针的本质 是指针常量 指针指向不可以修改	
	void showPerson() const
	{
		//此时指针指向的值也不可以修改
		//this->m_A = 100;

		//mutable 变量在常函数中也可以修改
		m_B = 20;
		cout << "常函数的调用" << endl;
	}

	void func(){}

	int m_A;
	//如果想要在常函数中也可以修改，在变量前加 mutable
	mutable int m_B;
};
void Class_Jx009()
{
	const PersonJx008 p;	//在对象前加const，变为常对象
	//p.m_A = 100;			//常对象不能修改普通的成员变量
	p.m_B = 18;				//但是常对象可以修改 mutable 成员变量
	p.showPerson();			//常对象只能调用常函数
	cout << p.m_B << endl;
	//p.func()				//error:对象含有不兼容的类型限定符	
}
```

## 友元

在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术

友元的目的就是让一个函数或一个类 访问另一个类中私有成员

关键字：`friend`

友元的三种实现

- 全局函数做友元
- 类做友元
- 成员函数做友元

```cpp
/*友元*/
//全局函数做友元
class BuildJx001;
class ClassGoodGay001;
class BuildJx001
{
	//GoodGay全局函数用friend声明	//甚至不用特意写在public作用域下
	friend void func_GoodGay(BuildJx001* build);
	//GoodGay类也是同样的方式声明
	friend class ClassGoodGay;
	//类的成员函数单独声明	//TODO：声明前后顺序并没有讲清，单纯这样写还是会报错
	//friend void ClassGoodGay001::visit();
public:
	BuildJx001();

public:
	string m_LivingRoom;		//客厅
private:
	string m_BedRoom;			//卧室
};
BuildJx001::BuildJx001()
{
	m_LivingRoom = "客厅";
	m_BedRoom = "卧室";
}
//	全局函数
void func_GoodGay(BuildJx001* build)
{
	cout << "全局函数正在访问： " << build->m_LivingRoom << endl;
	//cout << "全局函数正在访问： " << build->m_BedRoom << endl;	//私有属性不可访问

	//在类中用friend声明全局函数后即可访问类中私有变量
	cout << "全局函数正在访问： " << build->m_BedRoom << endl;
}
void Class_Jx010()
{
	BuildJx001 build;
	func_GoodGay(&build);
}
//类做友元
class ClassGoodGay
{
public:
	ClassGoodGay();
public:

	void visit();	//访问 BuildJx001 类中的属性

	BuildJx001* build;
};
ClassGoodGay::ClassGoodGay()
{
	//创建一个对象
	build = new BuildJx001;		//new对象返回指针
}
void ClassGoodGay::visit()
{
	cout << "好基友类正在访问： " << build->m_LivingRoom << endl;
	cout << "好基友类正在访问： " << build->m_BedRoom << endl;
}
//	test
void Class_Jx011()
{
	ClassGoodGay gp;		//创建一个类
	gp.visit();
}
//成员函数做友元
class ClassGoodGay001
{
public:
	ClassGoodGay001();
	void visit();		//	让visit函数可以访问私有成员
	void visit2();		//	让visit2函数不可以访问私有成员

private:
	BuildJx001* build;

};
ClassGoodGay001::ClassGoodGay001()
{  
	build = new BuildJx001;
}
void ClassGoodGay001::visit()
{
	cout << "好基友类正在访问： " << build->m_LivingRoom << endl;
	//cout << "好基友类正在访问： " << build->m_BedRoom << endl;
}
void ClassGoodGay001::visit2()
{
	cout << "好基友类正在访问： " << build->m_LivingRoom << endl;
	//cout << "好基友类正在访问： " << build->m_BedRoom << endl;	//visit2不可访问
}
//	test
//void Class_Jx012()
//{
//	ClassGoodGay001 gp;
//	gp.visit();
//}
```

## 运算符重载*

对于内置数据类型，编译器知道如何进行运算

为了规范，编译器为运算符重载都统一起名

### 加号运算符重载

`operator+`

```cpp
//加号运算符重载
class PersonJx009
{
public:
	PersonJx009& operator+(PersonJx009& p)
	{
		PersonJx009 temp;
		temp.mA = p.mA + this->mA;
		temp.mB = p.mB + this->mB;
		return temp;
	}
public:
	int mA;
	int mB;
private:
};
//	成员函数重载
void Class_Operator001()
{
	PersonJx009 p1;
	p1.mA = 10;
	p1.mB = 100;
	PersonJx009 p2;
	p2.mA = 20;
	p2.mB = 200;
	PersonJx009 p3;
	p3 = p1 + p2;		//重载运算符+
	cout << p3.mA << " " << p3.mB << endl;
}
//	全局函数重载
class PersonJx010
{
public:
	int mA;
	int mB;
private:
};
PersonJx010& operator+(PersonJx010& p1, PersonJx010& p2)
{
	PersonJx010 temp;
	temp.mA = p1.mA + p2.mA;
	temp.mB = p1.mB + p2.mB;
	return temp;
}
void Class_Operator002()
{
	PersonJx010 p1;
	p1.mA = 10;
	p1.mB = 100;
	PersonJx010 p2;
	p2.mA = 20;
	p2.mB = 200;
	PersonJx010 p3;
	p3 = p1 + p2;		//重载运算符+
	cout << p3.mA << " " << p3.mB << endl;
}
```

- 总结

  对于内置的数据类型的表达式的运算符是不可以改变的

  不要滥用运算符重载

### 左移运算符重载*

```cpp
//左移运算符重载
class PersonJx011
{
	//利用全局函数做友元访问私有属性
	friend ostream& operator<<(ostream& cout, PersonJx011& p);
public:
	PersonJx011(int a, int b);

	//通常不会利用成员函数重载 左移运算符， 因为无法实现 cout 在左侧
	//void operator<< (PersonJx011& p);
private:
	int mA;
	int mB;
};
PersonJx011::PersonJx011(int a, int b)
{
	this->mA = a;
	this->mB = b;
}
//	只能利用全局函数重载左移运算符
ostream& operator<<(ostream& cout, PersonJx011& p)
{
	cout << p.mA << " " << p.mB << endl;
	//还需注意链式编程思想
	return cout;
}
void Class_Operator003()
{
	PersonJx011 p(10, 20);
	cout << p << endl;
}
```

> 总结：重载左移运算符配合友元可以实现输出自定义数据类型

### 递增运算符重载

```cpp
class MyInteger
{
public:
	MyInteger();
	~MyInteger();
	int getNum();

	//重载前置++运算符	//返回值的话重复调用就会出现问题
	MyInteger& operator++()
	{
		mNum++;
		return *this;
	}
	//重载后置++运算符	//int代表占位参数，可以用于区分前置和后置递增，只认int！
	MyInteger operator++(int)
	{
		//先 记录当时结果
		MyInteger temp = *this;
		//后 递增
		mNum++;
		//返回的是局部对象，因此不能返回引用
		return temp;
	}
private:
	int mNum;
};

MyInteger::MyInteger()
{
	this->mNum = 0;
}

MyInteger::~MyInteger()
{
}
int MyInteger::getNum()
{
	return this->mNum;
}
//	重载左移运算符打印输出
ostream& operator<<(ostream& cout, MyInteger myint)
{
	cout << myint.getNum();
	return cout;
}
void Class_Operator004()
{
	MyInteger myint;
	cout << ++myint << endl;
	MyInteger myint2;
	cout << myint2++ << endl;
}
```

C++无法实现连续后置调用

### 赋值运算符重载

C++编译器至少给一个类添加4个函数

1. 默认构造函数（无参，函数体为空）

2. 默认析构函数（无参，函数体为空）
3. 默认拷贝构造函数，对属性进行值拷贝
4. 赋值运算符 operator=，对属性进行值拷贝

如果类中有属性指向堆区，做赋值操作时，也会出现深浅拷贝问题。

```cpp
//赋值运算符重载
class PersonJx012
{
public:
	PersonJx012(int age);
	~PersonJx012();

	//浅拷贝会重复释放堆区内存
	PersonJx012& operator=(PersonJx012& p);

	int* getAge();
private:
	int* mAge;
};
PersonJx012::PersonJx012(int age)
{
	mAge = new int(age);
}
PersonJx012::~PersonJx012()
{
	if (mAge!=NULL)
	{
		delete mAge;
		mAge = NULL;
	}
}
//	还要考虑链式编程
//void PersonJx012::operator=(PersonJx012& p)
PersonJx012& PersonJx012::operator=(PersonJx012& p)
{
	/*编译器提供的浅拷贝*/
	//mAge = p.mAge;

	/*为了避免堆区重复释放，应该对赋值运算操作符进行重载*/
	//先判断是否有属性在堆区，如果有先释放干净
	if (mAge!=NULL)
	{
		delete mAge;
		mAge = NULL;
	}
	//然后进行深拷贝
	this->mAge = new int(*p.getAge());
	return *this;
}
int* PersonJx012::getAge() { return mAge; }
void Class_Operator005()
{
	PersonJx012 p1(18);
	PersonJx012 p2(20);

	p2 = p1;	//赋值操作

	cout << *p1.getAge() << endl;
	cout << *p2.getAge() << endl;
}
```

### 关系运算符重载

```cpp
//关系运算符重载
class PersonJx013
{
public:
	PersonJx013(string name, int age);

	bool operator==(PersonJx013& p);
	bool operator!=(PersonJx013& p);

	string getName() { return mName; }
	int getAge() { return mAge; }
private:
	string mName;
	int mAge;
};
PersonJx013::PersonJx013(string name, int age)
{
	mName = name;
	mAge = age;
}
bool PersonJx013::operator==(PersonJx013& p)
{
	if (mName == p.getName() && mAge == p.getAge())
	{
		return true;
	}
	return false;
}
bool PersonJx013::operator!=(PersonJx013& p)
{
	if (mName == p.getName() && mAge == p.getAge())
	{
		return false;
	}
	return true;
}

void Class_Operator006()
{
	PersonJx013 p1("zhangsan", 18);
	PersonJx013 p2("zhangsan", 18);
	if (p1==p2)
	{
		cout << "p1和p2是相等的" << endl;
	}
	else { cout << "p1和p2是不相等的" << endl; }
}
```

### 函数调用运算符重载

- 函数调用运算符()也可以重载
- 由于重载后使用的方式非常像函数的调用，因此称为仿函数
- 仿函数没有固定写法，非常灵活

```cpp
//函数调用运算符重载
class MyPrint
{
public:
	//由于使用起来很像函数的调用，因此被称为仿函数
	void operator()(string test);

private:

};
void MyPrint::operator()(string test)
{
	cout << test << endl;
}
void Class_Operator007()
{
	MyPrint p;
	p("hello world");

	//匿名对象写法
	MyPrint()("匿名对象方式调用");
}
```

## 继承

**继承是面向对象三大特性之一**

我们发现，定义一些存在特殊关系的类时，下级别的成员除了拥有上一级的共性，还有自己的特性

这时就可以考虑利用继承的技术，减少重复代码

### 继承的基本语法

语法：`class 子类 : 继承方式 父类`

子类 也称为 派生类

父类 也称为 基类

```cpp
//继承的基本语法
/*	继承实现页面 */
class BasePage
{
public:
	void header()
	{
		cout << "首页、公开课、登陆、注册...(公共头部)" << endl;
	}
	void footer()
	{
		cout << "帮助中心、交流合作...(公共底部)" << endl;
	}
	void left()
	{
		cout << "Java、Python、C++...（公共列表）" << endl;
	}
};
class WebJava : public BasePage
{
public:
	void content()
	{
		cout << "Java学科视频" << endl;
	}
};
class WebPython : public BasePage
{
public:
	void content()
	{
		cout << "Python学科视频" << endl;
	}
};
class WebCpp : public BasePage
{
public:
	void content()
	{
		cout << "Cpp学科视频" << endl;
	}
};
void Class_successor()
{
	cout << "这是Java页面" << endl;
	WebJava webjava;
	webjava.header();
	webjava.footer();
	webjava.left();
	webjava.content();
	cout << "\n这是Python页面" << endl;
	WebPython webpy;
	webpy.header();
	webpy.footer();
	webpy.left();
	webpy.content();
	cout << "\n这是Cpp页面" << endl;
	WebCpp webcpp;
	webcpp.header();
	webcpp.footer();
	webcpp.left();
	webcpp.content();
}
```

**总结**

派生类中的成员，包含两大部分：

- 一类是从基类继承过来的
- 一类是自己增加的成员

从基类继承过来的表现其共性，而新增的成员体现了其个性。

### 继承方式

继承方式一共有三种：

- 公共继承
- 保护继承
- 私有继承

![image-20210913215619226](https://i.loli.net/2021/09/13/BuqgY4PF3KOT1zH.png)

总结：

可以理解为继承方式的选择是权限提升的过程。

### 继承中的对象模型

**问题：** 从父类继承过来的成员，哪些属于子类对象？

```cpp
//继承中的对象模型
class BaseTest
{
public:
	int m_public_A;
protected:
	int m_protected_B;
private:
	int m_private_C;	//私有属性只是被隐藏了，但还是会继承下去
};
class SonTest : public BaseTest
{
public:
	int m_D;
};
void Class_successor001()
{
	cout << sizeof(SonTest) << endl;		//16
}
```

**总结：** 其实都属于子类对象，但是被编译器隐藏了无法访问

### 继承中构造和析构顺序

子类继承父类后，当创建子类对象，也会调用父类的构造函数

问题：父类和子类的构造和析构顺序谁先谁后？

`父构造 子构造 子析构 父析构`

```cpp
class BaseTest001
{
public:
	BaseTest001();
	~BaseTest001();
public:
	int m_public_A;
protected:
	int m_protected_B;
private:
	int m_private_C;	//私有属性只是被隐藏了，但还是会继承下去
};
BaseTest001::BaseTest001()
{
	cout << "父类的构造函数调用" << endl;
}
BaseTest001::~BaseTest001()
{
	cout << "父类的析构函数调用" << endl;
}
class SonTest001 : public BaseTest001
{
public:
	SonTest001();
	~SonTest001();
public:
	int m_D;
};
SonTest001::SonTest001()
{
	cout << "子类的构造函数调用" << endl;
}
SonTest001::~SonTest001()
{
	cout << "子类的析构函数调用" << endl;
}
void Class_successor002()
{
	SonTest001 son;
	//父构造 子构造 子析构 父析构
}
```

### 继承同名成员处理方式

问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中的同名成员呢？

- 访问子类同名成员 直接访问即可
- 访问父类同名成员 需要加作用域

```cpp
//继承同名成员处理方式
class BaseTest002
{
public:
	BaseTest002();
public:
	int getA();
public:
	void func();
	void func(int a);
private:
	int mA;
};
BaseTest002::BaseTest002() { mA = 30; }
int BaseTest002::getA() { return mA; }
void BaseTest002::func()
{
	cout << "父类同名成员函数的调用" << endl;
}
void BaseTest002::func(int a)
{
	cout << "父类有参的同名成员函数调用" << endl;
}
class SonTest002 : public BaseTest002
{
public:
	SonTest002();
public:
	int getA();
public:
	void func();
private:
	int mA;
};
SonTest002::SonTest002() { mA = 18; }
int SonTest002::getA() { return mA; }
void SonTest002::func()
{
	cout << "子类同名成员函数的调用" << endl;
}
void Class_successor003()
{
	SonTest002 son;
	cout << son.getA() << endl;						//子类同名成员直接访问即可
	cout << son.BaseTest002::getA() << endl;		//父类同名成员加后缀即可访问

	//如果子类中出现和父类同名的成员函数，子类的同名成员会隐藏掉父类的所有同名成员函数
	son.func();					//cout:子类同名成员函数的调用
	//son.func(1);				//error C2660: “SonTest002::func”: 函数不接受 1 个参数
	son.BaseTest002::func(1);	//cout:父类有参的同名成员函数调用
}
```

**总结：**

1. 子类对象可以直接访问到子类中同名成员
2. 子类对象加作用域可以访问到父类同名成员
3. 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名成员函数

### 继承同名静态成员处理方式

问题：继承中同名的静态成员在子类对象上如何进行访问？

静态成员和非静态成员出现同名，处理方式一致

- 访问子类同名成员 直接访问即可
- 访问父类同名成员 需要加作用域

### 多继承语法

C++允许一个类继承多个类

语法：`class 子类 : 继承方式 父类1, 继承方式 父类2...`

多继承可能会引发父类中有同名成员出现，需要加作用域区分

**C++实际开发中不建议使用多继承**

### 菱形继承

- 菱形继承概念：

两个派生类继承同一个基类

又有某个类同时继承这两个派生类

这种继承被称为菱形继承，或者钻石继承

- 典型的菱形继承案例：

![image-20210915160420261](https://i.loli.net/2021/09/15/XAlhv3BoY8FH7R4.png)

-  菱形继承

1. 羊继承了动物的数据，驼同样继承了动物的数据，当羊驼使用数据时，就会产生二义性。
2. 羊驼继承自动物的数据继承了两份，其实只需要一份即可。

- 虚基类指针(vbptr)

  v : virtual

  b : base

  ptr : pointer

![image-20210923113803224](https://i.loli.net/2021/09/23/lHzdUIERhj8oFtD.png)

```cpp
//菱形继承 or 砖石继承
class Animal
{
public:
	int mAge;
};
class Sheep :public Animal
{
};
class Tuo :public Animal
{
};
class SheepTuo :public Sheep, public Tuo
{
};
void Class_successor004()
{
	SheepTuo st;
	st.Sheep::mAge = 18;
	st.Tuo::mAge = 28;
	//当菱形继承，两个父类拥有相同数据，需要加以作用域区分
	cout << "st.Sheep::mAge = " << st.Sheep::mAge << endl;
	cout << "st.Tuo::mAge = " << st.Tuo::mAge << endl;
	//这份数据我们知道，只需要有一份即可，菱形继承导致数据有两份，资源浪费
}
//	虚继承 解决菱形继承导致的资源浪费
class Animal001
{
public:
	int mAge;
};
//	Animal类被称为虚基类
class Sheep001 :virtual public Animal001
{
};
class Tuo001 :virtual public Animal001
{
};
class SheepTuo001 :public Sheep001, public Tuo001
{
};
void Class_successor005()
{
	SheepTuo001 st;
	st.Sheep001::mAge = 18;
	st.Tuo001::mAge = 28;
	//当菱形继承，两个父类拥有相同数据，需要加以作用域区分
	cout << "st.Sheep::mAge = " << st.Sheep001::mAge << endl;
	cout << "st.Tuo::mAge = " << st.Tuo001::mAge << endl;
	//这份数据我们知道，只需要有一份即可，菱形继承导致数据有两份，资源浪费
	
	//虚继承后的同名数据就为同一份数据
	cout << "st.mAge = " << st.mAge << endl;
	//此时两个父类的内容都是(vbptr -- 虚基类指针)
}
```

# 多态

## 多态基本概念

**多态是C++面向对象三大特性之一**

多态分为两种

- 静态多态：函数重载 和 运算符重载属于静态多态，复用函数名
- 动态多态：派生类和虚函数实现运行时多态

静态多态和动态多态区别：

- 静态多态的函数地址早绑定 - 编辑阶段确定函数地址
- 动态多态的函数地址晚绑定 - 运行阶段确定函数地址

```cpp
class Animal002
{
public:
	//speak函数就是虚函数
	//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了
	virtual void speak();
};
void Animal002::speak()
{
	cout << "动物在说话" << endl;
}
class Cat002 : public Animal002
{
public:
	void speak();

};
void Cat002::speak()
{
	//重写 函数返回值类型 函数名 参数列表 完全相同
	cout << "小猫在说话" << endl;
}
//地址早绑定 在编译阶段确定函数地址
//如果想执行让猫说话，那么这个函数地址就不能提前绑定，需要在运行阶段进行绑定，地址晚绑定
void doSpeak(Animal002& animal)
{
	animal.speak();
}
//动态多态满足条件
//1. 有继承关系
//2. 子类要重写父类中的虚函数
//动态多态使用
//父类指针或引用指向子类对象
void Class_Polymorphism()
{
	Cat002 cat;
	//C++默认允许父与子类间类型转换
	doSpeak(cat);
}
```

## 多态案例一：计算器类

案例描述：

分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类

多态的有点：

- 代码组织结构清晰
- 可读性强
- 利于前期和后期的扩展以及维护

```cpp
/*多态案例一：计算器类*/
//	普通写法
class Calculator
{
public:
	int getResult(string oper);
	
	int num1;
	int num2;
};
int Calculator::getResult(string oper)
{
	if (oper == "+")
	{
		return num1 + num2;
	}
	else if (oper == "-")
	{
		return num1 - num2;
	}
	else if (oper == "*")
	{
		return num1 * num2;
	}
	//如果想扩展新的功能，需要修改源码
	//在真实开发中 提倡 开闭原则
	//开闭原则：对扩展进行开放，对修改进行关闭
}
void Class_Polymorphism002()
{
	Calculator c;
	c.num1 = 20;
	c.num2 = 10;
	cout << c.num1 << " + " << c.num2 << " = " << c.getResult("+") << endl;
	cout << c.num1 << " - " << c.num2 << " = " << c.getResult("-") << endl;
	cout << c.num1 << " * " << c.num2 << " = " << c.getResult("*") << endl;
}
//	多态写法
/*多态好处
* 1.组织结构非常清晰
* 2.可读性强
* 3.对于前期和后期扩展以及维护性高
*/
//		实现计算器抽象类
class AbstractCalculator
{
public:
	virtual int getResult() { return 0; }
	int num1;
	int num2;
};
//		加法计算器类
class AddCalculator :public AbstractCalculator
{
public:
	int getResult()
	{
		return num1 + num2;
	}
};
//		减法计算器类
class SubCalculator :public AbstractCalculator
{
public:
	int getResult()
	{
		return num1 - num2;
	}
};
class MulCalculator :public AbstractCalculator
{
public:
	int getResult() { return num1 * num2; }
};
void Class_Polymorphism003()
{
	//多态使用条件
	//父类指针或引用指向子类对象
	AbstractCalculator* abc = new AddCalculator;
	abc->num1 = 20;
	abc->num2 = 10;
	cout << abc->num1 << " + " << abc->num2 << " = " << abc->getResult() << endl;
	//用完后手动销毁
	delete abc;

	//减法运算
	abc = new SubCalculator;
	abc->num1 = 20;
	abc->num2 = 10;
	cout << abc->num1 << " - " << abc->num2 << " = " << abc->getResult() << endl;
	//用完后手动销毁
	delete abc;
}
```

## 纯虚函数和抽象类

在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的代码

因此可以将虚函数改为 **纯虚函数**

纯虚函数语法：`virtual 返回值类型 函数名 (参数列表) = 0;`

当类中有了纯虚函数，这个类也称为`抽象类`

**抽象类特点：**

- 无法实例化对象
- 子类必须重写抽象类中的纯虚函数，否则也属于抽象类

```cpp
//纯虚函数和抽象类
class Abstract
{
	//纯虚函数
	//只要有一个纯虚函数，这个类称为抽象类
	//抽象类特点：
	//1.无法实例化对象
	//2.抽象类的子类，必须要重写父类中的纯虚函数，否则也属于抽象类
	virtual void func() = 0;
};
```

## 多态案例二：制作饮品

案例描述：

制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料



利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶

```cpp
//多态案例二：制作饮品
class AbstractDrinking
{
public:
	//煮水
	virtual void Boil() { cout << "煮矿泉水" << endl; }
	//冲泡
	virtual void Brew() = 0;
	//倒入杯中
	virtual void PourInCup() = 0;
	//加入辅料
	virtual void PutSomething() = 0;
	//制作饮品
	void makeDrink()
	{
		Boil();
		Brew();
		PourInCup();
		PutSomething();
	}
};
class Coffee :public AbstractDrinking
{	
public:
	//冲泡
	virtual void Brew()
	{
		cout << "冲泡咖啡" << endl;
	}
	//倒入杯中
	virtual void PourInCup()
	{
		cout << "倒入杯中" << endl;
	}
	//加入辅料
	virtual void PutSomething()
	{
		cout << "加入糖和牛奶" << endl;
	}
};
class Tea :public AbstractDrinking
{
public:
	//冲泡
	virtual void Brew()
	{
		cout << "冲泡茶叶" << endl;
	}
	//倒入杯中
	virtual void PourInCup()
	{
		cout << "倒入杯中" << endl;
	}
	//加入辅料
	virtual void PutSomething()
	{
		cout << "加入枸杞" << endl;
	}
};
void doWork(AbstractDrinking* abs)
{
	abs->makeDrink();
	delete abs;
}
void Class_Polymorphism004()
{
	doWork(new Coffee);
	cout << "----" << endl;
	doWork(new Tea);
}
```

## 虚析构和纯虚析构

多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码

解决方式：将父类中的析构函数改为 **虚析构** 或者 **纯虚析构**

虚析构和纯虚析构共性：

- 可以解决父类指针释放子类对象
- 都需要有具体的函数实现

虚析构和纯虚析构区别：

- 如果是纯虚析构，该类属于抽象类，无法实例化对象

虚析构语法：

`virtual ~类名(){}`

纯虚析构语法：

`virtual ~类名() = 0;`

`类名::~类名(){}`

# 文件操作

C++对文件操作需要包含头文件`<fstream>`

文件类型分为两种：

1. 文本文件 - 文件以文本的ASCII码形式存储在计算机中
2. 二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们

操作文件的三大类：

1. `ofstream` ： 写操作
2. `ifstream` ： 读操作
3. `fstream` ： 读写操作

## 文本文件

### 写文件

- 写文件步骤如下：

1. 包含头文件

   `#include<fstream>`

2. 创建流对象

   `ofstream ofs;`

3. 打开文件

   `ofs.open("文件路径",打开方式);`

4. 写数据

   `ofs << "写入的数据";`

5. 关闭文件

   `ofs.close();`

- 打开方式：

| **打开方式** | **解释**                   |
| :----------- | :------------------------- |
| ios::in      | 为读文件而打开文件         |
| ios::out     | 为写文件而打开文件         |
| ios::ate     | 初始位置：文件尾           |
| ios::app     | 追加方式写文件             |
| ios::trunc   | 如果文件存在先删除，再创建 |
| ios::binary  | 二进制方式                 |

注意：文件打开方式可以配合使用，利用`|`操作符

例如：用二进制方式写文件 `ios::binary | ios::out`

### 读文件

- 写文件步骤如下：

1. 包含头文件

   `#include<fstream>`

2. 创建流对象

   `ifstream ifs;`

3. 打开文件

   `ifs.open("文件路径",打开方式);`

4. 读数据

   四种方式读取

5. 关闭文件

   `ifs.close();`

```cpp
// 判断文件是否打开成功
if (!ifs.is_open())
{
    cout << "文件打开失败" << endl;
    return;
}
```

- 四种读数据的方式

第一种

```cpp
char buf[1024] = {0};
while ( ifs >> buf )		// 全部读完会退出循环,buf 是一行数据
{
    cout << buf << endl;
}
```

第二种

```cpp
char buf[1024] = {0};
while ( ifs.getline(buf,1024))
{
    cout << buf << endl;
}
```

第三种

```cpp
string buf;
while ( getline(ifs,buf) )
{
    cout << buf << endl;
}
```

第四种（不推荐）

```cpp
char c;
while ( (c = ifs.get()) != EOF )		// EOF = end of file
{
    cout << c;
}
```

## TODO:二进制文件