# 第1章 从基础开始--预备知识和复习

1. 由于 `Intel8086` 的功能限制，在直到最近还被广泛使用的`MSDOS`中，是通过将16位的值分成两组来表示20位的地址的。

   因为 `Intel8086` 是分段寻址的，具体来说是指一个物理地址由段地址（segment selector）与偏移量（offset）两部分组成，长度各式16位。其中段地址左移4位（即乘以16）与偏移量相加即为物理地址。

2. 在C语言中，对指针进行加1运算，地址的值会增加当前指针所指向数据类型的长度。

3.  `空指针` 确保它和任何非空指针进行比较都不会相等，因此经常作为函数发生异常时的返回值使用。

    `链表` 数据结构的末尾通常也会放置一个 `空指针` 来提示后面已经没有元素了。

4. 在C语言标准中， `空字符` 的定义为“所有的位为0的字节称为空字符（null character）”。也就是说， `空字符` 是值为0的字符。

    `空字符` 在表现上通常使用 `'\0'`。因为 `'\0'` 是常量，所以实际上它等同于0。也许有些不可思议，`'\0'` 或者 `'a'` 之类的，它们的数据类型数据其实并不是 `char`，而是 `int*`。

   但是，如果是 `C++` ，就不是这个结论了。

5.  `实参` 是调用函数时的参数。`func(5);` 中的 `5` 是 `实参` ；

    `形参` 是接受实参的一方。`void func(int hoge) {...}` 中的 `hoge` 是 `形参` 。

6.  `语法糖`

   `p[i]` 是 `*(p+i)` 的简单写法，实际上，至少对于编译器来说，`[]` 这样的运算符完全可以不存在。
   
   C语言引入了 `[]` 运算符，来实现 `*(p+i)` ，这样仅仅是为了让人类更容易理解而引入的功能，的确可以让外面感受到编程语言的甜蜜味道（容易着手），有时我们称这些功能为语法糖（syntax sugar 或者 syntactic sugar）。
   
7. 如今，编译器在不断地被优化，对于循环内部重复出现的表达式的集中处理，是编译器优化的基本内容。对于现在一般的C编译器，无论你使用数组还是指针，效率上都不会出现明显的差距。基本上都是输出完全相同的机器码。

8. 在网络通讯中，数据交换程序中经常会使用一个 `char`数组保存各种数据类型的数据。我们通常将这种行为称为 `序列化` 。

9. 如果之一要将数组的副本作为参数进行传递，可以使用代替方法 -- 将数组的所有元素整理成结构体的成员。

10.  `语法糖`

    在下面声明的形参，都具有相同的意义。

    ```c
    int func(int a);		/*写法1*/
    int func(int a[]);		/*写法2*/
    int func(int a[10]);	/*写法3*/
    ```

    写法2和写法3是写法1的语法糖。
    
11. 除了某些解释型的编程语言之外，目前几乎没有编译器可以为我们做数组的越界检查。

 # 第2章 做个实验见分晓 -- C是怎么使用内存的

1. 在如今的运行环境中，使用`printf()`输出指针的时候，打印输出的并不是物理内存本身。

   因为当今的操作系统都会给应用程序的每一个进程分配独立的“虚拟地址空间”。这和C语言本身并没有关系，而是操作系统和CPU协同工作的结构。

2. 虚拟内存的概念图

   ![image-20211014094717479](https://i.loli.net/2021/10/14/TaBfhZP9uKOpctA.png)

3. 在标准中，`“作用域”（scope）`和`“连接”（linkage）`是分别定义的，用语句块包围的是作用域，`static`和`extern`分别控制静态连结和外部连接。对于全局变量，作用域指文件作用域，连接指外部连接。对于程序员来说，这些方式都是控制命名空间的，它们没有什么不同。

4. 存储期（storage duration）的差别：

   **静态存储期（static storage duration）**

   全局变量、文件内的static变量、指定static的局部变量都持有静态存储期。这些变量被称为静态变量。

   持有静态存储期的变量的寿命从程序运行时开始，到程序关闭时结束。换句话说，静态变量一直存在于内存的同一地址上。

   **自动存储期（auto storage duration）**

   没有指定static的局部变量，持有自动存储期。这样的变量被称为自动变量。

   持有自动存储期的变量，在程序运行进入它所在的语句块时被分配以内存区域，该语句块执行结束后这片内存区域被释放。

   *如果说的细致一些，在几乎所有的处理环境中，并不是“程序执行进入语句块时”给自动变量分配内存空间，而是在“程序执行进入函数时”统一地进行内存区域分配的。这个特征通常使用“栈”的机制来实现。

5. C中有三种内存领域的寿命

   - 静态变量的寿命从程序开始，到程序关闭时结束。
   - 自动变量的寿命到声明该变量的语句块执行结束为止。
   - 通过`malloc（）`分配的领域的寿命到调用`free()`为止。

6. **存储类型修饰符**

   `typedef extern static auto register`

   `extern` 使得在其他地方定义的外部变量可以在本地可见；

   `auto` 是默认的，所以没有显示指定的必要；

   `register` 可以给出编译器优化提示（如今的编译已经很先进了，所以一般也不会使用这个关键字）；

   `typedef` 只是因为可以给编码带来便利才被归纳到存储类型修饰符中来的。

7. 通过将`自动变量`分配在`栈`中，内存区域可以被重复利用，这样可以节约内存。

8. 最简约的C语言函数调用的实现（基本思想一致）

   （1）在调用方，参数从后往前按顺序被堆积在栈中。

   （2）和函数调用关联的返回信息（返回地址等）也被堆积在栈中。所谓的“返回地址”，是指函数处理完毕后应该返回的地址。正因为返回地址被堆积在栈中，所以无论函数从什么地方被调用，它都能返回到调用点的下一个处理。

   （3）跳转到作为被调用对象的函数地址。

   （4）栈为当前函数所使用的自动变量增长所需大小内存区域。（1）到（4）所增长的栈的区域成为当前函数的可引用区域。

   （5）在函数的执行过程中，为了进行复杂的表达式运算，有时候会将计算过程中的值放在栈中。

   （6）一旦函数调用结束，局部变量占用的内存区域就被释放，并且使用返回信息返回到原来的地址。

   （7）从栈中除去调用方的参数。

9. 一旦函数执行结束，自动变量的内存区域就会被释放。

10. `Pascal`和`Java`中不能写带有`可变长参数`的函数，因为它们是从前往后将参数堆积在栈中的。

    注：Java在JDK1.5之后的版本也开始支持可变长参数了。

