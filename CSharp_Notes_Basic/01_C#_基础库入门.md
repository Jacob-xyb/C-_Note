# C# 简介

## Hello World

# .NET

## .NET 两种交互模式

- C/S：客户机（Client）/ 服务器模式（Server）
- B/S：浏览器（Browser）/ 服务器模式（Server） 

# 数据类型 - 值类型(Value types)

## 简单类型

### 整数、实数

### 字符

初始化：`char c = '\0';`

### 字符串

#### 初始化

- 字符数组的一部分初始化

  语法：`public string(char[] value, int offset, int count)`

  ```c#
  char[] charArray = {'时', '间', '就', '是', '金', '钱'};
  string a = new string(charArray, 4, 2);
  ```

---

- 空字符串与空引用的区别：

  `string str = null;` 是空对象，没有指向任何引用地址，调用string方法会抛出异常。

#### @字符串

`@` 字符不会发生转义

```c#
string str = @"hello world\n";
Console.WriteLine(str);  // hello world\n
```

#### 格式化输出

按 index 输出

```c#
int a = 23, b = 45;
Console.WriteLine("{0} + {1} = {2}", a, b, a + b);  // 23 + 45 = 68
```

**多填参数不报错，少填参数报错。**

#### 转义字符串

`\b` 表示退格，在字符串两端不起作用。

#### 字符串常用方法

##### ToLower() 、 ToUpper()

全小写，全大写。

##### Trim() 、TrimStart() 、TrimEnd()

去除头尾空格字符

##### Split()

分割字符串

```c#
string str = "name1,name2,name3";
string[] strArr = str.Split(',');
foreach (string item in strArr)
{
    Console.WriteLine(item);
}
```

## 复合类型

### 结构体

```c#
struct StudentInfo
{
    public string Name;
    public int age;
}
```

### 枚举

枚举是一组命名整型常量。枚举类型是使用 **enum** 关键字声明的。

C# 枚举是值类型。换句话说，枚举包含自己的值，且不能继承或传递继承。

#### 语法

`enum <enum_name> {value1, value2, ... valuen};`

```c#
enum RoleType
{
    Mage, Archer, Assassin, Tank, Support, Warior
}

static void Main(string[] args)
{
    RoleType roleType = RoleType.Assassin;
    Console.WriteLine((int)roleType);   // 2
}
```

#### int 转成枚举类型

```c#
MyEnum yy = (MyEnum)1;
Console.WriteLine(yy);  // Tuesday
```

#### string 转成枚举类型

string 变量可以是 枚举中对应的字符串， 也可以是对应的数字。

- 如果是数字，就算枚举中没有，也不会抛出异常；
- 如果是文本，如果枚举中没有，则会抛出异常。

```c#
MyEnum xx =  (MyEnum)Enum.Parse(typeof(MyEnum), "Monday");
Console.WriteLine(xx);  // Monday

MyEnum yy =  (MyEnum)Enum.Parse(typeof(MyEnum), "0");
Console.WriteLine(yy);  // Monday
```

# 数据类型 - 引用类型(Reference types)

## 对象（Object）类型

**对象（Object）类型** 是 C# 通用类型系统（Common Type System - CTS）中所有数据类型的终极基类。Object 是 System.Object 类的别名。所以对象（Object）类型可以被分配任何其他类型（值类型、引用类型、预定义类型或用户自定义类型）的值。但是，在分配值之前，需要先进行类型转换。

当一个值类型转换为对象类型时，则被称为 **装箱**；另一方面，当一个对象类型转换为值类型时，则被称为 **拆箱**。

## 数组

- 一维数组

```c#
// 声明int类型的数组
int[] ages1 = { 1, 2, 3, 4 };
int[] ages2 = new int[10];  // 默认值进行赋值
int[] ages3 = new int[] { 1, 2, 3, 4 };  // 比较规范的方式
```

- 二维数组

```c#
// 方法1
int[,] arr = new int[2, 4];

// 方法2, 可以声明一个不规则数组
int[,] arr = new int[2][];
arr[0] = new int[2];
arr[1] = new int[3];
```

### 数组的遍历

```c#
# for 循环
int[] ages = { 1, 2, 3, 4 };
for (int i = 0; i < ages.Length; i++)
{
    Console.WriteLine(ages[i]);
}

# foreach 循环
int[] ages = { 1, 2, 3, 4 };
foreach (int item in ages)
{
    Console.WriteLine(item);
}
```

### 数组的常用方法

#### Array.sort()

`Array.sort(arr)`

改变自身数组顺序。

```c#
int[] intArr = { 4, 7, 1, 2, 3 };
Array.Sort(intArr);
for (int i = 0; i < intArr.Length; i++)
{
    Console.WriteLine(intArr[i]);
}
```

## ArrayList

`ArrayList` 类位于 System.Collection 命名空间下，可以动态地添加和删除元素。

### 构造及初始化

**构造：**

- 使用默认构造器

```c#
ArrayList list = new ArrayList();
```

- 用一个 `ICollection` 对象来构造

```c#
ArrayList list = new ArrayList(arrName);
```

- 用指定的大小初始化内部的数组

```c#
ArrayList list = new ArrayList(n);
```

### 常用方法

#### Add()

#### Insert()

#### Clear()

#### Remove() 、RemoveAt() 、 RemoveRange()

#### IndexOf() 、LastInexOf() 、Contains()

## Hashtable

### 常用方法

#### Add()

`public virtual void Add(Object key, Object value)`

#### Clear()

#### Remove()

`public virtual void Remove(Object key)`

## 委托

`delegate ` 的返回值与参数列表要与委托的函数保持一致

```c#
static double Multiply(double x1, double x2)
{
    return x1 * x2;
}

static double Divide(double x1, double x2)
{
    return x1 / x2;
}

delegate double MyDelegate(double x1, double x2);

static void Main(string[] args)
{
    MyDelegate delegate1, delegate2;
    delegate1 = Multiply;
    delegate2 = Divide;
    Console.WriteLine(delegate1(3, 2));  // 6
    Console.WriteLine(delegate2(3, 2));  // 1.5
}
```

# 类型转换

## 隐式类型转换

在某种条件下，系统自动完成类型转换（即隐式类型转换）：

- 两种类型兼容：

  例如：double 兼容 int 类型

- 目标类型精度大于源类型（可以理解为所占字节数）：

  例如：double 是 8 字节 兼容 int 4 字节

## 显式类型转换

Convert 类型转换会导致精度丢失。

# 条件与循环

## 条件语句

```c#
Console.WriteLine("请输入您的年龄:");
int age = Convert.ToInt32(Console.ReadLine());

// if 语句
if (age <= 16)
{
    Console.WriteLine("too young");
}
else if (age <= 20)
{
    Console.WriteLine("so cool");
}
else
{
    Console.WriteLine("good job");
}
```

## switch 语句

C# 中 **switch** 语句的语法：

```c#
switch(expression){
    case constant-expression  :
       statement(s);
       break; 
    case constant-expression  :
       statement(s);
       break; 
  
    /* 您可以有任意数量的 case 语句 */
    default : /* 可选的 */
       statement(s);
       break; 
}
```

# 常量

## 整数常量

整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，没有前缀则表示十进制。

整数常量也可以有后缀，可以是 U 和 L 的组合，其中，U 和 L 分别表示 unsigned 和 long。后缀可以是大写或者小写，多个后缀以任意顺序进行组合。

```c#
212         /* 合法 */
215u        /* 合法 */
0xFeeL      /* 合法 */
078         /* 非法：8 不是一个八进制数字 */
032UU       /* 非法：不能重复后缀 */
    
85         /* 十进制 */
0213       /* 八进制 */
0x4b       /* 十六进制 */
30         /* int */
30u        /* 无符号 int */
30l        /* long */
30ul       /* 无符号 long */
```

## 浮点常量

一个浮点常量是由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。

这里有一些浮点常量的实例：

```c#
3.14159       /* 合法 */
314159E-5L    /* 合法 */
510E          /* 非法：不完全指数 */
210f          /* 非法：没有小数或指数 */
.e55          /* 非法：缺少整数或小数 */
```

**使用浮点形式表示时，必须包含小数点、指数或同时包含两者。**使用指数形式表示时，必须包含整数部分、小数部分或同时包含两者。有符号的指数是用 e 或 E 表示的。

# 函数

## 参数

### 函数中的参数数组

`params` 必须是最后一个参数

```c#
// params 必须是最后一个参数
static int Add(params int[] arr)
{
    int res = 0;
    foreach (int item in arr)
    {
        res += item;
    }
    return res;
}

static void Main(string[] args)
{
    Console.WriteLine(Add(1, 2, 3));
}
```

### ref 引用传输传递

- ref 关键字只对紧跟其后的参数有效，而不是应用于整个参数列表。
- 调用方法时，必须使用ref修饰实参，并且因为是引用参数，**实参和形参的数据类型一定要完全匹配**。
- **实参只能是变量，不能是常量或者表达式**。
- ref参数在调用之前，一定要进行赋值。

```c#
static void Swap(ref int num1, ref int num2)
{
    int temp;
    temp = num1;
    num1 = num2;
    num2 = temp;
}

static void Main(string[] args)
{
    int num1 = 18, num2 = 7;
    Swap(ref num1, ref num2);
    Console.WriteLine(num1 + " " + num2);  // 7 18
}
```

### out 参数

- out 关键字只对紧跟其后的参数有效，而不是应用于整个参数列表。
- 调用方法时，必须使用out修饰实参，并且因为是引用参数，**实参和形参的数据类型一定要完全匹配**。
- **实参只能是变量，不能是常量或者表达式**。
- out参数在调用之前，可以不进行赋值。
- 使用out参数的方法，可以同时返回多个值。

```c#
static void Add(int num1, int num2, out int num3)
{
    num3 = num1 + num2;
}

static void Main(string[] args)
{
    int num1 = 18, num2 = 7, num3;
    Add(num1, num2, out num3);  // out 可以使用未经初始化的参数
    Console.WriteLine(num3);  // 25
}
```

## 函数重载

函数名相同，参数不同，这个叫函数的重载。

1. 如果参数的个数相同，那么参数的类型就不能相同。
2. 如果参数的类型相同，那么参数的个数就不能相同。

# 类

## 类成员属性

```c#
class Student
{
    public int age
    {
        get { return age; }
        set
        {
            if (value > 0 && value < 100)
            {
                age = value;
            }
            else
            {
                age = 18;
            }
        }
    }
}
```

## 静态与非静态

**静态函数只能访问静态成员，不允许访问实例成员**。

**实例方法既能访问实例成员，也可以访问静态成员。**

**静态类中只允许出现静态成员。**

**静态类不允许被实例化。**

## this

### this 调用自身构造函数

```c#
public Person(string name, string description, int age, int id)
{
    m_Name = name;
    m_Description = description;
    m_Age = age;
    m_Id = id;
}

public Person(int age, int id) : this("", "", age, id)
{
}
```



# 变量类型

## 常量

编译时常量： `const`

- 定义 const 常量时 必须对其初始化

运行时常量：`readonly`

- 定义 readonly 常量时可以不初始化，后续只能在构造函数中初始化

# 异常处理

异常提供了一种把程序控制权从某个部分转移到另一个部分的方式。C# 异常处理时建立在四个关键词之上的：**try**、**catch**、**finally** 和 **throw**。

- **try**：一个 try 块标识了一个将被激活的特定的异常的代码块。后跟一个或多个 catch 块。
- **catch**：程序通过异常处理程序捕获异常。catch 关键字表示异常的捕获。
- **finally**：finally 块用于执行给定的语句，不管异常是否被抛出都会执行。例如，如果您打开一个文件，不管是否出现异常文件都要被关闭。
- **throw**：当问题出现时，程序抛出一个异常。使用 throw 关键字来完成。

**语法：**

假设一个块将出现异常，一个方法使用 try 和 catch 关键字捕获异常。try/catch 块内的代码为受保护的代码，使用 try/catch 语法如下所示：

```c#
try
{
   // 引起异常的语句
}
catch( ExceptionName e1 )
{
   // 错误处理代码
}
catch( ExceptionName e2 )
{
   // 错误处理代码
}
catch( ExceptionName eN )
{
   // 错误处理代码
}
finally
{
   // 要执行的语句
}
```

## C# 中的异常类

C# 异常是使用类来表示的。C# 中的异常类主要是直接或间接地派生于 **System.Exception** 类。**System.ApplicationException** 和 **System.SystemException** 类是派生于 System.Exception 类的异常类。

**System.ApplicationException** 类支持由应用程序生成的异常。所以程序员定义的异常都应派生自该类。

**System.SystemException** 类是所有预定义的系统异常的基类。

下表列出了一些派生自 System.SystemException 类的预定义的异常类：

| 异常类                            | 描述                                           |
| :-------------------------------- | :--------------------------------------------- |
| System.IO.IOException             | 处理 I/O 错误。                                |
| System.IndexOutOfRangeException   | 处理当方法指向超出范围的数组索引时生成的错误。 |
| System.ArrayTypeMismatchException | 处理当数组类型不匹配时生成的错误。             |
| System.NullReferenceException     | 处理当依从一个空对象时生成的错误。             |
| System.DivideByZeroException      | 处理当除以零时生成的错误。                     |
| System.InvalidCastException       | 处理在类型转换期间生成的错误。                 |
| System.OutOfMemoryException       | 处理空闲内存不足生成的错误。                   |
| System.StackOverflowException     | 处理栈溢出生成的错误。                         |

# 封装

**封装** 被定义为"把一个或多个项目封闭在一个物理的或者逻辑的包中"。在面向对象程序设计方法论中，封装是为了防止对实现细节的访问。

抽象和封装是面向对象程序设计的相关特性。抽象允许相关信息可视化，封装则使开发者*实现所需级别的抽象*。

C# 封装根据具体的需要，设置使用者的访问权限，并通过 **访问修饰符** 来实现。

一个 **访问修饰符** 定义了一个类成员的范围和可见性。C# 支持的访问修饰符如下所示：

- public：所有对象都可以访问；
- internal：同一个程序集的对象可以访问；
- protected：只有该类对象及其子类对象可以访问
- protected internal：访问限于当前程序集或派生自包含类的类型。
- private：对象本身在对象内部可以访问；

---

-  (1) **Pubilc** ：任何公有成员可以被外部的类访问。
-  (2) **Private** ：只有同一个类中的函数可以访问它的私有成员。
-  (3) **Protected** ：该类内部和继承类中可以访问。
-  (4) **internal** : 同一个程序集的对象可以访问。
-  (5) **Protected internal** ：3 和 4 的并集，符合任意一条都可以访问。

范围比较：

```c#
private < internal/protected < protected internal < public
```

