# C++简介

## 简介

C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。

C++ 被认为是一种**中级**语言，它综合了高级语言和低级语言的特点。

C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山**贝尔实验室**开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。

C++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。

**注意：**使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。

## 面向对象程序设计

C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性：

- 封装
- 抽象
- 继承
- 多态

## 标准库

标准的 C++ 由三个重要部分组成：

- 核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。
- C++ 标准库，提供了大量的函数，用于操作文件、字符串等。
- 标准模板库（STL），提供了大量的方法，用于操作数据结构等。

## ANSI 标准

ANSI 标准是为了确保 C++ 的便携性 —— 您所编写的代码在 Mac、UNIX、Windows、Alpha 计算机上都能通过编译。

由于 ANSI 标准已稳定使用了很长的时间，所有主要的 C++ 编译器的制造商都支持 ANSI 标准。

## 学习 C++

学习 C++，关键是要理解概念，而不应过于深究语言的技术细节。

学习程序设计语言的目的是为了成为一个更好的程序员，也就是说，是为了能更有效率地设计和实现新系统，以及维护旧系统。

C++ 支持多种编程风格。您可以使用 Fortran、C、Smalltalk 等任意一种语言的编程风格来编写代码。每种风格都能有效地保证运行时间效率和空间效率。

## C++ 的使用

基本上每个应用程序领域的程序员都有使用 C++。

C++ 通常用于编写设备驱动程序和其他要求实时性的直接操作硬件的软件。

C++ 广泛用于教学和研究。

任何一个使用苹果电脑或 Windows PC 机的用户都在间接地使用 C++，因为这些系统的主要用户接口是使用 C++ 编写的。

## 标准化

| 发布时间 | 通称                    | 备注                       |
| :------- | :---------------------- | :------------------------- |
| 2017     | C++17                   | 第五个C++标准              |
| 2017     | coroutines TS           | 协程库扩展                 |
| 2017     | ranges TS               | 提供范围机制               |
| 2017     | library fundamentals TS | 标准库扩展                 |
| 2016     | concurrency TS          | 用于并发计算的扩展         |
| 2015     | concepts TS             | 概念库，用于优化编译期信息 |
| 2015     | TM TS                   | 事务性内存操作             |
| 2015     | parallelism TS          | 用于并行计算的扩展         |
| 2015     | filesystem TS           | 文件系统                   |
| 2014     | C++14                   | 第四个C++标准              |
| 2011     | -                       | 十进制浮点数扩展           |
| 2011     | C++11                   | 第三个C++标准              |
| 2010     | -                       | 数学函数扩展               |
| 2007     | C++TR1                  | C++技术报告：库扩展        |
| 2006     | -                       | C++性能技术报告            |
| 2003     | C++03                   | 第二个C++标准              |
| 1998     | C++98                   | 第一个C++标准              |

# 基本语法

C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。现在让我们简要地看一下什么是类、对象，方法、即时变量。

- **对象 -** 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。
- **类 -** 类可以定义为描述对象行为/状态的模板/蓝图。
- **方法 -** 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。
- **即时变量 -** 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。

## C++ 程序结构

让我们看一段简单的代码，可以输出单词 *Hello World*。

## 实例

```c++
#include <iostream>
using namespace std;
 
// main() 是程序开始执行的地方
 
int main()
{
   cout << "Hello World"; // 输出 Hello World
   return 0;
}
```

接下来我们讲解一下上面这段程序：

- C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 **<iostream>**。
- 下一行 **using namespace std;** 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。
- 下一行 **// main() 是程序开始执行的地方** 是一个单行注释。单行注释以 // 开头，在行末结束。
- 下一行 **int main()** 是主函数，程序从这里开始执行。
- 下一行 **cout << "Hello World";** 会在屏幕上显示消息 "Hello World"。
- 下一行 **return 0;** 终止 main( )函数，并向调用进程返回值 0。

## C++ 中的分号 & 语句块

- 在 C++ 中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。

- 语句块是一组使用大括号括起来的按逻辑连接的语句。
- C++ 不以行末作为结束符的标识，因此，您可以在一行上放置多个语句。

`x = y; y = y+1; add(x, y);`

## C++ 标识符

C++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。

一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。

C++ 标识符内不允许出现标点字符，比如 @、& 和 %。C++ 是区分大小写的编程语言。因此，在 C++ 中，**Manpower** 和 **manpower** 是两个不同的标识符。

## C++ 关键字

下表列出了 C++ 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。

| **asm**      | **else**      | **new**          | **this**    |
| ------------ | ------------- | ---------------- | ----------- |
| **auto**     | **enum**      | **operator**     | **throw**   |
| **bool**     | explicit      | **private**      | **true**    |
| **break**    | export        | **protected**    | try         |
| **case**     | extern        | **public**       | **typedef** |
| catch        | **false**     | register         | typeid      |
| **char**     | **float**     | reinterpret_cast | typename    |
| **class**    | **for**       | **return**       | union       |
| **const**    | **friend**    | **short**        | unsigned    |
| const_cast   | **goto**      | signed           | **using**   |
| **continue** | **if**        | **sizeof**       | **virtual** |
| default      | inline        | **static**       | **void**    |
| **delete**   | **int**       | static_cast      | volatile    |
| **do**       | **long**      | **struct**       | wchar_t     |
| **double**   | mutable       | **switch**       | **while**   |
| dynamic_cast | **namespace** | template         |             |

完整关键字介绍可查阅：[C++ 的关键字（保留字）完整介绍](https://www.runoob.com/w3cnote/cpp-keyword-intro.html)

## 三字符组

三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。三字符序列总是以两个问号开头。

三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。以前为了表示键盘上没有的字符，这是必不可少的一种方法。

三字符序列可以出现在任何地方，包括字符串、字符序列、注释和预处理指令。

下面列出了最常用的三字符序列：

| 三字符组 | 替换 |
| :------- | :--- |
| ??=      | #    |
| ??/      | \    |
| ??'      | ^    |
| ??(      | [    |
| ??)      | ]    |
| ??!      | \|   |
| ??<      | {    |
| ??>      | }    |
| ??-      | ~    |

如果希望在源程序中有两个连续的问号，且不希望被预处理器替换，这种情况出现在字符常量、字符串字面值或者是程序注释中，可选办法是用字符串的自动连接："...?""?..."或者转义序列："...?\?..."。

**从Microsoft Visual C++ 2010版开始，该编译器默认不再自动替换三字符组。如果需要使用三字符组替换（如为了兼容古老的软件代码），需要设置编译器命令行选项** `/Zc:trigraphs`

g++仍默认支持三字符组，但会给出编译警告。

## C++ 中的空格

只包含空格的行，被称为空白行，可能带有注释，C++ 编译器会完全忽略它。

在 C++ 中，**空格** 用于描述 **空白符、制表符、换行符和注释** 。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。因此，在下面的语句中：

```
int age;
```

在这里，int 和 age 之间必须至少有一个空格字符（通常是一个空白符），这样编译器才能够区分它们。另一方面，在下面的语句中：

```
fruit = apples + oranges;   // 获取水果的总数
```

fruit 和 =，或者 = 和 apples 之间的空格字符不是必需的，但是为了增强可读性，您可以根据需要适当增加一些空格。

## C++ 中的include

**`< >`** 先去系统目录中找头文件，如果没有在到当前目录下找。所以像标准的头文件 stdio.h、stdlib.h 等用这个方法。

**`" "`** 首先在当前目录下寻找，如果找不到，再到系统目录中寻找。 这个用于 include 自定义的头文件，让系统优先使用当前目录中定义的。

## C++ 中的 :: 符号

**`::`** 在 C++ 中表示作用域，和所属关系。 **`::`** 是运算符中等级最高的，它分为三种，分别如下：

- **作用域符号:**

  作用域符号 **`::`** 的前面一般是类名称，后面一般是该类的成员名称，C++ 为例避免不同的类有名称相同的成员而采用作用域的方式进行区分。

  例如：A,B 表示两个类，在 A,B 中都有成员 member。

  那么：

  -  1、A::member就表示类A中的成员member。
  -  2、B::member就表示类B中的成员member。

- **全局作用域符号:**

  全局作用域符号：当全局变量在局部函数中与其中某个变量重名，那么就可以用 **`::`** 来区分，例如：

  ```cpp
  int global_a = 1;
  void ParamType()
  {
      // 如果函数类同时存在全局变量和局部变量，可以用 :: 调用全局变量
      int global_a = 10;
      std::cout << global_a << std::endl;
      std::cout << ::global_a << std::endl;
  }
  ```

  output:

  ```cpp
  10
  1
  ```

- **作用域分解运算符：**

  还用于函数外部定义；以及调用类实例中的变量

  ```cpp
  class CA 
  {
  public:
    int ca_var;
    int add(int a, int b);
    int add(int a);
  }
  //那么在实现这个函数时，必须这样写：
  int CA::add(int a, int b)
  {
    return a + b;
  }
  //另外，双冒号也常常用于在类变量内部作为当前类实例的元素进行表示，比如：
  int CA::add(int a)
  {
    return a + CA::ca_var;	//表示当前类实例中的变量ca_var。
  }
  ```

# C++ 注释

程序的注释是解释性语句，您可以在 C++ 代码中包含注释，这将提高源代码的可读性。所有的编程语言都允许某种形式的注释。

C++ 支持单行注释和多行注释。注释中的所有字符会被 C++ 编译器忽略。

C++ 注释一般有两种：

- **//** - 一般用于单行注释。
- /*** ... \*/** - 一般用于多行注释。

# C++ 数据类型

使用编程语言进行编程时，需要用到各种变量来存储各种信息。变量保留的是它所存储的值的内存位置。这意味着，当您创建一个变量时，就会在内存中保留一些空间。

您可能需要存储各种数据类型（比如字符型、宽字符型、整型、浮点型、双浮点型、布尔型等）的信息，操作系统会根据变量的数据类型，来分配内存和决定在保留内存中存储什么。

## 基本的内置类型

C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：

| 类型     | 关键字  |
| :------- | :------ |
| 布尔型   | bool    |
| 字符型   | char    |
| 整型     | int     |
| 浮点型   | float   |
| 双浮点型 | double  |
| 无类型   | void    |
| 宽字符型 | wchar_t |

其实 wchar_t 是这样来的：

```
typedef short int wchar_t;
```

所以 wchar_t 实际上的空间是和 short int 一样。

一些基本类型可以使用一个或多个类型修饰符进行修饰：

- signed
- unsigned
- short
- long

下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。

**注意：**不同系统会有所差异，一字节为 8 位。

**注意：**long int 8 个字节，int 都是 4 个字节，早期的 C 编译器定义了 long int 占用 4 个字节，int 占用 2 个字节，新版的 C/C++ 标准兼容了早期的这一设定。

| 类型               | 位            | 范围                                                         |
| :----------------- | :------------ | :----------------------------------------------------------- |
| char               | 1 个字节      | -128 到 127 或者 0 到 255                                    |
| unsigned char      | 1 个字节      | 0 到 255                                                     |
| signed char        | 1 个字节      | -128 到 127                                                  |
| int                | 4 个字节      | -2147483648 到 2147483647（-2^31 ~ 2^31-1）                  |
| unsigned int       | 4 个字节      | 0 到 4294967295                                              |
| signed int         | 4 个字节      | -2147483648 到 2147483647                                    |
| short int          | 2 个字节      | -32768 到 32767（-2^15 ~ 2^15-1）                            |
| unsigned short int | 2 个字节      | 0 到 65,535 (2^16-1)                                         |
| signed short int   | 2 个字节      | -32768 到 32767                                              |
| long int           | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807      |
| signed long int    | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807      |
| unsigned long int  | 8 个字节      | 0 到 18,446,744,073,709,551,615                              |
| float              | 4 个字节      | 精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个有效数字) |
| double             | 8 个字节      | 双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个有效数字) |
| long double        | 16 个字节     | 长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。 |
| wchar_t            | 2 或 4 个字节 | 1 个宽字符                                                   |

从上表可得知，变量的大小会根据编译器和所使用的电脑而有所不同。

 ## sizeof

如果记不住类型所占内存大小，可以直接用关键字`sizeof`来进行查询。

`sizeof(int)`

整型结论：**short < int <= long <= long long**

### 为什么long和int都是4字节

如果你测试过long和int内置类型的大小，当发现都为4字节时，可能都会产生疑问，如果都是4字节，long并没有提供更大的存储范围，那么还要long做什么用？本文如下内容将为你解开这些疑团。

先简要概述以下内置类型的发展，如有疏漏，还请指正。C语言开始时只有char(8位)和int(16位)两种，后来随着发展又加入了short(16位)和long(32位)，此时，int可以是16位或者32位，依赖于平台和后续的兼容性。再后来当64位出现时，long long(64位)又被添加进来，为了进行规范，对较小的一些类型的范围就有了一些调整，逐渐稳定为int32位，long可以有多种定义，可以是32位，也可以是64位。

C++标准上只是说long至少要和int一样大，所有整数类型实现时要满足如下规范：

sizeof(char)  ==  1

sizeof(char)  <=  sizeof(short) <=  sizeof(int) <=  sizeof(long) <= sizeof(long long)

sizeof(long long) == 8	

除了`char`和`long long`，其余的类型范围较灵活，都是平台相关的，与实现相关。如果要实现平台独立的话，在windows平台上，就有`__intn`可以使用，n代表位数。`__int8、__int16、__int32、__int64`。

- 编译器数据模型的区别

| Datetype（bit） | LP64 | ILP64 | LLP64 | ILP32 | LP32 |
| :-------------- | :--: | :---: | :---: | :---: | :--: |
| char            |  8   |   8   |   8   |   8   |  8   |
| short           |  16  |  16   |  16   |  16   |  16  |
| int             |  32  |  64   |  32   |  32   |  16  |
| long            |  64  |  64   |  32   |  32   |  32  |
| long long       |  64  |  64   |  64   |  64   |  64  |
| pointer         |  64  |  64   |  64   |  32   |  32  |

​	一般情况下windows64位一般使用LLP64模型

​	64位Unix,Linux使用的是LP64模型

## 字符型

`char ch = 'a'`

字符型每次只能创建一个字符，并且只能用单引号`''`，一个字符内存中存储的是对应的ASCII码，占用1个字节。

- 查看ASCII码

强制转化类型：`(int)ch`

需要记住的ASCII码：`a -97` ;`A - 65`。

### 输出的小知识

C语言中%p,%u,%lu都有什么用处？
%p表示输出这个指针,
%d表示后面的输出类型为有符号的10进制整形，
%u表示无符号10进制整型，
%lu表示输出无符号长整型整数 (long unsigned)

C语言中的%p和%x的区别
格式控制符“%p”中的p是pointer（指针）的缩写。指针的值是语言实现（编译程序）相关的，但几乎所有实现中，指针的值都是一个表示地址空间中某个存储器单元的整数。printf函数族中对于%p一般以十六进制整数方式输出指针的值，附加前缀0x。
示例：

```cpp
int i = 1;
printf("%p",&i);
相当于
int i = 1;
printf(“0x%x”,&i);
```

对于32位的指针，输出一般会是类似0xf0001234之类的结果。

### char * 和 char [] 的区别

`char *s` 定义了一个char型的指针，它只知道所指向的内存单元，并不知道这个内存单元有多大，所以：

**当char *s = “hello”;后,不能使用s[0]=‘a’；语句进行赋值。这是将提示内存不能为"written"。**

当用char s[]=“hello”;后，完全可以使用s[0]=‘a’；进行赋值，这是常规的数组操作。

```cpp
void Research_CharArray() {
	char s1[] = "hello world";
	s1[0] = 'H';
	std::cout << s1 << std::endl;		// 能够正常打印，因为 s1 是数组

	const char* s2 = "hello world";
	//s2[0] = 'H';		// 报错，因为 s2 是一个指针指向了字符串的第一个字符所在地址
}
```

- **“初始化“::无法从const char* 转换为char***

  C和C++11有所不同:

```cpp
// C
char *a="hello";
char *b={"hello","world"};
// C++11
const char *a="hello";
const char *b[]={"hello","world"}
```

char str[]这里单独的str表示的是一个char类型的数组指针，该指针所指向的数组内容是保存在栈上面的，是可以修改的。

而char *str是一个字符串指针，这个指针指向的是字符串第一个字符的地址，而这个指针存在栈上，但是字符串的内容并不在栈里面，而在字符常量区域里面储存。

所以查看char *str1 = "abcd1234"与char *str2 = "abcd1234"的地址时，他们都是储存的字符a的地址，所以这个地址时相同的，所以其 %p 的值也是一样的，但是char str3[] = “abcd1234” 与 char str[] = "abcd1234"是分别两个char类型的数组，而str3与str4分别表示的是char型的数组指针，所以他们的地址时不同的。

```cpp
void Research_CharArray1() {
	const char* str1 = "abcd1234";
	char str2[] = "abcd1234";
	printf("%u  %u\n", strlen(str1), strlen(str2));

	const char* str3 = "abcd1234";
	char str4[] = "abcd1234";
	printf("%p  %p\n", str1, str3);		// 00007FF699FD2268  00007FF699FD2268
	printf("%p  %p\n", str2, str4);		// 0000006F96D6FCE0  0000006F96D6FCF0

	strncpy_s(str2, str4, 4);		// 将 str4 的前 4 个字符复制到 str2
	printf("%s\n%s\n", str2, str4);		// 可修改，但是 char* 不可修改
}
```

## 转义字符

常用的转义字符：`\n \\ \t`

| 转义字符 | 含义                               | ASCII码 |
| :------- | :--------------------------------- | :------ |
| \n       | 换行(LF)，将当前位置移到下一行开头 | 010     |
| \t       | 水平制表(HT)(跳到下一个TAB位置)    | 009     |
| \\\      | 代表一个反斜线字符 \               | 092     |
| \\'      | 单引号                             | 039     |
| \\"      | 双引号                             | 034     |
| \?       | 问号                               | 063     |
| \a       | 警报                               | 007     |

## 字符串型

### C风格字符串

- `char 变量名[] = "字符串值"`

字符串名后面需要加一个`[]`；字符是单引号，字符串是双引号。

### C++风格字符串

- `string 变量名 = ""`

头文件需要加入`#include <string>`，但是VS2019不需要。

```cpp
void CStyleString() {
	// C 风格字符串
	char CString[] = "Jacob-xyb by C";
	// C++ 风格字符串
	std::string CppString = "Jacob-xyb by Cpp";

	std::cout << CString << std::endl;
	std::cout << CppString << std::endl;
}
```

## 基础数据类型转换

```cpp
void dataType_TypeConversion()
{
	// num to string
	int numI = 100;
	double numD = 100;
	float numF = 100;
	string strI = to_string(numI);
	string strD = to_string(numD);
	string strF = to_string(numF);

	// string to num
	string str = "100";
	numI = stoi(str);
	numD = stod(str);
	numF = stof(str);
}
```

# 运算符

| 运算符类型 | 作用             |
| ---------- | ---------------- |
| 算术运算符 | 四则运算         |
| 赋值运算符 | 赋值             |
| 比较运算符 | 比较，返回真或假 |
| 逻辑运算符 | 比较，返回真或假 |

- 运算符类型

  ```cpp
  算术运算符： +  -  *  /  %  ^  ! ···
  关系运算符(6个)： ==  !=  >  >=  <  <=
  赋值运算符： =  +=  -=  *=  /=  %= ···
  逻辑运算符：&&  ||
  ```

- 优先级

  ！ > 算术运算符 > 关系运算符 > && > || > 赋值运算符

## 算术运算符

假设变量 A 的值为 10，变量 B 的值为 20，则：

| 运算符 | 描述                             | 实例             |
| :----- | :------------------------------- | :--------------- |
| +      | 把两个操作数相加                 | A + B 将得到 30  |
| -      | 从第一个操作数中减去第二个操作数 | A - B 将得到 -10 |
| *      | 把两个操作数相乘                 | A * B 将得到 200 |
| /      | 分子除以分母                     | B / A 将得到 2   |
| %      | 取模运算符，整除后的余数         | B % A 将得到 0   |
| ++     | 整数值增加 1                     | A++ 将得到 11    |
| --     | 整数值减少 1                     | A-- 将得到 9     |

- 注意：

1. `int / int` 结果依然是整数，小数部分去除（不是四舍五入！）；

2. 只能 `int % int` ，取模运算只能是整型变量间运行；

- ++ 和 --

`++a` 前置递增 ；`a++` 后置递增；前置后置都会使 a 的值加 1。

但是 `++a 前置递增` 先让变量+1，然后进行表达式运算；`a++ 后置递增` 先进行表达式的运算，后让变量+1。

```cpp
// 前置递增
int a1 = 10;
int b1 = ++a1 * 10;
// 结果：a1=11 b1=110
    
// 后置递增
int a2 = 10;
int b2 = a2++ * 10;
// 结果：a2=11 b2=100
```

## 赋值运算符

下表列出了 C++ 支持的赋值运算符：

| 运算符 | 描述                                                         | 实例                            |
| :----- | :----------------------------------------------------------- | :------------------------------ |
| =      | 简单的赋值运算符，把右边操作数的值赋给左边操作数             | C = A + B 将把 A + B 的值赋给 C |
| +=     | 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 | C += A 相当于 C = C + A         |
| -=     | 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 | C -= A 相当于 C = C - A         |
| *=     | 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 | C *= A 相当于 C = C * A         |
| /=     | 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 | C /= A 相当于 C = C / A         |
| %=     | 求模且赋值运算符，求两个操作数的模赋值给左边操作数           | C %= A 相当于 C = C % A         |
| <<=    | 左移且赋值运算符                                             | C <<= 2 等同于 C = C << 2       |
| >>=    | 右移且赋值运算符                                             | C >>= 2 等同于 C = C >> 2       |
| &=     | 按位与且赋值运算符                                           | C &= 2 等同于 C = C & 2         |
| ^=     | 按位异或且赋值运算符                                         | C ^= 2 等同于 C = C ^ 2         |
| \|=    | 按位或且赋值运算符                                           | C \|= 2 等同于 C = C \| 2       |

```cpp
void BinaryRecursion(int n)
{
	int a = n % 2;
	n >>= 1;
	if (n != 0)
	{
		BinaryRecursion(n);
	}
	std::cout << a;
}

void AssignmentOperator() {
	// 和算术运算符相关的赋值运算符就不介绍了

	// 位运算符
	std::cout << "位运算：" << std::endl;
	std::cout << "1 << 2 = " << (1 << 2) << std::endl;		// 4
	std::cout << "1 << 4 = " << (1 << 4) << std::endl;		// 16
	std::cout << "8 >> 1 = " << (8 >> 1) << std::endl;		// 4

	// 与或运算
	std::cout << "1100 & 100 = ";	// 1100 & 100 = 100
	BinaryRecursion(0xc & 0x4);
	std::cout << std::endl;		
	std::cout << "1010 | 110 = ";	// 1010 & 110 = 1110
	BinaryRecursion(10 | 6);
	std::cout << std::endl;		
	std::cout << "1010 ^ 110 = ";	// 1010 & 110 = 1100
	BinaryRecursion(10 ^ 6);
	std::cout << std::endl;
}

/*
位运算：
1 << 2 = 4
1 << 4 = 16
8 >> 1 = 4

与或运算：
1100 & 100 = 100
1010 | 110 = 1110
1010 ^ 110 = 1100
*/
```

## 关系运算符

下表显示了 C++ 支持的关系运算符。

假设变量 A 的值为 10，变量 B 的值为 20，则：

| 运算符 | 描述                                                         | 实例              |
| :----- | :----------------------------------------------------------- | :---------------- |
| ==     | 检查两个操作数的值是否相等，如果相等则条件为真。             | (A == B) 不为真。 |
| !=     | 检查两个操作数的值是否相等，如果不相等则条件为真。           | (A != B) 为真。   |
| >      | 检查左操作数的值是否大于右操作数的值，如果是则条件为真。     | (A > B) 不为真。  |
| <      | 检查左操作数的值是否小于右操作数的值，如果是则条件为真。     | (A < B) 为真。    |
| >=     | 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 | (A >= B) 不为真。 |
| <=     | 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 | (A <= B) 为真。   |

## 逻辑运算符

下表显示了 C++ 支持的关系逻辑运算符。

假设变量 A 的值为 1，变量 B 的值为 0，则：

| 运算符 | 描述                                                         | 实例                 |
| :----- | :----------------------------------------------------------- | :------------------- |
| &&     | 称为逻辑与运算符。如果两个操作数都 true，则条件为 true。     | (A && B) 为 false。  |
| \|\|   | 称为逻辑或运算符。如果两个操作数中有任意一个 true，则条件为 true。 | (A \|\| B) 为 true。 |
| !      | 称为逻辑非运算符。用来逆转操作数的逻辑状态，如果条件为 true 则逻辑非运算符将使其为 false。 | !(A && B) 为 true。  |

### 与运算符

- 注意事项：

  condition1 && condition2时，会优先判断condition1，

  condition1不满足时会直接返回false，并不会再执行conditon2。

  ```cpp
  void test()
  {
  	vector<int> digits{ 9,9,9 };
  	int bit = digits.size() - 1;
  	while (bit >= 0 && digits[bit] == 9)
  	//while (digits[bit] == 9 && bit >= 0)	//Expression: vector subscript out of range 
  	{
  		digits[bit] = 0;
  		bit--;
  	}
  	for (int i = 0; i < digits.size(); i++)
  	{
  		cout << digits[i] << " ";
  	}
  	cout << endl;
  }
  ```

  虽然有这样的一个机制，但是极不推荐，应该想出更稳定的方法避免潜在的隐患。

### 逗号运算符

在C语言和C++语言中，可以把多个表达式用逗号联接起来，构成一个更大的表达式。其中的逗号称为**逗号运算符**，所构成的表达式称为**逗号表达式**。逗号表达式中用逗号分开的表达式分别求值，以最后一个表达式的值作为整个表达式的值。

`表达式1, 表达式2`

- 逗号运算符确保操作数被顺序地处理：先计算左边的操作数（表达式1），再计算右边的操作数（表达式2）
- 右操作数的类型和值作为整个表达式的结果
- 左操作数只是为了副作用需要而被计算，它的值会被丢弃

```cpp
void CommaOperator() {
	int a = 1;
	int b = 2;
	int c = (a, b++, a+=b);
	std::cout << c << std::endl;		// 4
	// 计算顺序为：a=1, b=2+1=3, a=a+b=1+3=4, c=a=4
}
```

在上例中，计算顺序为：a=1, b=2+1=3, a=a+b=1+3=4, c=a=4

# 程序流程结构

C/C++ 支持最基本的三种程序运行结构：

- 顺序结构：程序按顺序执行，不发生跳转
- 选择结构：依据条件是否满足，有选择的执行相应功能
- 循环结构：依据条件是否满足，循环多次执行某段代码

## 选择结构

- if

```cpp
if(boolean_expression)
{
   // 如果布尔表达式为真将执行的语句
}
```

- if .. else

```cpp
if(boolean_expression)
{
   // 如果布尔表达式为真将执行的语句
}
else
{
   // 如果布尔表达式为假将执行的语句
}
```

- 多条件 if 语句

```cpp
if(boolean_expression)
{
    // 判断为真时将执行的语句
}
else if(boolean_expression)  // 第二个条件
{
    // 判断为真时将执行的语句
}
else
{
    // 判断为真时将执行的语句
}
```

- if 嵌套

```cpp
if( boolean_expression 1)
{
   // 当布尔表达式 1 为真时执行
   if(boolean_expression 2)
   {
      // 当布尔表达式 2 为真时执行
   }
}
```

- 三目运算符*

 [**条件运算符 ? :**](https://www.runoob.com/cplusplus/cpp-conditional-operator.html) 可以用来替代 **if...else** 语句。它的一般形式如下：

```
Exp1 ? Exp2 : Exp3;
```

其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。

? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。

```cpp
int a = 10; int b = 20; int c = 0;
c = (a > b ? a : b);  // c 就是 a b 中最大的值
```

还可以对返回的变量继续赋值

```cpp
(a > b ? a : b) = 100;  // a b 中最大值会被重新赋值为 100
cout << "a= " << a << ", b= " << b << endl;
```

```cpp
void TripletOperator() {
	int a = 10; int b = 20; int c = 0;
	c = (a > b ? a : b);  // c 就是 a b 中最大的值

	std::cout << "三目运算符用于返回：" << std::endl;
	std::cout << c << std::endl;	// 20

	std::cout << "三目运算符用于赋值：" << std::endl;
	(a > b ? a : b) = 100;
	std::cout << b << std::endl;	// 100
}
```

- switch

一个 **switch** 语句允许测试一个变量等于多个值时的情况。每个值称为一个 case，且被测试的变量会对每个 **switch case** 进行检查。

```cpp
switch(expression--表达式){
    case constant-expression--结果1 :
       statement(s);
       break; // 可选的
    case constant-expression--结果2 :
       statement(s);
       break; // 可选的
  
    // 您可以有任意数量的 case 语句
    default : // 可选的
       statement(s);
}
```

**switch** 语句必须遵循下面的规则：

- **switch** 语句中的 **expression** 必须是一个整型或枚举类型，或者是一个 class 类型，其中 class 有一个单一的转换函数将其转换为整型或枚举类型。
- 在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。
- case 的 **constant-expression** 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。
- 当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 **break** 语句为止。
- 当遇到 **break** 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。
- 不是每一个 case 都需要包含 **break**。如果 case 语句不包含 **break**，控制流将会 *继续* 后续的 case，直到遇到 break 为止。
- 一个 **switch** 语句可以有一个可选的 **default** case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 **break** 语句不是必需的。

![](https://www.runoob.com/wp-content/uploads/2014/09/switch_statement.jpg)

- 注意：

1. `if`后面不能加分号，不然无论是否满足条件都会执行下面语句。 
2. `switch`缺点，判断时候只能是整型或者字符型，不可以是一个区间
3. `switch`优点，结构清晰，执行效率高。

## 循环结构

### while 循环

```cpp
while(condition)
{
   statement(s);
}
```

### do...while循环

**do...while** 循环是在循环的尾部检查它的条件。

```cpp
do
{
   statement(s);

}while( condition );
```

请注意，条件表达式出现在循环的尾部，所以循环中的 statement(s) 会在条件被测试之前至少执行一次。

### for 循环

```cpp
for ( init; condition; increment )
{
   statement(s);
}
```

下面是 for 循环的控制流：

1. **init** 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。
2. 接下来，会判断 **condition**。如果为真，则执行循环主体。如果为假，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。
3. 在执行完 for 循环主体后，控制流会跳回上面的 **increment** 语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。
4. 条件再次被判断。如果为真，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为假时，for 循环终止。

示例：

```cpp
int main(){
    for (int i = 0; i < 10; i++)
    {
        cout << i << endl;
    }
    system("pause");
    return 0;
}
```

### 嵌套循环

一个循环内可以嵌套另一个循环。C++ 允许至少 256 个嵌套层次。

关于嵌套循环有一点值得注意，您可以在任何类型的循环内嵌套其他任何类型的循环。比如，一个 for 循环可以嵌套在一个 while 循环内，反之亦然。

## 跳转语句

### break

C++ 中 **break** 语句有以下两种用法：

1. 当 **break** 语句出现在一个循环内时，循环会立即终止，且程序流将继续执行紧接着循环的下一条语句。
2. 它可用于终止 **switch** 语句中的一个 case。

如果您使用的是嵌套循环（即一个循环内嵌套另一个循环），break 语句会停止执行最内层的循环，然后开始执行该块之后的下一行代码。

### continue

C++ 中的 **continue** 语句有点像 **break** 语句。但它不是强迫终止，continue 会跳过当前循环中的代码，强迫开始下一次循环。

对于 **for** 循环，**continue** 语句会导致执行条件测试和循环增量部分。对于 **while** 和 **do...while** 循环，**continue** 语句会导致程序控制回到条件测试上。

### goto

**goto** 语句允许把控制无条件转移到同一函数内的被标记的语句。

**注意：**在任何编程语言中，都不建议使用 goto 语句。因为它使得程序的控制流难以跟踪，使程序难以理解和难以修改。任何使用 goto 语句的程序可以改写成不需要使用 goto 语句的写法。

```cpp
#include <iostream>
using namespace std;
 
int main ()
{
   // 局部变量声明
   int a = 10;

   // do 循环执行
   LOOP:do
   {
       if( a == 15)
       {
          // 跳过迭代
          a = a + 1;
          goto LOOP;
       }
       cout << "a 的值：" << a << endl;
       a = a + 1;
   }while( a < 20 );
 
   return 0;
}
```

**建议：**只在退出深度循环时使用：

```cpp
for(...) {
   for(...) {
      while(...) {
         if(...) goto stop;
         .
         .
         .
      }
   }
}
stop:
cout << "Error in program.\n";
```

# 数组

C++ 支持**数组**数据结构，它可以存储一个`固定大小`的`相同类型元素`的`顺序集合`。数组是用来存储一系列数据，但它往往被认为是`一系列相同类型的变量`。

数组的声明并不是声明一个个单独的变量，比如 number0、number1、...、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers[0]、numbers[1]、...、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。

所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。

## 一维数组

### 声明数组

在 C++ 中一维数组有三种方法声明一个数组：

```cpp
// 1.使用未初始化的内存，不会补0，但是可以调用
type arrayName [ arraySize ];

// 2.使用初始化的内存，会补0
type arrayName [ arraySize ] = {};	// 会有 arraySize 个 0
type arrayName [ arraySize ] = { val1, val2 ...};	// 没有定义的话会自动补 0

// 3.长度会依据输入的数据个数而定
type arrayName[] = { val1, val2 ...};
```

这叫做一维数组。**arraySize** 必须是一个大于零的整数常量，**type** 可以是任意有效的 C++ 数据类型。

> 需要注意是：C++数组标签超过上限并不会报错，而是读未初始化的内存。

```cpp
void ArrayDeclarationWay() {
	// 1.使用未初始化的内存，不会补0，但是可以调用
	int arr1[10];
	PrintArrry(arr1, 10);		// [-1283640808, 32759, -1283647303, 32759, 31, 0, 1, 0, 0, 0, ]

	// 2.使用初始化的内存，会补0
	int arr2_1[4] = {};	// 会有 arraySize 个 0
	PrintArrry(arr2_1, 4);		// [0, 0, 0, 0, ]
	int arr2_2[4] = { 1, 2 };	// 没有定义的话会自动补 0
	PrintArrry(arr2_2, 4);		// [1, 2, 0, 0, ]

	// 3.长度会依据输入的数据个数而定
	int arr3_1[] = { 1, 2, 3};
	PrintArrry(arr3_1, 3);		// [1, 2, 3, ]
}

/*
[1146892824, 32759, 1146886633, 32759, 31, 0, 1, 0, 0, 0, ]
[0, 0, 0, 0, ]
[1, 2, 0, 0, ]
[1, 2, 3, ]
*/
```

### 数组名应用

- `sizeof(arr)`

  ```cpp
  sizeof(arr);	// 统计整个数组占用内存空间
  sizeof(arr)/sizeof(arr[0]);		// 统计数组长度
  ```

- 查看首地址

  ```cpp
  cout << arr << endl;	// 可以直接查看 arr数组 首地址 // 十六进制
  cout << (int)arr << endl;	// 可以直接查看 arr数组 首地址 // 十进制
  cout << &arr[0] << endl;	// 查看 arr数组 第一个数据的 首地址
  // arr数组 首地址 == arr数组 第一个数据的 首地址
  // 验证了：数组是连续的数组空间
  ```

- 注意：

  数组名一旦创建，就是一个常量，指向一个首地址，因此不能够再进行赋值，会报错。

- 指针

  `arr` 是类型指针，`&arr` 是数组指针，需要加以区分。

```cpp
void ArrayVariableName() {
	int arr1[] = { 1,2,3,4,5,6,7,8,9 };
	std::cout << arr1 << std::endl;				// 0000000F42AFFAF0
	std::cout << arr1 + 1 << std::endl;			// 0000000F42AFFAF4
	std::cout << *arr1 << std::endl;			// 1
	std::cout << *(arr1 + 1) << std::endl;		// 2
}
```

## 二维数组

### 声明数组

在 C++ 中二维数组有三种方法声明一个数组：

```cpp
// 1.使用未初始化的内存，不会补0
type arrayName [row][col];

// 2.使用初始化的内存，会补0
type arrayName [row][col] = {};		// 会有 row*col 个 0
// 没有定义的话会自动补 0		// 更加直观，提高可读性
type arrayName [row][col] = {{ val11, val12 ...},{ val21, val22 ...}};	
// exp:
int arr[2][3] = 
{
    {1,2,3},
    {4,5,6}
};

// 3.可以写在一起自己分行列
// 这种方式数据个数不能超过 row*col,不足的会补0		// index超过了也不会报错，会获取0
type arrayName [row][col] = {val11, val12 ...};		

// 4.只写列数
// 生成 n*col 的二维数组（矩阵），不足的会补0
type arrayName [][col] = {val11, val12 ...};	
```

> 可以看出，二维数组不声明列数的都是会报错的。

### 数组名应用

- `sizeof(arr)`

  ```cpp
  sizeof(arr);	// 统计整个数组占用内存空间
  sizeof(arr[0]);	// 统计整个数组第一行占用内存空间
  sizeof(arr[0][0]);	// 统计整个数组第一个数据占用内存空间
  
  sizeof(arr)/sizeof(arr[0]);		// 计算行数
  sizeof(arr[0])/sizeof(arr[0][0]);		// 计算列数
  sizeof(arr)/sizeof(arr[0][0]);		// 统计数组数据个数
  ```

- 查看首地址

  ```cpp
  cout << arr << endl;		// 可以直接查看 arr数组 首地址 // 十六进制
  cout << (int)arr << endl;		// 可以直接查看 arr数组 首地址 // 十进制
  cout << &arr[0][0] << endl;		// 查看 arr数组 第一个数据的 首地址
  // arr数组 首地址 == arr数组 第一个数据的 首地址
  // 验证了：数组是连续的数组空间
  ```

## 注意事项

1. **数组名** 是一个常量，为不可修改的左值，不能对其进行赋值操作。

# 函数

函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 **main()** ，所有简单的程序都可以定义其他额外的函数。

函数**声明**告诉编译器函数的名称、返回类型和参数。函数**定义**提供了函数的实际主体。

## 函数的定义

函数的定义一般主要有5个步骤：

1. 返回值类型；有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 **void**。
2. 函数名；函数名和参数列表一起构成了函数签名。
3. 参数列表；参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。
4. 函数体语句；函数主体包含一组定义函数执行任务的语句。
5. return表达式。

- 语法：

  ```cpp
  return_type function_name( parameter list )
  {
     body of the function
  }
  ```

- 实例：

  以下是 **max()** 函数的源代码。该函数有两个参数 num1 和 num2，会返回这两个数中较大的那个数：

  ```cpp
  // 函数返回两个数中较大的那个数
  
  int max(int num1, int num2) 
  {
      // 局部变量声明
  	int result;
  
      if (num1 > num2)
          result = num1;
      else
          result = num2;
  
      return result; 
  }
  ```

## 函数的调用

- `function (prm1,prm2..)`即可。

## 传值调用

- 传值调用：函数调用时实参将数值传入给形参；如果形参发生改变，并不会影响实参。
- 默认情况下，C++ 使用**传值调用**来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的参数。之前提到的实例，调用 max() 函数时，使用了相同的方法。

从内从层面理解：传值调用时，会在内存里面分配出传入参数的内存，相当于复制了一份实参数据。

## 函数的声明

函数**声明**会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。

函数声明包括以下几个部分：

```
return_type function_name( parameter list );
```

针对上面定义的函数 max()，以下是函数声明：

```
int max(int num1, int num2);
```

**在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：**

```
int max(int, int);
```

当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。

> 声明可以有多次，定义只能有一次。

## 分文件编写

- 作用：

  让结构代码更加清晰。

  函数分文件编写一般有4个步骤：

  1. 创建后缀名为`.h`的头文件；
  2. 创建后缀名为`.cpp`的源文件；
  3. 在头文件中写函数的声明；
  4. 在源文件中写函数的定义。

- 示例：

头文件：`function.h`

```cpp
#include <iostream>
using namespace std;

// function declaration
void swap(int, int);
```

函数文件: `function.cpp`

```cpp
#include "function.h"

void swap(int num1, int num2)
{
	int temp;
	temp = num1;
	num1 = num2;
	num2 = temp;

	cout << "x= " << num1 << endl;
	cout << "y= " << num2 << endl;
}
```

主函数文件: `main.cpp`

```cpp
#include <iostream>
using namespace std;
#include "function.h"

int main()
{
	int x = 10;
	int y = 20;
	swap(x, y);
}
```

# 指针

## 基本概念

通过一个指针变量保存一个地址。

**指针的作用：**可以通过指针间接访问内存

- 内存编号是从0开始记录的，一般用十六进制数字表示
- 可以利用指针变量保存地址（理解为：指针就是一个地址）

## 指针变量的定义和使用

指针变量的语法：`变量类型 * 变量名`

```cpp
#include <iostream>
using namespace std;

int main()
{
	// 1.定义指针
	int a = 10;
	// 指针定义语法： 数据类型 * 指针变量名；
	int* p;
	// 创建指针，未记录地址前是无法输出指针的会报错:	// error C4700: 使用了未初始化的局部变量“p”
	// 让指针记录变量 a 的地址
	p = &a;
	cout << "a的地址为： " << &a << endl;
	cout << "指针p的值为： " << p << endl;
	cout << "指针p的地址为： " << &p << endl;
	cout << endl;

	// 2.使用指针
	// 可以通过解引用的方式来找到指针指向的内存	// *p
	cout << "p指向的内存内容为： " << *p << endl;
	// 通过 *p 可以访问和读写 内存内容
	*p = 1000;
	cout << "改写后，a的值变为了：" << a << endl;
	cout << "此时，*p的值变为了： " << *p << endl;
	cout << "但是p的值是没有变的为： " << p << endl;
    cout << "同时，p的内存地址&p也没有变： " << &p << endl;

	return 0;
}
```

## 指针所占内存空间

**指针也是一种数据类型**，指针占据了多少内存空间来存放16进制内存地址呢？

- 无论什么数据类型的指针

  32位操作系统：4字节

  64位操作系统：8字节

## 空指针和野指针

- **空指针**

**空指针：**指针变量指向内存中编号为0的空间

**用途：**初始化指针变量

**注意：**空指针指向的内存是不可以访问的，0~255之间的内存编号是系统占用的，因此不可以访问。

```cpp
//空指针
int* p = NULL;
//	只能查看p指针所指向的地址
cout << p << endl;	//0000000000000000
//	但是不能访问和读写
//cout << *p << endl;	//引发了异常: 读取访问权限冲突。\n p 是 nullptr。
//*p = 100;	//访问都不可，那只要再出现*p就会报错了
```

- 野指针

**野指针：** 指针指向非法的内存空间

```cpp
int* p = (int *)0x1100;		// 避免出现野指针
```

## const修饰指针*

const修饰指针有三种情况：

1. const修饰指针 -- 常量指针
2. const修饰常量 -- 指针常量
3. const既修饰指针，又修饰常量

### const修饰指针 -- 常量指针

```cpp
int a = 10; int b = 20;
const int * p = &a;		// 常量指针
```

**特点：** 指针的指向可以修改，但是指针指向的值不可以修改。

```cpp
// 指针的指向可以修改
p = &b;		// 正确写法

// 指针指向的值不可以修改
*p = 20;		// 错误写法；不能修改指向的值
```

### const修饰常量 -- 指针常量

```cpp
int a = 10; int b = 20;
int * const p = &a;
```

**特点：** 指针的指向不可以修改，但是指针指向的值可以修改。

```cpp
// 指针的指向不可以修改
p = &b;		// 错误写法；不能够修改指向

// 指针指向的值可以修改
*p = 20;		// 正确写法
```

### const既修饰指针，又修饰常量

```cpp
int a = 10; int b = 20;
const int * const p = &a;
```

**特点：** 指针的指向和指向值都不可以修改。

## 指针和数组

**作用：** 利用指针访问数组中元素

### 传递数组给函数

C++ 中通过指定不带索引的数组名来传递一个指向数组的指针。

C++ 传数组给一个函数，数组类型自动转换为指针类型，因而传的实际是地址。

如果您想要在函数中传递一个一维数组作为参数，您必须以下面三种方式来声明函数形式参数，这三种声明方式的结果是一样的，**因为每种方式都会告诉编译器将要接收一个整型指针。**同样地，您也可以传递一个多维数组作为形式参数。

- 方式1：

  形式参数是一个指针：

  ```cpp
  void myFunction(int *param){...}
  ```

- 方式2：

  形式参数是一个已定义大小的数组：

  ```cpp
  void myFunction(int param[10]){...}
  ```

- 方式3：

  形式参数是一个未定义大小的数组：

  ```cpp
  void myFunction(int param[]){...}
  ```

## 指针和函数

前面讲到过，以形参的形式来传递值的话，不会改变原本的值，相当于是在内存中复制了一份，但是用指针传递就可以改变实参的值了。

```cpp
void swap(int*p1,int*p2)
{
    int temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}

// 调用
int a = 10;
int b = 20;
swap(&a, &b)		// 地址传递
```

# 结构体

结构体属于用户**自定义的数据类型**，允许用户存储不同的数据类型。

## 定义和使用

**语法：** `struct 结构体名 { 结构体成员列表 } object_names；`

`object_names` 是变量的名称

**使用：**

```cpp
struct Student
{
	// 成员列表

	// 姓名
	string name;
	// 年龄
	int age;
	// 分数
	int score;
};

// 第一种：struct Student s1
struct Student s1;
s1.name = "张三"; s1.age = 18; s1.score = 100;

// 第二种：struct Student s2 = {...}
struct Student s2 = { "李四",19,80 };		// 不足的会自动补0

    // 第三种：在创建结构体时就创建一个结构体变量
struct Student {...} s3;
s3 = { "王五",20,60 }

// 结构体对象创建时：struct 关键字可以省略
```

## 结构体数组

**作用：** 将自定义的结构体放入到数组中方便维护

**语法：** `struct 结构体名 数组名[arrNum] = { {} ,{},...{}};`

## 结构体指针

**作用：** 通过指针访问结构体中的成员

- 利用操作符` ->` 可以通过结构体指针访问结构体属性

```cpp
struct Student
{
    string name; int age; int score;
};

int main()
{
    struct Student s = {"张三",18,100};
    struct Student * p = &s;
    cout << "姓名：" << p->name << endl;		// p->name == (*p).name  
}
```

## struct 嵌套 struct

```cpp
struct Student {...};
sturct Teacher
{
    struct Student stu;
};
```

## 结构体做函数参数

**作用：** 将结构体作为参数向函数中传递；分为 `值传递` 和 `地址传递`。

```cpp
// 值传递
void function(struct Student x)
{
    cout << x.name << endl;
}

// 地址传递
void function(struct Student* p)
{
    cout << p->name << endl;
}
```

## 结构体中const的应用

- **作用:**
  1.  const防止误操作
  2.  将函数中的形参改为指针，可以减少内存空间，不会复制新的副本出来

```cpp
// 使用const 常量指针可以锁定内存的值而不受改变
void function(const struct Student*p){...}
```

# C++ 核心编程 +++++++

# 内存分区模型

C++程序执行时，将内存大方向划分为4个区域

- 代码区：存放函数体的二进制代码，由操作系统进行管理的
- 全局区：存放全局变量和静态变量以及常量
- 栈区：由编译器自动分配释放，存放函数的参数值、局部变量等
- 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收

内存四区意义：

​    不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程

## 程序运行前

在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域

- 代码区：

  存放CPU执行的机器指令

  代码区是`共享`的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可

  代码区是`只读`的，使其只读的原因是防止程序意外地修改了它的指令

- 全局区：

  全局变量和静态变量存放在此

  全局区还包含了常量区，字符串常量和其他常量也存放在此

  `该区域的数据在程序结束后由操作系统释放`

---

> 变量类型

```cpp
int global_a = 1;           //全局变量
int global_b = 1;           //全局变量
const int CstG_a = 1;       //const修饰的全局变量 - 全局常量
const int CstG_b = 1;       //const修饰的全局变量 - 全局常量
void ParamType_001()
{
    //局部变量
    int a = 1;
    int b = 1;

    //静态变量
    static int static_a = 1;
    static int static_b = 1;

    //常量
    //  字符串常量
    cout << "字符串常量的地址：\t\t" << (int)&"hello" << endl;
    //  const修饰的变量
    //      const修饰的全局变量 - 全局常量
    //      const修饰的局部变量 - 局部常量
    const int Cst_a = 1;
    const int Cst_b = 1;

    //输出
    cout << "全局变量 global_a 地址：\t" << (int)&global_a << endl;
    cout << "全局变量 global_b 地址：\t" << (int)&global_b << endl;
    cout << "局部变量 a 地址：\t\t" << (int)&a << endl;
    cout << "局部变量 b 地址：\t\t" << (int)&b << endl;
    cout << "静态变量 static_a 地址：\t" << (int)&static_a << endl;
    cout << "静态变量 static_b 地址：\t" << (int)&static_b << endl;
    cout << "全局常量 CstG_a 地址：\t\t" << (int)&CstG_a << endl;
    cout << "全局常量 CstG_b 地址：\t\t" << (int)&CstG_b << endl;
    cout << "局部常量 Cst_a 地址：\t\t" << (int)&Cst_a << endl;
    cout << "局部常量 Cst_b 地址：\t\t" << (int)&Cst_b << endl;

    //总结:局部不在全局区，其余(全局变量、静态变量、常量)都在全局区
}
```

输出

```cpp
字符串常量的地址：              -945122828
全局变量 global_a 地址：        -945069968
全局变量 global_b 地址：        -945069964
局部变量 a 地址：               305461044
局部变量 b 地址：               305461076
静态变量 static_a 地址：        -945069960
静态变量 static_b 地址：        -945069956
全局常量 CstG_a 地址：          -945161288
全局常量 CstG_b 地址：          -945161284
局部常量 Cst_a 地址：           305461108
局部常量 Cst_b 地址：           305461140
```

**总结：**

**全局区：**全局变量、静态变量、常量（字符串常量、const修饰的全局变量）

**不在全局区：**局部变量、const修饰的局部变量

## 程序运行后

- 栈区：

  由编译器自动分配释放，存放函数的参数值，局部变量等；

  注意事项：不要返回局部变量的地址，栈开启的数据由编译器自动释放。

```cpp
int* func_Stack_001()
{
    int a = 10; //局部变量  //存放在栈区，栈区的数据在函数执行完后自动释放
    return &a;
}
void Stack_001()
{
    /*注意事项*/
    //  不要返回局部变量的地址
    int* p = func_Stack_001();
    cout << *p << endl;     //能够正常输出10是因为编译器做了保留
}
```

- 堆区：

  由程序员分配释放，若程序员不释放，程序结束时由操作系统回收

  在C++中主要利用new在堆区开辟内存

## new操作符

C++中利用`new`操作符在堆区开辟数据

堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符`delete`

语法：`new 数据类型()`

利用`new`创建的数据，会返回该数据对应的类型的指针

`delete` 释放数组时需要加中括号， `delete[] arr`

  ```cpp
int* func_Heap_001()
{
    //利用new关键字 可以将数据开辟到堆区
    //  指针也是局部变量，存放在栈区
    int* p = new int(10);   //new 返回的是该类型的指针
    int* arr = new int[10]; //10代表数组有10个元素，返回数组的首地址
    delete[] arr;           //手动释放数组
    return p;
}
void Heap_001()
{
    //在堆区开辟数据
    int* p = func_Heap_001();   //程序执行完自动释放
    delete p;                   //也可以手动释放
    //cout << *p << endl;       //error:读取访问权限冲突。
}
  ```

### new一个数组引发的问题

虽然可以通过指针获取创建在堆上的数组大小，但是作为函数引用，你完全不知道这个数组是在哪里：

```cpp
int get_len_array1(int* a) {
	return _msize(a) / sizeof(int);
}

int get_len_array2(int* a) {
	return *(a - 4) / sizeof(int);
}

void Call_point_and_array() {
	int* p1 = new int[10];
	std::cout << get_len_array1(p1) << std::endl;
	std::cout << get_len_array2(p1) << std::endl;
	int p2[10];
	//std::cout << get_len_array1(p2) << std::endl;		// 此处报错
	std::cout << get_len_array2(p2) << std::endl;		// 不报错，但是无法获取正确结果
	delete[] p1;
}
```

如果你的数组大小是编译期已知，那么可以使用数组的引用来避免decay，也就是说你的函数签名可以写成int func(int(&foo)[10])这种。当然更好的方法是使用std::array，这东西本身就免疫decay，而且支持.size()，支持迭代器。

如果数组大小编译期不可知，那么两种方法，一种是C风格，写int func(int* a, size_t n);，自己把大小传进来。一种是C++风格，直接用一个vector来动态分配数组，然后传引用进来。更激进的是改成template并传两个迭代器，不过这种比较overkill。推荐使用vector代替动态分配数组。

至于hack malloc库拿内存分配的元信息这种是不可取的，想都不要想，因为你作为一个通用的函数int func(int* a)，你根本不知道a是不是一个new出来的数组的开头元素，可能它是一个栈上的数组，可能是个static，这个hack不仅跨不了平台，同一个平台上都有很多处理不了的case。

  # 引用

## 引用的基本使用*

作用： 给变量起别名

语法： `数据类型 &别名 = 原名`

```cpp
int a = 10;
int &b = a;		// 引用 // a和b操作的是同一块内存
```

## 引用注意事项*

- **引用必须初始化**
- **引用在初始化后，不可以改变**

```cpp
int a = 0;
// 引用必须初始化  // 错误写法 int &b；
int &b = a;
// 引用一旦初始化后，就不能更改 // 错误写法 int &b = c;
int c = 20;

b = c;		// 赋值操作，而不是更改引用
// a、b、c 结果都是20
cout << "a=" << a << endl;
cout << "b=" << b << endl;
cout << "c=" << c << endl;
```

## 引用做函数参数

作用：函数传参时，可以利用引用的技术让形参修饰实参

优点：可以简化指针修改实参

```cpp
// 交换函数

// 1、值传递
void mySwap01(int a, int b)
{
    int temp = a;
    a = b;
    b = temp;
}

// 2、地址传递
void mySwap02(int* a, int* b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

// 3、引用传递
void mySwap03(int &a, int &b)
{
    int temp = a;
    a = b;
    b = temp;
}
```

## 引用做函数返回值

注意：`不要返回局部变量引用`；函数的调用可以作为左值存在

```cpp
int& test01()
{
    int a = 10;		// 不要返回局部变量引用
    retrun a;
}

int& test02()
{
    static a = 10;		// 静态变量，存放在全局区，在程序结束后释放
    retrun a;
}

int main()
{
    int& ref = test02();
    cout << ref << endl;	//10
    test02 = 1000;			// 如果函数的返回值是引用，这个函数调用可以作为左值
    cout << ref << endl;	//1000
}
```

## 引用的本质

本质：引用的本质在C++内部实现是一个 **指针常量**。

```cpp
// 发现是引用，转换为 int* const ref = &a;
void func(int& ref)
{
    ref = 100;		// ref是引用，转换为*ref = 100
}

int main()
{
    int a = 10;
    
    // 自动转换为 int*const ref = &a; 指针常量是指针指向不可改，也说明为什么引用不可更改
    int& ref = a;
    ref = 20;		// 内部发现ref是引用，自动帮我们转换为：*ref=20;
    cout << "a:" << a << endl;
    cout << "ref" << ref << endl;
    
    func(a);
    return 0;
}
```

## 常量引用

```cpp
void showValue(const int & val)
{	
    val = 1000;	//不允许修改
    cout << "val" << val << endl;
}

int main()
{
    // 常量使用
    // 使用场景；用来修饰形参，防止误操作
    
    // int a = 10；
    
    // int& ref = 10; 引用本身需要一个合法的内存空间，因此这行错误
    // 加上 const 之后 编码器将代码修改 int temp = 10； const int & ref = temp；
    const int & ref = 10;		// 引用必须引一块合法的内存空间
    //因为 int& ref == int* const p 
    //所以 const int& ref == const int* const p	//p不可变，*p不可变
    
    // 防止误操作
    int v = 10;
    showValue(v);
    
    return 0;
}
```

# 函数提高

## 函数默认参数

在C++中，函数的形参列表是可以有默认值的。

语法：`返回值类型 函数名 （参数=默认值）{}` 

- 注意

1. `默认参数往后的参数都必须有默认值；`

2. `如果函数声明有默认参数，函数实现就不能有默认参数。`

   这种情况编译器没有红线提示，但是的确会报错

   ```cpp
   //默认参数
   int func_DefaultParam_001(int a = 10, int b = 20)
   {
   	return a + b;
   }
   void func_DefaultParam_001t()
   {
   	//如果传入数据就用传入的数据，否则就用默认值
   	cout << func_DefaultParam_001()			<< endl;	//30
   	cout << func_DefaultParam_001(30, 40)	<< endl;	//70
   	cout << func_DefaultParam_001(80)		<< endl;	//100
   }
   //声明和实现
   int func_DefaultParam_002(int a = 10, int b = 20);
   int func_DefaultParam_002(int a, int b)
   {
   	return a + b;
   }
   void func_DefaultParam_002t()
   {	
   	//函数声明中有默认参数，定义就不能有，反之亦然
   	cout << func_DefaultParam_002() << endl;	//30
   	//error C2572: “func_DefaultParam_002”: 重定义默认参数 : 参数 1s
   }
   // error: 重定义默认参数
   // 二异性
   ```

   **`声明和实现只能一个有默认参数！`**

## 函数占位参数

C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置

语法： `返回值类型 函数名（数据类型）{}`

```cpp
void func(int a,int)
{
    cout << "this is func" << endl;
}

// 调用时必须填写占位参数
func(10, 10);

// 占位参数还可以用默认参数
void func(int a, int = 10){...}

func(10);		// 占位参数有默认值时就可以不用传占位参数了
```

占位参数意义不大，但是高级用法中会用到

## 函数重载**

作用：函数名可以相同，提高复用性

**函数重载满足条件：**

- 同一作用域下
- 函数名称相同
- 函数参数 类型不同 或者 个数不同 或者 顺序不同

```cpp
// 最主要的是函数参数 类型不同 或者 个数不同 或者 顺序不同
// 参数类型不同
void func(){...}
void func(int a){...}
void func(double a){...}

// 顺序不同
void func(int a, double b){...}
void func(double a, int b){...}

// 返回值类型不同是不作为函数重载的条件
void func(int a, double b){...}
int func(int a, double b){...}
```

**函数重载注意事项：**

- 引用作为重载条件
- 函数重载碰到函数默认参数

```cpp
// 引用作为重载条件
void func(int &a){...}
void func(const int &a){...}

int a = 10;
func(a);		// 调用第一个，因为 a 可读可写
fucn(10);		// 调用第二个，因为 10 可读不可写
// int& a = 10 是不成立的，因为引用必须指向合法的内存空间
// const int& a = 10	//const int& a 不可读不可写 与 int& a 可以区分开来
// 此时会在内存给a开辟一个可读不可写的空间，所以是合法的

// 函数重载碰到函数默认参数
void func(int a, int b =10){...}
void func(int a){...}
func(10);		// 此时出现了二异性，编译器不知道应该加载哪个函数
// 尽量避免这种情况，写函数重载时不要写默认参数
```

# 类和对象

C++面向对象的三大特性：`封装、继承、多态`

C++认为万事万物皆为对象，对象上有其属性和行为

## 封装

封装的意义：

- 将属性和行为作为一个整体，表现生活中的事物

- 将属性和行为加以权限控制

### 封装

将属性和行为作为一个整体，表现事物

语法：`class 类型{ 访问权限： 属性/行为 };`

```cpp
class 类名
{
    // 访问权限
    // 属性
    // 行为
};
```

示例1：

​	设计一个圆类，求圆的周长

思路：

- 圆周长的公式： 2 * pi * radius
- 因此圆类需要一个 radius 即可

代码：

```cpp
class Circle
{
    // 访问权限
    // 	公共权限
public:
    // 属性
    //	半径
    int m_r:
     
    // 行为
    //	获取圆的周长
    double calculateZC()
    {
        return 2 * 3.14 * m_r;
    }
};

int main()
{
    // 通过圆类 创建具体的圆（对象）
    // 实例化 ： 通过一个类，创建一个对象的过程
    Circle c1;
    // 给圆对象的属性进行赋值
    c1.m_r = 10;
    // 计算周长
    ret = c1.calculateZC();
}
```

示例2：

​	设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号

代码：

```cpp
class Student
{
public:		//权限
	//属性
	string mName;
	int mId;
	//行为
	void showStudent()
	{
		cout << "姓名: " << this->mName << endl;
		cout << "学号: " << this->mId	<< endl;
	}
	//	赋值函数
	void setName(string& name) { this->mName = name; }
	void setId(int id) { this->mId = id; }
};
```

- 注意

  类中的`属性`和`行为` 我们统一称为 `成员`

  - `属性： 成员属性 成员变量`

  - `行为： 成员函数 成员方法`

### 访问权限

访问权限有三种：

- public		公共权限
  - 成员	类内可以访问	类外可以访问
- protected	保护权限
  - 成员	类内可以访问	类外不可以访问
  - 儿子可以访问  保护内容
- private		私有权限
  - 成员	类内可以访问	类外不可以访问
  - 儿子不可以访问  私有内容

### struct 和 class 区别

struct 和 class 的唯一区别在于 `默认的访问权限不同`

区别：

- struct 默认权限为公共
- class 默认权限为私有

### 成员属性设置为私有

优点1：将所有成员属性设置为私有，可以自己控制读写权限

优点2：对于写权限，我们可以检测数据的有效性

```cpp
class PersonPermission01
{
public:
	//写姓名
	//字符串最好不要用引用，直接输入字符串时，无法用引用传参
	void setName(string name) {this->mName = name;}
	//读姓名
	string getName() {return this->mName;}
	//只读年龄
	int getAge() { this->mAge = 18; return this->mAge; }
	//只写爱好
	void setHobby(string hobby) { this->mHobby = hobby; }
private:
	string mName;		//可读可写
	int mAge;			//只读
	string mHobby;		//只写
};
void Class_Permission01()
{
	PersonPermission01 p1;
	p1.setName("张三");
	cout << p1.getName()	<< endl;
	cout << p1.getAge()		<< endl;
	p1.setHobby("coding");
}
```

## 对象的初始化和清理

### 构造函数和析构函数*

对象的初始化和清理也是两个非常重要的安全问题

C++利用 **构造函数** 和 **析构函数** 解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。

对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，

编译器会提供编译器提供的构造函数和析构函数，但是是空实现。

- 构造函数：主要作用于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。
- 析构函数：主要作用于对象 **销毁前** 系统自动调用，执行一些清理工作。

**构造函数语法：** `类名(){}`

1. **构造函数，没有返回值也不写void**
2. 函数名称与类名相同
3. **构造函数可以有参数，因此可以发生重载**
4. 程序在调用对象时候会自动调用构造，无需手动调用，而且只会调用一次

**析构函数语法：** `~类名(){}`

1. **析构函数，没有返回值也不写void**
2. 函数名称与类名相同，在名称前加上`~`
3. **析构函数不可以有参数，因此不可以发生重载**
4. 程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次

- 个人理解

  构造函数会自动调用，与python的`__init__()`很像

  ```cpp
  class PersonJx001
  {
  public:
  	//构造函数
  	PersonJx001()
  	{
  		cout << "构造函数的调用" << endl;
  	}
  	//析构函数
  	~PersonJx001()
  	{
  		cout << "析构函数的调用" << endl;
  	}
  };
  void Class_Jx002()
  {
  	PersonJx001 p1;
  	cout << "this is a pause.." << endl;
  }
  ```

### 构造函数的分类及调用

两种分类方式：

​	按参数分：有参构造和无参构造

​	按类型分：普通构造和拷贝构造

三种调用方式：

​	括号法（推荐）

​	显示法

​	隐式转换法

```cpp
class PersonJx002
{
public:
	//无参构造函数
	PersonJx002()
	{
		cout << "无参构造函数的调用" << endl;
	}
	PersonJx002(int a)
	{
		this->mAge = a;
		cout << "有参构造函数的调用" << endl;
	}

	//拷贝构造函数
	PersonJx002(const PersonJx002& p)
	{
		mAge = p.mAge;
		cout << "拷贝构造函数的调用" << endl;
	}
	
	//析构函数
	~PersonJx002()
	{
		cout << "年龄为 " << mAge << " 的对象被析构" << endl;
	}

	int getAge() { return mAge; }
private:
	int mAge;
};
void Class_Jx003()
{
	//1.括号法
	PersonJx002 p1;		//调用无参构造函数
	cout << p1.getAge() << endl;
	PersonJx002 p2(10);	//调用有参构造函数
	cout << p2.getAge() << endl;

	PersonJx002 p3(p2);	//调用拷贝构造函数
	cout << p3.getAge() << endl;

	//2.显式法
	PersonJx002 p4;		//PersonJx002 p4();	写法错误，会认为是一个函数声明.
	PersonJx002 p5 = PersonJx002(20);
	PersonJx002 p6 = PersonJx002(p5);

	//注意事项
	PersonJx002(30);		// 匿名对象	特点：当前行执行结束后，系统会立即回收掉匿名对象
	cout << "aaa" << endl;		// 测试发现会在 'aaa' 之前进行构造和析构
	// 注意：不要利用拷贝构造函数初始化匿名对象
	// 因为编译器会认为 PersonJx002(p6) 是 PersonJx002 p6；对象重定义
	// PersonJx002(p6);

	//3.隐式转换法
	PersonJx002 p7 = 40;	//有参构造
	PersonJx002 p8 = p7;	//拷贝构造
}
```

### 拷贝构造函数的调用时机

C++ 中拷贝构造函数调用时机

- 使用一个已经创建完毕的对象来初始化一个对象
- 值传递的方式给函数参数传值
- 以值方式返回局部对象

```cpp
class Person
{
public:
    Person(){...}		// 默认构造函数
    Person(int age){...}		//有参构造函数
    Person(const Person& p){...}		// 拷贝构造函数
    ~Person(){...}		// 析构函数
};

// 1.使用一个已经创建完毕的对象来初始化一个对象
void test01()
{
    Person p1(20);
    Person p2(p1);
    // 此时 p2 会调用 拷贝构造函数
    // 最常用的调用时机
}

// 2.值传递的方式给函数参数传值
void doWork(Person px)
{
    
}

void test02()
{
    Person p;
    doWork(p);
    // 在函数 doWork 中，实参传给形参是， Person px = p, 调用拷贝构造函数
}

// 3.以值方式返回局部对象
Person doWork2()
{
    Person p1;
    return p1;  
};

void test03()
{
    Person p = doWork2();		// return p1 时，也会返回一个拷贝对象，因为 p1 是doWork2中的局部变量
}
```

### 构造函数调用规则*

默认情况下，c++编译器至少给一个类添加3个函数

1. 默认构造函数（无参，函数体为空）
2. 默认析构函数（无参，函数体为空）
3. 默认拷贝构造函数，对属性进行值拷贝

构造函数调用规则如下：

- `如果用户定义有参构造函数，c++不再提供 默认无参构造，但是会提供默认拷贝构造`
- `如果用户定义拷贝构造函数，c++不再提供其他构造函数`

```cpp
// 1.创建一个类时，c++编译器会给每个类都添加至少3个函数
// 默认构造（空实现）
// 析构函数（空实现）
// 拷贝函数（值拷贝）
class Person
{
public:
    // 默认构造函数
    Person()
    {
        cout << "Person的默认构造函数调用" << endl;
    }
    Person(int age)		// 有参构造函数
    {
        cout << "Person的有参构造函数调用" << endl;
        m_age = age;
    }
    Person(const Person& p)		// 拷贝构造函数
    {
        cout << "Person的拷贝构造函数调用" << endl;
        m_age = p.m_age;
    }
    ~Person()
    {
        cout << "Person的析构函数调用" << endl;
    }
private:
    int m_age;   
};

// 可以写个test函数来检验一下构造函数调用规则
```

### 深拷贝和浅拷贝

深浅拷贝是面试经典问题，也是个常见的坑。

浅拷贝：简单的赋值拷贝操作

深拷贝：在堆区重新申请空间，进行拷贝操作

- 错误示例

  由于默认的拷贝构造函数是浅拷贝，所以同一空间释放了两次。

```cpp
class PersonJx003
{
public:
	//无参构造函数
	PersonJx003()
	{
		cout << "无参构造函数的调用" << endl;
	}
	//有参构造函数
	PersonJx003(int age, int height)
	{
		this->mAge = age;
		this->mHeight = new int(height);
		cout << "有参构造函数的调用" << endl;
	}
	~PersonJx003()
	{
		if (mHeight)
		{
			delete mHeight;
			mHeight = NULL;
		}
		cout << "析构函数的调用" << endl;
	}
public:
	int mAge;
	int *mHeight;	//将此数据创建到堆区
};
void Class_Jx004()
{
	PersonJx003 p1(18, 160);	//有参构造
	PersonJx003 p2(p1);			//拷贝构造函数，此时属于浅拷贝函数
	cout << "p1的年龄" << p1.mAge << endl;
}
```

![image-20210908111304579](https://i.loli.net/2021/09/08/nFtLzVHIGZh8fmo.png)

- 深拷贝写法

  自己实现拷贝构造函数，解决浅拷贝带来的问题

```cpp
class PersonJx003
{
public:
	//无参构造函数
	PersonJx003()
	{
		cout << "无参构造函数的调用" << endl;
	}
	//有参构造函数
	PersonJx003(int age, int height)
	{
		this->mAge = age;
		this->mHeight = new int(height);
		cout << "有参构造函数的调用" << endl;
	}
	//用深拷贝重写拷贝构造函数	//默认拷贝构造函数是浅拷贝
	PersonJx003(const PersonJx003& p)
	{
		this->mAge = p.mAge;
		this->mHeight = new int(*p.mHeight);
		cout << "拷贝构造函数的调用" << endl;
	}
	~PersonJx003()
	{
		if (mHeight)
		{
			delete mHeight;
			mHeight = NULL;
		}
		cout << "析构函数的调用" << endl;
	}
public:
	int mAge;
	int *mHeight;	//将此数据创建到堆区
};
void Class_Jx004()
{
	PersonJx003 p1(18, 160);	//有参构造
	PersonJx003 p2(p1);			//拷贝构造函数，此时属于浅拷贝函数
	cout << "p1的年龄" << p1.mAge << endl;
}
```

### 初始化列表

**作用：** C++ 提供了初始化列表语法，用来初始化属性

**语法：** `构造函数() :属性1(值1), 属性2(值2) ... {}`

```cpp
class PersonJx004
{
public:
	//传统初始化操作
	/*PersonJx004(int a, int b, int c)
	{
		mA = a;
		mB = b;
		mC = c;
	}*/

	//初始化列表创建无参构造函数
	PersonJx004():mA(10),mB(20),mC(30){}

	//有参构造函数也可以用初始化列表改写
	PersonJx004(int a, int b, int c):mA(a), mB(b), mC(c) {}
public:
	int mA;
	int mB;
	int mC;
};
void Class_Jx005()
{
	PersonJx004 p1;
	cout << p1.mA << "\t" << p1.mB << "\t" << p1.mC << endl;
	PersonJx004 p2(11, 22, 33);
	cout << p2.mA << "\t" << p2.mB << "\t" << p2.mC << endl;
}
```

### 类对象作为类成员

C++ 类中的成员可以是另一类的对象，我们称该成员为 对象成员

例如：

```cpp
class A{};
class B
{
    A a;
};
```

如果B类中有对象A作为成员，A为对象成员

那么创建B对象时，A与B的构造和析构的顺序是谁先谁后？

**示例：**

```cpp
class Phone
{
public:
    Phone(string pName)
    {
        m_pName = pName;
        cout << "Phone构造函数调用" << endl;
    }
    string m_pName;
};
class Person
{
public:
    // Phone m_phone = pName;  // 隐式转换法
    Person(string name,string pName) :m_name(name),m_phone(pName)
    {
        cout << "Person构造函数调用" << endl;
    }
    string m_name;
    Phone m_phone;
};
```

当其他类对象作为本类成员，构造时候先构造其他类对象，再构造自身，析构的顺序相反，类在栈区，先进后出。

### 静态成员

静态成员就是在成员变量和成员函数前加上关键字`static`，称为静态成员。

可以理解为，静态对象属于独立的对象。

静态成员分为：

- 静态成员变量
  - 所有对象共享同一份数据
  - 在编译阶段分配内存
  - 类内声明，类外初始化
- 静态成员函数
  - 所有对象共享一个函数
  - 静态成员函数只能访问静态成员变量

```cpp
class PersonJx005
{
public:
	//静态成员函数
	static void func()
	{
		cout << "静态成员函数的调用" << endl;
		mA = 100;		//静态成员函数可以访问静态成员变量
		//mB = 200;		//静态成员函数不能访问非静态成员变量

	}
	//静态成员变量
	static int mA;
	//非静态成员变量
	int mB;
private:
	//静态成员函数也是有访问权限的
	static void func2()
	{
		cout << "私有的静态成员函数的调用" << endl;
	}
};
//	初始化静态成员变量
int PersonJx005::mA = 0;
void Class_Jx006()
{
	//1.通过对象访问
	PersonJx005 p1;
	p1.func();

	//2.通过类名访问
	PersonJx005::func();
}
```

## C++对象模型和this指针

### 成员变量和成员函数分开存储

在C++中，类内的成员变量和成员函数分开存储

只有非静态成员变量才属于类的对象上

- 空对象

```cpp
class Person
{
};
void test01()
{
    Person p;
    // 空对象占用内存空间为：1
    // C++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置
    // 每个空对象也应该有一个独一无二的内存地址
    cout << "size of p = " << sizeof(p) << endl;
}
```

- 非静态成员

```cpp
class Person
{
    int m_A;        // 非静态成员  // 属于类对象上的
};
void test01()
{
    Person p;
    // 非空对象占用内存空间为：4
    cout << "size of p = " << sizeof(p) << endl;
}
```

- 静态成员

```cpp
class Person
{
    int m_A;        // 非静态成员  // 属于类对象上的
    static int m_B;     // 静态成员     // 不属于类对象上的
};
int Person::m_B = 0;

void test01()
{
    Person p;
    // 类对象占用内存空间为：4
    // 类对象占用空间并没有发生改变
    cout << "size of p = " << sizeof(p) << endl;
}
```

- 成员函数

```cpp
class Person
{
    int m_A;        // 非静态成员  // 属于类对象上
    static int m_B;     // 静态成员     // 不属于类对象上
    void func(){}       // 非静态成员函数  // 不属于类对象上
};
void test01()
{
    Person p;
    // 类对象占用内存空间为：4
    // 成员函数 静态 和 非静态 都不属于类，均是独一无二的存在 
    cout << "size of p = " << sizeof(p) << endl;
}

int Person::m_B = 0;
```

- 总结

只有 非静态成员变量 属于 类对象上

### this 指针概念

上节中了解到 C++ 中成员变量和成员函数是分开存储的

每个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码

那么问题是：这一块代码是如何区分哪个对象调用自己的呢？



C++通过提供特殊的对象指针，this指针，解决上述问题。**this指针指向被调用的成员函数所属的对象**



this指针是隐含每一个非静态成员函数内的一种指针

this指针不需要定义，直接使用即可



this指针的用途：

- 当形参和成员变量同名时，可用this指针来区分
- 在类的非静态成员函数中返回对象本身，可使用 `return *this`

**示例：**

- 解决名称冲突

```cpp
class Person
{
public:
    Person(int age)
    {
        age = age;
    }
    int age;
};
void test01()
{
    Person p1(18);
    // 年龄： - 858993460
    cout << "年龄： " << p1.age << endl;
}
```

此时在类的构造函数中，3个`age`被认为是同一个对象，所以无法产生赋值操作。

解决办法，可以在定义类时，用加前缀的方式命名成员变量，以示区分；或者用this指针来告诉编译器哪个变量才是类的成员变量。

```cpp
// this指针的方式
class Person
{
public:
    Person(int age)
    {
        this->age = age;
    }
    int age;
};
void test01()
{
    Person p1(18);
    // 年龄：18 显示正常
    cout << "年龄： " << p1.age << endl;
}
```

- 返回对象本身

```cpp
class PersonJx006
{
public:
	PersonJx006() {}	//如果用户定义有参构造函数，c++不再提供默认无参构造，但是会提供默认拷贝构造
	PersonJx006(int age)
	{
		this->mAge = age;
	}
	/*无返回值*/
	//void PersonAddAge(PersonJx006& p)
	//{
	//	this->mAge += p.mAge;
	//}
	/*返回对象的引用*/
	PersonJx006& PersonAddAge(PersonJx006& p)
	{
		this->mAge += p.mAge;
		//this指向实例化对象，而*this就是解引用，也就是实例化对象本体
		return *this;
	}
	/*返回对象的拷贝*/
	//PersonJx006 PersonAddAge(PersonJx006& p)
	//	此时返回的时候会创建一个新的对象，注意区分

	int mAge;
};
void Class_Jx007()
{
	PersonJx006 p1(10);
	PersonJx006 p2(18);
	p1.PersonAddAge(p2);	//这样当然是可以的
	cout << p1.mAge << endl;
	//如果想采用链式编程，调用的函数就得返回对象本身
	p1.PersonAddAge(p2).PersonAddAge(p2).PersonAddAge(p2);
	cout << p1.mAge << endl;
}
```

### 空指针访问成员函数

C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针

如果用到this指针，需要加以判断保证代码的健壮性

```cpp
class PersonJx007
{
public:
	void showPersonClass()
	{
		cout << "This is Person class!" << endl;
	}
	void showPersonAge()
	{
		//添加一个判断
		if (this == NULL)
		{
			return;
		}
		cout << "age = " << m_Age << endl;
	}
	int m_Age;
};
void Class_Jx008()
{
	PersonJx007* p = NULL;		//创建一个类的空指针
	p->showPersonClass();		//可以正常调用
	//p->showPersonAge();		//引发了异常: 读取访问权限冲突。
								//**this** 是 nullptr。
	//报错的原因是空指针无法访问属性，因为 this指针为空。
	//在类中添加判断
	p->showPersonAge();			//这样就不会报错了

	//试试空对象
	PersonJx007 p1;
	//空对象均可以正常调用
	p1.showPersonClass();
	p1.showPersonAge();
}
// erro: this 是 nullptr。
// 但是成功执行了`showPersonClass`函数
// 如果只调用`showPersonClass`函数发现是没有报错的
// 但是只调用`showPersonAge`函数还是会报错
// 区别在于`showPersonAge`函数调用了`m_Age`
// 在类中 ：` cout << "age = " << m_Age << endl;`
//		相当于：` cout << "age = " << this->m_Age << endl;`
// 空指针是没有对象实例化的，因此是没法访问到对象里面的属性。
// 简单来说，你连对象都没有，还要问你对象的年龄？
```

因此为了防止报错，需要将代码做一个判断

```cpp
void showPersonAge()
{
    if (this == NULL)
    {
        return;
    }
    cout << "age = " << this->m_Age << endl;
}
```

### const 修饰成员函数

**常函数：**

- 成员函数后加const后我们称为这个函数为 **常函数**
- 常函数内不可以修改成员属性
- 成员属性声明时加关键字`mutable`后，在常函数中依然可以修改

**常对象：**

- 声明对象前加const称该对象对常对象
- 常对象只能调用常函数

**示例：**

```cpp
class PersonJx008
{
public:
	//在成员函数后面加 const，修饰的是this指针，
	//	this指针的本质 是指针常量 指针指向不可以修改	
	void showPerson() const
	{
		//此时指针指向的值也不可以修改
		//this->m_A = 100;

		//mutable 变量在常函数中也可以修改
		m_B = 20;
		cout << "常函数的调用" << endl;
	}

	void func(){}

	int m_A;
	//如果想要在常函数中也可以修改，在变量前加 mutable
	mutable int m_B;
};
void Class_Jx009()
{
	const PersonJx008 p;	//在对象前加const，变为常对象
	//p.m_A = 100;			//常对象不能修改普通的成员变量
	p.m_B = 18;				//但是常对象可以修改 mutable 成员变量
	p.showPerson();			//常对象只能调用常函数
	cout << p.m_B << endl;
	//p.func()				//error:对象含有不兼容的类型限定符	
}
```

## 友元

在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术

友元的目的就是让一个函数或一个类 访问另一个类中私有成员

关键字：`friend`

友元的三种实现

- 全局函数做友元
- 类做友元
- 成员函数做友元

```cpp
/*友元*/
//全局函数做友元
class BuildJx001;
class ClassGoodGay001;
class BuildJx001
{
	//GoodGay全局函数用friend声明	//甚至不用特意写在public作用域下
	friend void func_GoodGay(BuildJx001* build);
	//GoodGay类也是同样的方式声明
	friend class ClassGoodGay;
	//类的成员函数单独声明	//TODO：声明前后顺序并没有讲清，单纯这样写还是会报错
	//friend void ClassGoodGay001::visit();
public:
	BuildJx001();

public:
	string m_LivingRoom;		//客厅
private:
	string m_BedRoom;			//卧室
};
BuildJx001::BuildJx001()
{
	m_LivingRoom = "客厅";
	m_BedRoom = "卧室";
}
//	全局函数
void func_GoodGay(BuildJx001* build)
{
	cout << "全局函数正在访问： " << build->m_LivingRoom << endl;
	//cout << "全局函数正在访问： " << build->m_BedRoom << endl;	//私有属性不可访问

	//在类中用friend声明全局函数后即可访问类中私有变量
	cout << "全局函数正在访问： " << build->m_BedRoom << endl;
}
void Class_Jx010()
{
	BuildJx001 build;
	func_GoodGay(&build);
}
//类做友元
class ClassGoodGay
{
public:
	ClassGoodGay();
public:

	void visit();	//访问 BuildJx001 类中的属性

	BuildJx001* build;
};
ClassGoodGay::ClassGoodGay()
{
	//创建一个对象
	build = new BuildJx001;		//new对象返回指针
}
void ClassGoodGay::visit()
{
	cout << "好基友类正在访问： " << build->m_LivingRoom << endl;
	cout << "好基友类正在访问： " << build->m_BedRoom << endl;
}
//	test
void Class_Jx011()
{
	ClassGoodGay gp;		//创建一个类
	gp.visit();
}
//成员函数做友元
class ClassGoodGay001
{
public:
	ClassGoodGay001();
	void visit();		//	让visit函数可以访问私有成员
	void visit2();		//	让visit2函数不可以访问私有成员

private:
	BuildJx001* build;

};
ClassGoodGay001::ClassGoodGay001()
{  
	build = new BuildJx001;
}
void ClassGoodGay001::visit()
{
	cout << "好基友类正在访问： " << build->m_LivingRoom << endl;
	//cout << "好基友类正在访问： " << build->m_BedRoom << endl;
}
void ClassGoodGay001::visit2()
{
	cout << "好基友类正在访问： " << build->m_LivingRoom << endl;
	//cout << "好基友类正在访问： " << build->m_BedRoom << endl;	//visit2不可访问
}
//	test
//void Class_Jx012()
//{
//	ClassGoodGay001 gp;
//	gp.visit();
//}
```

## 运算符重载*

对于内置数据类型，编译器知道如何进行运算

为了规范，编译器为运算符重载都统一起名

### 加号运算符重载

`operator+`

```cpp
//加号运算符重载
class PersonJx009
{
public:
	PersonJx009& operator+(PersonJx009& p)
	{
		PersonJx009 temp;
		temp.mA = p.mA + this->mA;
		temp.mB = p.mB + this->mB;
		return temp;
	}
public:
	int mA;
	int mB;
private:
};
//	成员函数重载
void Class_Operator001()
{
	PersonJx009 p1;
	p1.mA = 10;
	p1.mB = 100;
	PersonJx009 p2;
	p2.mA = 20;
	p2.mB = 200;
	PersonJx009 p3;
	p3 = p1 + p2;		//重载运算符+
	cout << p3.mA << " " << p3.mB << endl;
}
//	全局函数重载
class PersonJx010
{
public:
	int mA;
	int mB;
private:
};
PersonJx010& operator+(PersonJx010& p1, PersonJx010& p2)
{
	PersonJx010 temp;
	temp.mA = p1.mA + p2.mA;
	temp.mB = p1.mB + p2.mB;
	return temp;
}
void Class_Operator002()
{
	PersonJx010 p1;
	p1.mA = 10;
	p1.mB = 100;
	PersonJx010 p2;
	p2.mA = 20;
	p2.mB = 200;
	PersonJx010 p3;
	p3 = p1 + p2;		//重载运算符+
	cout << p3.mA << " " << p3.mB << endl;
}
```

- 总结

  对于内置的数据类型的表达式的运算符是不可以改变的

  不要滥用运算符重载

### 左移运算符重载*

```cpp
//左移运算符重载
class PersonJx011
{
	//利用全局函数做友元访问私有属性
	friend ostream& operator<<(ostream& cout, PersonJx011& p);
public:
	PersonJx011(int a, int b);

	//通常不会利用成员函数重载 左移运算符， 因为无法实现 cout 在左侧
	//void operator<< (PersonJx011& p);
private:
	int mA;
	int mB;
};
PersonJx011::PersonJx011(int a, int b)
{
	this->mA = a;
	this->mB = b;
}
//	只能利用全局函数重载左移运算符
ostream& operator<<(ostream& cout, PersonJx011& p)
{
	cout << p.mA << " " << p.mB << endl;
	//还需注意链式编程思想
	return cout;
}
void Class_Operator003()
{
	PersonJx011 p(10, 20);
	cout << p << endl;
}
```

> 总结：重载左移运算符配合友元可以实现输出自定义数据类型

### 递增运算符重载

```cpp
class MyInteger
{
public:
	MyInteger();
	~MyInteger();
	int getNum();

	//重载前置++运算符	//返回值的话重复调用就会出现问题
	MyInteger& operator++()
	{
		mNum++;
		return *this;
	}
	//重载后置++运算符	//int代表占位参数，可以用于区分前置和后置递增，只认int！
	MyInteger operator++(int)
	{
		//先 记录当时结果
		MyInteger temp = *this;
		//后 递增
		mNum++;
		//返回的是局部对象，因此不能返回引用
		return temp;
	}
private:
	int mNum;
};

MyInteger::MyInteger()
{
	this->mNum = 0;
}

MyInteger::~MyInteger()
{
}
int MyInteger::getNum()
{
	return this->mNum;
}
//	重载左移运算符打印输出
ostream& operator<<(ostream& cout, MyInteger myint)
{
	cout << myint.getNum();
	return cout;
}
void Class_Operator004()
{
	MyInteger myint;
	cout << ++myint << endl;
	MyInteger myint2;
	cout << myint2++ << endl;
}
```

C++无法实现连续后置调用

### 赋值运算符重载

C++编译器至少给一个类添加4个函数

1. 默认构造函数（无参，函数体为空）

2. 默认析构函数（无参，函数体为空）
3. 默认拷贝构造函数，对属性进行值拷贝
4. 赋值运算符 operator=，对属性进行值拷贝

如果类中有属性指向堆区，做赋值操作时，也会出现深浅拷贝问题。

```cpp
//赋值运算符重载
class PersonJx012
{
public:
	PersonJx012(int age);
	~PersonJx012();

	//浅拷贝会重复释放堆区内存
	PersonJx012& operator=(PersonJx012& p);

	int* getAge();
private:
	int* mAge;
};
PersonJx012::PersonJx012(int age)
{
	mAge = new int(age);
}
PersonJx012::~PersonJx012()
{
	if (mAge!=NULL)
	{
		delete mAge;
		mAge = NULL;
	}
}
//	还要考虑链式编程
//void PersonJx012::operator=(PersonJx012& p)
PersonJx012& PersonJx012::operator=(PersonJx012& p)
{
	/*编译器提供的浅拷贝*/
	//mAge = p.mAge;

	/*为了避免堆区重复释放，应该对赋值运算操作符进行重载*/
	//先判断是否有属性在堆区，如果有先释放干净
	if (mAge!=NULL)
	{
		delete mAge;
		mAge = NULL;
	}
	//然后进行深拷贝
	this->mAge = new int(*p.getAge());
	return *this;
}
int* PersonJx012::getAge() { return mAge; }
void Class_Operator005()
{
	PersonJx012 p1(18);
	PersonJx012 p2(20);

	p2 = p1;	//赋值操作

	cout << *p1.getAge() << endl;
	cout << *p2.getAge() << endl;
}
```

### 关系运算符重载

```cpp
//关系运算符重载
class PersonJx013
{
public:
	PersonJx013(string name, int age);

	bool operator==(PersonJx013& p);
	bool operator!=(PersonJx013& p);

	string getName() { return mName; }
	int getAge() { return mAge; }
private:
	string mName;
	int mAge;
};
PersonJx013::PersonJx013(string name, int age)
{
	mName = name;
	mAge = age;
}
bool PersonJx013::operator==(PersonJx013& p)
{
	if (mName == p.getName() && mAge == p.getAge())
	{
		return true;
	}
	return false;
}
bool PersonJx013::operator!=(PersonJx013& p)
{
	if (mName == p.getName() && mAge == p.getAge())
	{
		return false;
	}
	return true;
}

void Class_Operator006()
{
	PersonJx013 p1("zhangsan", 18);
	PersonJx013 p2("zhangsan", 18);
	if (p1==p2)
	{
		cout << "p1和p2是相等的" << endl;
	}
	else { cout << "p1和p2是不相等的" << endl; }
}
```

### 函数调用运算符重载

- 函数调用运算符()也可以重载
- 由于重载后使用的方式非常像函数的调用，因此称为仿函数
- 仿函数没有固定写法，非常灵活

```cpp
//函数调用运算符重载
class MyPrint
{
public:
	//由于使用起来很像函数的调用，因此被称为仿函数
	void operator()(string test);

private:

};
void MyPrint::operator()(string test)
{
	cout << test << endl;
}
void Class_Operator007()
{
	MyPrint p;
	p("hello world");

	//匿名对象写法
	MyPrint()("匿名对象方式调用");
}
```

## 继承

**继承是面向对象三大特性之一**

我们发现，定义一些存在特殊关系的类时，下级别的成员除了拥有上一级的共性，还有自己的特性

这时就可以考虑利用继承的技术，减少重复代码

### 继承的基本语法

语法：`class 子类 : 继承方式 父类`

子类 也称为 派生类

父类 也称为 基类

```cpp
//继承的基本语法
/*	继承实现页面 */
class BasePage
{
public:
	void header()
	{
		cout << "首页、公开课、登陆、注册...(公共头部)" << endl;
	}
	void footer()
	{
		cout << "帮助中心、交流合作...(公共底部)" << endl;
	}
	void left()
	{
		cout << "Java、Python、C++...（公共列表）" << endl;
	}
};
class WebJava : public BasePage
{
public:
	void content()
	{
		cout << "Java学科视频" << endl;
	}
};
class WebPython : public BasePage
{
public:
	void content()
	{
		cout << "Python学科视频" << endl;
	}
};
class WebCpp : public BasePage
{
public:
	void content()
	{
		cout << "Cpp学科视频" << endl;
	}
};
void Class_successor()
{
	cout << "这是Java页面" << endl;
	WebJava webjava;
	webjava.header();
	webjava.footer();
	webjava.left();
	webjava.content();
	cout << "\n这是Python页面" << endl;
	WebPython webpy;
	webpy.header();
	webpy.footer();
	webpy.left();
	webpy.content();
	cout << "\n这是Cpp页面" << endl;
	WebCpp webcpp;
	webcpp.header();
	webcpp.footer();
	webcpp.left();
	webcpp.content();
}
```

**总结**

派生类中的成员，包含两大部分：

- 一类是从基类继承过来的
- 一类是自己增加的成员

从基类继承过来的表现其共性，而新增的成员体现了其个性。

### 继承方式

继承方式一共有三种：

- 公共继承
- 保护继承
- 私有继承

![image-20210913215619226](https://i.loli.net/2021/09/13/BuqgY4PF3KOT1zH.png)

总结：

可以理解为继承方式的选择是权限提升的过程。

### 继承中的对象模型

**问题：** 从父类继承过来的成员，哪些属于子类对象？

```cpp
//继承中的对象模型
class BaseTest
{
public:
	int m_public_A;
protected:
	int m_protected_B;
private:
	int m_private_C;	//私有属性只是被隐藏了，但还是会继承下去
};
class SonTest : public BaseTest
{
public:
	int m_D;
};
void Class_successor001()
{
	cout << sizeof(SonTest) << endl;		//16
}
```

**总结：** 其实都属于子类对象，但是被编译器隐藏了无法访问

### 继承中构造和析构顺序

子类继承父类后，当创建子类对象，也会调用父类的构造函数

问题：父类和子类的构造和析构顺序谁先谁后？

`父构造 子构造 子析构 父析构`

```cpp
class BaseTest001
{
public:
	BaseTest001();
	~BaseTest001();
public:
	int m_public_A;
protected:
	int m_protected_B;
private:
	int m_private_C;	//私有属性只是被隐藏了，但还是会继承下去
};
BaseTest001::BaseTest001()
{
	cout << "父类的构造函数调用" << endl;
}
BaseTest001::~BaseTest001()
{
	cout << "父类的析构函数调用" << endl;
}
class SonTest001 : public BaseTest001
{
public:
	SonTest001();
	~SonTest001();
public:
	int m_D;
};
SonTest001::SonTest001()
{
	cout << "子类的构造函数调用" << endl;
}
SonTest001::~SonTest001()
{
	cout << "子类的析构函数调用" << endl;
}
void Class_successor002()
{
	SonTest001 son;
	//父构造 子构造 子析构 父析构
}
```

### 继承同名成员处理方式

问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中的同名成员呢？

- 访问子类同名成员 直接访问即可
- 访问父类同名成员 需要加作用域

```cpp
//继承同名成员处理方式
class BaseTest002
{
public:
	BaseTest002();
public:
	int getA();
public:
	void func();
	void func(int a);
private:
	int mA;
};
BaseTest002::BaseTest002() { mA = 30; }
int BaseTest002::getA() { return mA; }
void BaseTest002::func()
{
	cout << "父类同名成员函数的调用" << endl;
}
void BaseTest002::func(int a)
{
	cout << "父类有参的同名成员函数调用" << endl;
}
class SonTest002 : public BaseTest002
{
public:
	SonTest002();
public:
	int getA();
public:
	void func();
private:
	int mA;
};
SonTest002::SonTest002() { mA = 18; }
int SonTest002::getA() { return mA; }
void SonTest002::func()
{
	cout << "子类同名成员函数的调用" << endl;
}
void Class_successor003()
{
	SonTest002 son;
	cout << son.getA() << endl;						//子类同名成员直接访问即可
	cout << son.BaseTest002::getA() << endl;		//父类同名成员加后缀即可访问

	//如果子类中出现和父类同名的成员函数，子类的同名成员会隐藏掉父类的所有同名成员函数
	son.func();					//cout:子类同名成员函数的调用
	//son.func(1);				//error C2660: “SonTest002::func”: 函数不接受 1 个参数
	son.BaseTest002::func(1);	//cout:父类有参的同名成员函数调用
}
```

**总结：**

1. 子类对象可以直接访问到子类中同名成员
2. 子类对象加作用域可以访问到父类同名成员
3. 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名成员函数

### 继承同名静态成员处理方式

问题：继承中同名的静态成员在子类对象上如何进行访问？

静态成员和非静态成员出现同名，处理方式一致

- 访问子类同名成员 直接访问即可
- 访问父类同名成员 需要加作用域

### 多继承语法

C++允许一个类继承多个类

语法：`class 子类 : 继承方式 父类1, 继承方式 父类2...`

多继承可能会引发父类中有同名成员出现，需要加作用域区分

**C++实际开发中不建议使用多继承**

### 菱形继承

- 菱形继承概念：

两个派生类继承同一个基类

又有某个类同时继承这两个派生类

这种继承被称为菱形继承，或者钻石继承

- 典型的菱形继承案例：

![image-20210915160420261](https://i.loli.net/2021/09/15/XAlhv3BoY8FH7R4.png)

-  菱形继承

1. 羊继承了动物的数据，驼同样继承了动物的数据，当羊驼使用数据时，就会产生二义性。
2. 羊驼继承自动物的数据继承了两份，其实只需要一份即可。

- 虚基类指针(vbptr)

  v : virtual

  b : base

  ptr : pointer

![image-20210923113803224](https://i.loli.net/2021/09/23/lHzdUIERhj8oFtD.png)

```cpp
//菱形继承 or 砖石继承
class Animal
{
public:
	int mAge;
};
class Sheep :public Animal
{
};
class Tuo :public Animal
{
};
class SheepTuo :public Sheep, public Tuo
{
};
void Class_successor004()
{
	SheepTuo st;
	st.Sheep::mAge = 18;
	st.Tuo::mAge = 28;
	//当菱形继承，两个父类拥有相同数据，需要加以作用域区分
	cout << "st.Sheep::mAge = " << st.Sheep::mAge << endl;
	cout << "st.Tuo::mAge = " << st.Tuo::mAge << endl;
	//这份数据我们知道，只需要有一份即可，菱形继承导致数据有两份，资源浪费
}
//	虚继承 解决菱形继承导致的资源浪费
class Animal001
{
public:
	int mAge;
};
//	Animal类被称为虚基类
class Sheep001 :virtual public Animal001
{
};
class Tuo001 :virtual public Animal001
{
};
class SheepTuo001 :public Sheep001, public Tuo001
{
};
void Class_successor005()
{
	SheepTuo001 st;
	st.Sheep001::mAge = 18;
	st.Tuo001::mAge = 28;
	//当菱形继承，两个父类拥有相同数据，需要加以作用域区分
	cout << "st.Sheep::mAge = " << st.Sheep001::mAge << endl;
	cout << "st.Tuo::mAge = " << st.Tuo001::mAge << endl;
	//这份数据我们知道，只需要有一份即可，菱形继承导致数据有两份，资源浪费
	
	//虚继承后的同名数据就为同一份数据
	cout << "st.mAge = " << st.mAge << endl;
	//此时两个父类的内容都是(vbptr -- 虚基类指针)
}
```

# 多态

## 多态基本概念

**多态是C++面向对象三大特性之一**

多态分为两种

- 静态多态：函数重载 和 运算符重载属于静态多态，复用函数名
- 动态多态：派生类和虚函数实现运行时多态

静态多态和动态多态区别：

- 静态多态的函数地址早绑定 - 编辑阶段确定函数地址
- 动态多态的函数地址晚绑定 - 运行阶段确定函数地址

```cpp
class Animal002
{
public:
	//speak函数就是虚函数
	//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了
	virtual void speak();
};
void Animal002::speak()
{
	cout << "动物在说话" << endl;
}
class Cat002 : public Animal002
{
public:
	void speak();

};
void Cat002::speak()
{
	//重写 函数返回值类型 函数名 参数列表 完全相同
	cout << "小猫在说话" << endl;
}
//地址早绑定 在编译阶段确定函数地址
//如果想执行让猫说话，那么这个函数地址就不能提前绑定，需要在运行阶段进行绑定，地址晚绑定
void doSpeak(Animal002& animal)
{
	animal.speak();
}
//动态多态满足条件
//1. 有继承关系
//2. 子类要重写父类中的虚函数
//动态多态使用
//父类指针或引用指向子类对象
void Class_Polymorphism()
{
	Cat002 cat;
	//C++默认允许父与子类间类型转换
	doSpeak(cat);
}
```

## 多态案例一：计算器类

案例描述：

分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类

多态的有点：

- 代码组织结构清晰
- 可读性强
- 利于前期和后期的扩展以及维护

```cpp
/*多态案例一：计算器类*/
//	普通写法
class Calculator
{
public:
	int getResult(string oper);
	
	int num1;
	int num2;
};
int Calculator::getResult(string oper)
{
	if (oper == "+")
	{
		return num1 + num2;
	}
	else if (oper == "-")
	{
		return num1 - num2;
	}
	else if (oper == "*")
	{
		return num1 * num2;
	}
	//如果想扩展新的功能，需要修改源码
	//在真实开发中 提倡 开闭原则
	//开闭原则：对扩展进行开放，对修改进行关闭
}
void Class_Polymorphism002()
{
	Calculator c;
	c.num1 = 20;
	c.num2 = 10;
	cout << c.num1 << " + " << c.num2 << " = " << c.getResult("+") << endl;
	cout << c.num1 << " - " << c.num2 << " = " << c.getResult("-") << endl;
	cout << c.num1 << " * " << c.num2 << " = " << c.getResult("*") << endl;
}
//	多态写法
/*多态好处
* 1.组织结构非常清晰
* 2.可读性强
* 3.对于前期和后期扩展以及维护性高
*/
//		实现计算器抽象类
class AbstractCalculator
{
public:
	virtual int getResult() { return 0; }
	int num1;
	int num2;
};
//		加法计算器类
class AddCalculator :public AbstractCalculator
{
public:
	int getResult()
	{
		return num1 + num2;
	}
};
//		减法计算器类
class SubCalculator :public AbstractCalculator
{
public:
	int getResult()
	{
		return num1 - num2;
	}
};
class MulCalculator :public AbstractCalculator
{
public:
	int getResult() { return num1 * num2; }
};
void Class_Polymorphism003()
{
	//多态使用条件
	//父类指针或引用指向子类对象
	AbstractCalculator* abc = new AddCalculator;
	abc->num1 = 20;
	abc->num2 = 10;
	cout << abc->num1 << " + " << abc->num2 << " = " << abc->getResult() << endl;
	//用完后手动销毁
	delete abc;

	//减法运算
	abc = new SubCalculator;
	abc->num1 = 20;
	abc->num2 = 10;
	cout << abc->num1 << " - " << abc->num2 << " = " << abc->getResult() << endl;
	//用完后手动销毁
	delete abc;
}
```

## 纯虚函数和抽象类

在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的代码

因此可以将虚函数改为 **纯虚函数**

纯虚函数语法：`virtual 返回值类型 函数名 (参数列表) = 0;`

当类中有了纯虚函数，这个类也称为`抽象类`

**抽象类特点：**

- 无法实例化对象
- 子类必须重写抽象类中的纯虚函数，否则也属于抽象类

```cpp
//纯虚函数和抽象类
class Abstract
{
	//纯虚函数
	//只要有一个纯虚函数，这个类称为抽象类
	//抽象类特点：
	//1.无法实例化对象
	//2.抽象类的子类，必须要重写父类中的纯虚函数，否则也属于抽象类
	virtual void func() = 0;
};
```

## 多态案例二：制作饮品

案例描述：

制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料



利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶

```cpp
//多态案例二：制作饮品
class AbstractDrinking
{
public:
	//煮水
	virtual void Boil() { cout << "煮矿泉水" << endl; }
	//冲泡
	virtual void Brew() = 0;
	//倒入杯中
	virtual void PourInCup() = 0;
	//加入辅料
	virtual void PutSomething() = 0;
	//制作饮品
	void makeDrink()
	{
		Boil();
		Brew();
		PourInCup();
		PutSomething();
	}
};
class Coffee :public AbstractDrinking
{	
public:
	//冲泡
	virtual void Brew()
	{
		cout << "冲泡咖啡" << endl;
	}
	//倒入杯中
	virtual void PourInCup()
	{
		cout << "倒入杯中" << endl;
	}
	//加入辅料
	virtual void PutSomething()
	{
		cout << "加入糖和牛奶" << endl;
	}
};
class Tea :public AbstractDrinking
{
public:
	//冲泡
	virtual void Brew()
	{
		cout << "冲泡茶叶" << endl;
	}
	//倒入杯中
	virtual void PourInCup()
	{
		cout << "倒入杯中" << endl;
	}
	//加入辅料
	virtual void PutSomething()
	{
		cout << "加入枸杞" << endl;
	}
};
void doWork(AbstractDrinking* abs)
{
	abs->makeDrink();
	delete abs;
}
void Class_Polymorphism004()
{
	doWork(new Coffee);
	cout << "----" << endl;
	doWork(new Tea);
}
```

## 虚析构和纯虚析构

多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码

解决方式：将父类中的析构函数改为 **虚析构** 或者 **纯虚析构**

虚析构和纯虚析构共性：

- 可以解决父类指针释放子类对象
- 都需要有具体的函数实现

虚析构和纯虚析构区别：

- 如果是纯虚析构，该类属于抽象类，无法实例化对象

虚析构语法：

`virtual ~类名(){}`

纯虚析构语法：

`virtual ~类名() = 0;`

`类名::~类名(){}`

```cpp
class Animal003
{
public:
	Animal003(){ cout << "Animal的构造函数调用" << endl; }
	virtual ~Animal003(){ cout << "Animal的析构函数调用" << endl; }
	//纯虚函数
	virtual void speak() = 0;
};
class Cat003 :public Animal003
{
public:
	Cat003(string name)
	{
		cout << "Cat的构造函数调用" << endl;
		this->name = new string(name);
	}
	~Cat003()
	{
		if (name != NULL)
		{
			cout << "Cat的析构函数调用" << endl;
			delete name;
			name = NULL;
		}
	}
	virtual void speak()
	{
		cout << *name << "小猫在说话" << endl;
	}
	string* name;	//创建在堆区
};
void Class_Polymorphism005()
{
	Animal003* animal = new Cat003("Tom");
	animal->speak();
	//父类指针在析构时候 不会调用子类中析构函数，导致子类如果有堆区属性，出现内存泄漏
	//因此要采用虚析构来解决 父类指针释放子类对象时不干净的问题
	delete animal;
}
```

**总结**

1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象
2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构
3. 拥有纯虚析构函数的类也属于抽象类

### 多态案例三：电脑组装

**案例描述：**

电脑主要组成部件为CPU（用于计算），显卡（用于显示），内存条（用于存储）

将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商

创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口

测试时组装三台不同的电脑进行工作

```cpp
//多态案例三：电脑组装
class CPU
{
public:
	//抽象的计算函数
	virtual void calculate() = 0;
};
class VideoCard
{
public:
	//抽象的显示函数
	virtual void display() = 0;
};
class Memory
{
public:
	//抽象的存储函数
	virtual void storage() = 0;
};
class Computer
{
public:
	Computer(CPU* cpu, VideoCard* vc, Memory* mem)
	{
		m_cpu = cpu;
		m_vc = vc;
		m_mem = mem;
	}
	~Computer()
	{
		if (m_cpu != NULL)
		{
			delete m_cpu;
			m_cpu = NULL;
		}
		if (m_vc != NULL)
		{
			delete m_vc;
			m_vc = NULL;
		}
		if (m_mem != NULL)
		{
			delete m_mem;
			m_mem = NULL;
		}
	}
	//提供工作的函数
	void work()
	{
		//让零件工作起来
		m_cpu->calculate();
		m_vc->display();
		m_mem->storage();
	}
private:
	//构造函数中传入三个零件指针
	CPU* m_cpu;		//CPU的零件指针
	VideoCard* m_vc;	//显卡零件指针
	Memory* m_mem;	//内存条零件指针

};
class IntelCpu :public CPU
{
public:
	//Intel厂商提供
	virtual void calculate()
	{
		cout << "Intel的CPU开始计算了." << endl;
	}
};
class IntelVideoCard :public VideoCard
{
public:
	//Intel厂商提供
	virtual void display()
	{
		cout << "Intel的VideoCard开始显示了." << endl;
	}
};
class IntelMemory :public Memory
{
public:
	//Intel厂商提供
	virtual void storage()
	{
		cout << "Intel的Memory开始存储了." << endl;
	}
};
class LenovoCpu :public CPU
{
public:
	//Lenovo厂商提供
	virtual void calculate()
	{
		cout << "Lenovo的CPU开始计算了." << endl;
	}
};
class LenovoVideoCard :public VideoCard
{
public:
	//Lenovo厂商提供
	virtual void display()
	{
		cout << "Lenovo的VideoCard开始显示了." << endl;
	}
};
class LenovoMemory :public Memory
{
public:
	//Lenovo厂商提供
	virtual void storage()
	{
		cout << "Lenovo的Memory开始存储了." << endl;
	}
};
void Class_Polymorphism006()
{
	//第一台电脑零件
	CPU* intelCpu = new IntelCpu;
	VideoCard* intelCard = new IntelVideoCard;
	Memory* intelMem = new IntelMemory;

	//创建第一台电脑
	Computer* computer1 = new Computer(intelCpu, intelCard, intelMem);
	computer1->work();
	delete computer1;

	//第二台电脑零件
	CPU* lenovoCpu = new LenovoCpu;
	VideoCard* lenovoCard = new LenovoVideoCard;
	Memory* lenovoMem = new LenovoMemory;

	//创建第二台电脑
	Computer* computer2 = new Computer(lenovoCpu, lenovoCard, lenovoMem);
	computer2->work();
	delete computer2;
}
```



# 文件操作

C++对文件操作需要包含头文件`<fstream>`

文件类型分为两种：

1. **文本文件** - 文件以文本的ASCII码形式存储在计算机中
2. **二进制文件** - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们

操作文件的三大类：

1. `ofstream` ： 写操作
2. `ifstream` ： 读操作
3. `fstream` ： 读写操作

## 文本文件

### 写文件

- 写文件步骤如下：

1. 包含头文件

   `#include<fstream>`

2. 创建流对象

   `ofstream ofs;`

3. 打开文件

   `ofs.open("文件路径",打开方式);`

4. 写数据

   `ofs << "写入的数据";`

5. 关闭文件

   `ofs.close();`

- 打开方式：

| **打开方式** | **解释**                   |
| :----------- | :------------------------- |
| ios::in      | 为读文件而打开文件         |
| ios::out     | 为写文件而打开文件         |
| ios::ate     | 初始位置：文件尾           |
| ios::app     | 追加方式写文件             |
| ios::trunc   | 如果文件存在先删除，再创建 |
| ios::binary  | 二进制方式                 |

注意：文件打开方式可以配合使用，利用`|`操作符

例如：用二进制方式写文件 `ios::binary | ios::out`

```cpp
#include <iostream>
using namespace std;
#include <fstream>	//头文件包含

//文本文件 写文件
void Jx_IOStream_001()
{
	//1.包含头文件 fstream
	//2.创建流对象
	ofstream ofs;
	//3.指定打开方式
	ofs.open("test.txt", ios::out);		//没写权限好像也不会有啥问题
	//4.写内容
	ofs << "姓名：张三" << endl;
	ofs << "姓名：李四" << endl;
	ofs << "姓名：王五" << endl;
	//5.关闭文件
	ofs.close();
}
```

总结：

- 文件操作必须包含头文件 `fstream`
- 读文件可以利用 `ofstream`，或者 `fstream` 类
- 打开文件时候需要指定操作文件的路径，以及打开方式
- 利用 `<<` 可以向文件中写数据
- 操作完毕，要关闭文件

### 读文件

- 写文件步骤如下：

1. 包含头文件

   `#include<fstream>`

2. 创建流对象

   `ifstream ifs;`

3. 打开文件

   `ifs.open("文件路径",打开方式);`

4. 读数据

   四种方式读取

5. 关闭文件

   `ifs.close();`

```cpp
// 判断文件是否打开成功
if (!ifs.is_open())
{
    cout << "文件打开失败" << endl;
    return;
}
```

- 四种读数据的方式

```cpp
void Jx_IOStream_002()
{
	//1.包含头文件 fstream
	//2.创建流对象
	ifstream ifs;
	//3.打开文件 并且判断是否打开成功
	ifs.open("test.txt", ios::in);

	if (!ifs.is_open()) { cout << "文件打开失败" << endl; return; }
	//4.读数据
	/*第一种*/
	//char buf[1024] = { 0 };
	//while (ifs >> buf)
	//{
	//	cout << buf << endl;
	//}
	/*第二种*/
	/*char buf[1024] = { 0 };
	while (ifs.getline(buf,sizeof(buf)))
	{
		cout << buf << endl;
	}*/
	/*第三种*/
	/*string buf;
	while (getline(ifs,buf))
	{
		cout << buf << endl;
	}*/
	/*第四种*/
	//不推荐
	char c;
	while ( (c = ifs.get()) != EOF )	// EOF
	{
		cout << c;
	}
	//5.关闭文件
	ifs.close();
}
```

总结：

- 读文件可以利用 `ifstream`，或者 `fstream`类
- 利用 `is_open`  函数可以判断文件是否打开成功
- close 关闭文件

## 二进制文件

以二进制的方式对文件进行读写操作

打开方式要指定为 `ios::binary`

### 写文件

二进制方式写文件主要利用流对象调用成员函数`write`

函数原型： `ostream& write(const char* buffer, int len);`

参数解释：字符指针`buffer`指向内存中一段存储空间。`len`是读写的字节数

```cpp
class Person
{
public:
	char m_Name[64];	//姓名
	int m_Age;			//年龄
};
void Jx_IOStream_003()
{
	ofstream ofs;
	ofs.open("Person.txt", ios::out | ios::binary);
	Person p = { "张三",18 };
	ofs.write( (const char *)&p, sizeof(p));
	ofs.close();
}
```

### 读文件

二进制方式读文件主要利用流对象调用成员函数`read`

函数原型：`istream& read(char *buffer, int len);`

参数解释：字符指针buffer指向内存中一段存储空间，len是读写的字节数

```cpp
void Jx_IOStream_004()
{
	ifstream ifs;
	ifs.open("Person.txt", ios::in | ios::binary);
	if (!ifs.is_open()) { cout << "文件打开失败" << endl; return; }
	Person p;
	ifs.read((char*)&p, sizeof(p));
	ifs.close();
	cout << p.m_Name << endl;
	cout << p.m_Age << endl;
}
```

# C++提高编程 +++++++

- 本章主要针对C++ `泛型编程` 和 `STL` 技术做详细讲解，探讨C++更深层的应用

# 模板

- 模板不能直接使用，只是一个框架，需要有内容填充
- 模板不是万能的，需要视情况而定

## 函数模板

- C++另一种编程思想称为 `泛型编程`，主要利用的技术就是模板
- C++提供两种模板机制： **函数模板** 和 **类模板**

### 函数模板语法

函数模板作用：

建立一个通用函数，其函数返回值类型和形参类型可以不具体指定，用一个**虚拟的类型**来代表。

**语法：**

```cpp
template<typename T>	//typename也是关键字
函数声明或定义
```

**解释：**

template -- 声明创建模板

typename -- 表明其后面的符号是一种数据类型，可以用class代替

T -- 通用的数据类型，名称可以替换，通常为大写字母

**总结：** 类型参数化

```cpp
/*函数模板*/
//通用数据类型
template<typename T>
void mySwap(T& a, T& b)
{
	T temp = a;
	a = b;
	b = temp;
}
void Template_Type_001()
{
	/*两种方式使用模板函数*/
	int a = 10;
	int b = 80;
	//1.自动类型推导
	mySwap(a, b);
	cout << "a: " << a << endl;
	cout << "b: " << b << endl;
	//2.显式指定类型
	mySwap<int>(a, b);
	cout << "a: " << a << endl;
	cout << "b: " << b << endl;
}
```

### 函数模板注意事项

注意事项：

- 自动类型推导，必须推导出一致的数据类型T，才可以使用
- 模板必须要确定出T的数据类型，才可以使用
- 使用模板后必须紧跟着声明函数

```cpp
//函数模板注意事项
template<typename T>
void Template_Func_002()
{
	cout << "func 调用" << endl;
}
void Template_Type_002()
{
	//Template_Func_002();		//error:未能为“T”推导 模板 参数
	Template_Func_002<int>();	//但是显式指定类型就可以使用
}
```

### 函数模板案例

```cpp
template<typename T>
void mySort_001(T arr[])
{
	int n = sizeof(arr)/sizeof(arr[0]);
	for (int i = 0; i < n; i++)
	{
		int minIdx = i;
		for (int j = i+1; j < n; j++)
		{
			if (arr[j] < arr[minIdx])
			{
				minIdx = j;
			}
		}
		if (minIdx != i)
		{
			mySwap(arr[i], arr[minIdx]);
		}
	}
}
void Template_Eg_001()
{
	char arr1[] = "dabiadao";
	mySort_001(arr1);
	for (int i = 0; i < sizeof(arr1) / sizeof(arr1[0]); i++)
	{
		cout << arr1[i] << " ";
	}
	cout << endl;
}
```

### 普通函数与函数模板的区别

**普通函数与函数模板的区别：**

- 普通函数调用时可以发生自动类型转换（隐式类型转换）（只有值传递才会帮你转换类型）
- 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换
- 如果利用显式指定类型的方式，可以发生隐式类型转换

建议：在调用模板函数时，尽量使用显式指定类型的方式，自己提前确定T为什么类型比较好

```cpp
int myAdd_001(int a, int b)
{
	return a + b;
}
template<typename T>
int myAdd_002(T a, T b)
{
	return a + b;
}
//	普通函数可以发生隐式类型转换
void Template_Type_003()
{
	int a = 10;
	int b = 20;
	char c = 'c';
	cout << "a+b：" << myAdd_001(a, b) << endl;	//30
	/*普通函数*/
	//隐式类型转换，a -- ASCII(97);c -- ASCII(99)
	cout << "a+c：" << myAdd_001(a, c) << endl;	//109
	/*模板函数*/
	//自动类型推导
	//cout << myAdd_002(a, c) << endl;	//error:参数不匹配
	//显式指定类型
	cout << myAdd_002<int>(a, c) << endl;		//109
}
```

### 普通函数与函数模板的调用规则

调用规则：

1. 如果函数模板和普通函数都可以实现，优先调用普通函数
2. 可以通过空模板参数列表来强制调用函数模板
3. 函数模板也可以发生重载
4. 如果函数模板可以产生更好的匹配，优先调用函数模板

建议：提供了函数模板，最好不要再提供普通函数，容易出现二义性

```cpp
void myFuncPrint(int a, int b)
{
	cout << "调用的普通函数" << endl;
}
template<typename T>
void myFuncPrint(T a, T b)
{
	cout << "调用的函数模板" << endl;
}
template<typename T>
void myFuncPrint(T a, T b, T c)
{
	cout << "重载函数模板" << endl;
}
void myFuncPrint_test001()
{
	int a = 0, b = 0;
	//1.优先调用普通函数
	myFuncPrint(a, b);
	//	如果普通函数只有声明没有实现，也不会去执行函数模板，而是依旧优先执行普通函数然后报错，error：1个无法解析的外部命令
	//2.通过空模板参数列表，强制调用函数模板
	myFuncPrint<>(a, b);
	//3.函数模板可以发生函数重载
	myFuncPrint(a, b, 100);
	//4.如果函数模板可以产生更好的匹配，优先调用函数模板
	char c1 = 'a';
	char c2 = 'b';
	myFuncPrint(c1, c2);	//推导优于隐式转换，优先调用函数模板
}
```

### 模板的局限性

**局限性：**

- 情形1

```cpp
template<typename T>
void f(T a, T b)
{
    a = b;
}
//如果传入的a和b是数组，就无法实现
```

- 情形2

```cpp
template<typename T>
void f(T a, T b)
{
    if(a > b) {...}
}
//数组不行，自定义数据类型也没法做比较
```

C++为了解决上述问题，提供模板的重载，可以为这些 **特定的数据类型** 提供 **具体化的模板**]

总结：

- 利用具体化的模板，可以解决自定义类型的通用化
- 学习模板并不是为了写模板，而是在STL能够运用系统提供的模板

```cpp
//模板局限性	//模板函数重载
struct PersonTest001
{
	string m_Name;
	int m_Age;
};
template<typename T>
bool myCompare001(T& a, T& b)
{
	return (a == b);
}
// 利用具体化Person的版本实现代码，具体化会被优先调用
template<> 
bool myCompare001(PersonTest001& p1, PersonTest001& p2)
{
	return (p1.m_Name == p2.m_Name && p1.m_Age == p2.m_Age);
}
void Template_Type_004()
{
	//正常调用函数模板
	int a = 10, b = 20;
	cout << myCompare001(a, b) << endl;		//0
	//具体化函数模板
	PersonTest001 p1 = { "Tom", 10 };
	PersonTest001 p2 = { "Tom", 10 };
	cout << myCompare001(p1, p2) << endl;	//1
}
```

## 类模板

### 类模板语法

类模板作用：

- 建立一个通用类，类中的成员数据类型可以不具体定制，用一个**虚拟的类型**来代表

语法：

```cpp
template<typename T>
类
```

解释：

template -- 声明创建模板

typename -- 表明后面的符号是一种数据类型，可以使用class代替

T -- 通用的数据类型，名称可以替换，通常为大写字母

```cpp
template<class NameT, class AgeT>
class PersonClass
{
public:
	PersonClass(NameT name, AgeT age)
	{
		this->m_Name = name;
		this->m_Age = age;
	}
	NameT m_Name;
	AgeT m_Age;
};
void ClassTemplate_001()
{
	//类模板必须要使用模板参数列表
	PersonClass<string, int> p1("张三", 18);
}
```

### 类模板与函数模板区别

区别主要有两点：

1. 类模板没有自动类型推导的使用方式
2. 类模板在模板参数列表中可以有默认参数

# TODO 类模板与函数模板区别

## 模板的一些常见问题

### 模板的声明

通常情况下，你会在.h文件中声明函数和类，而将它们的定义放置在一个单独的.cpp文件中。但是在使用模板时，这种习惯性做法将变得不再有用，因为当实例化一个模板时，编译器必须看到模板确切的定义，而不仅仅是它的声明。因此，最好的办法就是将模板的声明和定义都放置在同一个.h文件中。这就是为什么所有的STL头文件都包含模板定义的原因。

### 模板调用迭代器不成功

```cpp
template<typename T>
void printVector(T& v)
{
    for (T::iterator it = v.begin(); it != v.end(); it++)
    {
        cout << *it << " ";
    }
    cout << endl;
}
```

上述写法，泛型使用迭代器会出错。

```cpp
template<typename T>
void printVector(T& v)
{
    for (typename T::iterator it = v.begin(); it != v.end(); it++)
    {
        cout << *it << " ";
    }
    cout << endl;
}
```

- 泛型类型在使用迭代器时，前面需要加 `typename`。

# STL初识

## STL的诞生

- 长久以来，软件界一直希望建立一种可重复利用的东西
- C++的 **面向对象** 和 **泛型编程** 的思想，目的就是 **复用性的提升**
- 大多情况下，数据结构和算法都未能有一套标准，导致被迫从事大量重复工作
- 为了建立数据结构和算法的一套标准，诞生了 **STL**

## STL基本概念

- STL（Standard Template Library，**标准库模板**）
- STL 从广义上分为：**容器（container）算法（algorithm）迭代器（iterator）**

- **容器** 和 **算法** 之间通过 **迭代器** 进行无缝连接
- STL几乎所有的代码都采用了模板类或者模板函数

## STL六大组件

**容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器**

1. 容器：各种数据结构，如vector、list、deque、set、map等，用来存放数据
2. 算法：各种常见的算法，如sort、find、copy、for_each等
3. 迭代器：扮演了容器与算法之间的胶合剂
4. 仿函数：行为类似函数，可作为算法的某种策略
5. 适配器：一种用来修饰容器或者仿函数或迭代器接口的东西
6. 空间配置器：负责空间的配置与管理

## STL中容器、算法、迭代器

- 容器

实现运用最广泛的一些数据结构

常见的数据结构：数组，链表，树，栈，队列，集合，映射表 等

容器分为 **序列式容器** 和 **关联式容器** 两种：

​	**序列式容器：** 强调值的排序，序列式容器中的每个元素均有固定的位置

​	**关联式容器：** 二叉树结构，各元素之间没有严格的物理上的顺序关系

- 算法

有限的步骤，解决逻辑或数学上的问题，这一门科学称为算法。

算法分为： **质变算法** 和 **非质变算法**。

​	**质变算法：** 是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等

​	**非质变算法**： 是指运算过程中不会更改区间内的元素内容。例如查找，计数，遍历，寻找极值等等。

- 迭代器

提供一种方法，使之能够依序访寻某个容器所含的各个元素，而又无需暴露该容器的内部表达方式。

每个容器都有自己专属的迭代器

迭代器使用非常类似于指针，初学阶段可以先理解迭代器为指针

- 迭代器种类：

| 种类           | 功能                                                     | 支持运算                                |
| -------------- | -------------------------------------------------------- | --------------------------------------- |
| 输入迭代器     | 对数据的只读访问                                         | 只读，支持++、==、!=                    |
| 输出迭代器     | 对数据的只写访问                                         | 只写，支持++                            |
| 前向迭代器     | 读写操作，并能向前推进迭代器                             | 读写，支持++、==、！=                   |
| 双向迭代器     | 读写操作，并能向前和向后操作                             | 读写，支持++、--                        |
| 随机访问迭代器 | 读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器 | 读写，支持++、--、[n]、-n、<、<=、>、>= |

常见的容器中迭代器种类为双向迭代器，和随机访问迭代器

## 容器算法迭代器初识

STL中最常见的容器为 `vector`，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器

### vector存放内置数据类型

容器： `vector`

算法：`for_each`

迭代器：`vector<int>::iterator`

### vector存放自定义数据类型

```cpp
//vector 容器中存放自定义数据类型
//  存放类
class Person
{
public:
    Person(string name, int age)
    {
        this->m_Name = name;
        this->m_Age = age;
    }
    string m_Name;
    int m_Age;
};

void vector_005()
{
    vector<Person> v;
    Person p1("aa", 10);
    Person p2("bb", 20);
    Person p3("cc", 30);
    v.push_back(p1);
    v.push_back(p2);
    v.push_back(p3);
    for (vector<Person>::iterator it = v.begin(); it != v.end(); it++)
    {
        // *it 解引用后是一个 Person 数据类型；就是vector<>内的内容
        cout << "姓名：" << (*it).m_Name << endl;
        cout << "年龄：" << (*it).m_Age << endl;
        // 当 it 是指针时，可以直接用指针访问类属性
        cout << "姓名：" << it->m_Name << endl;
        cout << "年龄：" << it->m_Age << endl;
    }
}

//  存放指针
void vector_006()
{
    vector<Person*> v;      // Type* 就是指针的意思
    Person p1("aa", 10);
    Person p2("bb", 20);
    Person p3("cc", 30);
    v.push_back(&p1);       // &对象  取实例化对象地址
    v.push_back(&p2);
    v.push_back(&p3);
    for (vector<Person*>::iterator it = v.begin(); it != v.end(); it++)
    {
        // *it 解引用后是一个 Person* 数据类型；就是vector<>内的内容
        cout << "姓名：" << (*(*it)).m_Name << endl;
        cout << "年龄：" << (*(*it)).m_Age << endl;
        // 两次解引用也可以这样写
        cout << "姓名：" << (**it).m_Name << endl;
        cout << "年龄：" << (**it).m_Age << endl;
        // 当 *it 是指针时，可以直接用指针访问类属性
        cout << "姓名：" << (*it)->m_Name << endl;
        cout << "年龄：" << (*it)->m_Age << endl;
    }
}
```

### vector容器嵌套容器

相当于多维数组

```cpp
void vector_007()
{
    vector<vector<int>> v;
    // 创建小容器
    vector<int> v1;
    vector<int> v2;
    vector<int> v3;
    vector<int> v4;
    // 向小容器中添加数据
    for (int i = 0; i < 4; i++)
    {
        v1.push_back(i+1);
        v2.push_back(i+2);
        v3.push_back(i+3);
        v4.push_back(i+4);
    }
    // 将小容器插入到大容器中
    v.push_back(v1);
    v.push_back(v2);
    v.push_back(v3);
    v.push_back(v4);
    // 通过大容器，遍历所有数据
    for (vector<vector<int>>::iterator it = v.begin(); it != v.end(); it++)
    {
        for (vector<int>::iterator jt = it->begin(); jt != it->end(); jt++)
        {
            cout << *jt << "\t";
        }
        cout << endl;
    }

}
```

# STL - 常用容器

## string容器

### string基本概念

本质：

- string是C++风格的字符串，而string本质上是一个类

`string` 和 `char*` 的区别：

- char* 是一个指针
- string是一个类，类内部封装了 `char*`，管理这个字符串，是一个`char*`型的容器

特点：

- string类内部封装了很多成员方法

例如：

- find, copy, delete, replace, insert

string管理`char*`所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责

### string构造函数

构造函数原型：

- `string();`		// 创建一个空的字符串 例如：string str;

  `string(const char* s);`		// 使用字符串s初始化

- `string(const string& str);`         // 使用一个string对象初始化另一个string对象

- `string(int n, char c);`		    // 使用n个字符c初始化

```cpp
// string的构造函数
//	`string();`		// 创建一个空的字符串 例如：string str;
//	`string(const char* s); `		// 使用字符串s初始化
void string_001()
{
	string s1;	// 默认构造
	const char* str = "hello world";		// C语言风格字符串
	string s2(str);
	cout << "构造的字符串为：" << s2 << endl;
}
//	`string(const string& str);`		// 使用一个string对象初始化另一个string对象
void string_002()
{	
	string str = "hello world";
	string s3(str);
	cout << "string初始化的对象为：" << s3 << endl;
}
//	`string(int n, char c);`		    // 使用n个字符c初始化
void string_003()
{
	string s4(10, 's');
	cout << s4 << endl;
}
```

### string赋值操作

赋值的函数原型：

- `string& operator=(const char* s);`		// `char*`类型字符串 赋值给当前字符串
- `string& operator=(const string& s);`		// 字符串s 赋值给当前字符串
- `string& operator=(char c);`		// 字符c 赋值给当前字符串
- `string& assign(const char* s);`		// 字符串s 赋值给当前字符串
- `string& assign(const char* s, int n);`		// 字符串s 的前n个字符 赋值给当前字符串
- `string& assign(const string& s);`		// 字符串s  赋值给当前字符串
- `string& assign(int n, char c);`		// n个字符c  赋值给当前字符串

```cpp
void string_004()
{
	string jx;
	// `string& operator=(const char* s);`
	jx = "hello world";
	cout << "string& operator=(const char* s);" << jx << endl;
	// `string& operator=(const string & s); `
	string jx2;
	jx2 = jx;
	cout << "string& operator=(const string & s); " << jx2 << endl;
	// `string& operator=(char c); `
	jx2 = 'x';
	cout << "string& operator=(char c); " << jx2 << endl;
	
	// `string& assign(const char* s); `
	jx2.assign("hello world");
	cout << "string& assign(const char* s); " << jx2 << endl;
	// `string& assign(const char* s, int n); `
	jx2.assign("hello world", 8);
	cout << "string& assign(const char* s, int n); " << jx2 << endl;
	// `string& assign(const string & s); `
	jx2.assign(jx);
	cout << "string& assign(const string & s); " << jx2 << endl;
	// `string& assign(int n, char c); `
	jx2.assign(5, 'x');
	cout << "string& assign(int n, char c);" << jx2 << endl;
}
```

### string字符串拼接

实现在字符串末尾拼接字符串

函数原型：

- `string& operator+=(const char* str);`		// 重载+=操作符
- `string& operator+=(const char c);`		// 重载+=操作符
- `string& operator+=(const string& str);`		// 重载+=操作符
- `string& append(const char* s);`		// 把字符串s连接到当前字符串结尾
- `string& append(const char* s,int n);`		// 把字符串s的前n个字符连接到当前字符串结尾
- `string& append(const string& s);`		// 同 `operator+=(const string& str)`
- `string& append(const string&s, int pos, int n);`		// 字符串s中从pos开始的n个字符连接到字符串结尾

```cpp
void string_005()
{
	string jx = "I";
	// `string& operator+=(const char* str);`
	jx += " have ";
	cout << "string& operator+=(const char* str);" << jx << endl;
	//-`string& operator+=(const char c); `		// 重载+=操作符
	jx += ' a';
	cout << "string& operator+=(const char c); " << jx << endl;
	//-`string& operator+=(const string & str); `		// 重载+=操作符
	string str = " hobby";
	jx += str;
	cout << "string& operator+=(const string & str); " << jx << endl;

	string jxa = "I";
	//-`string& append(const char* s); `		// 把字符串s连接到当前字符串结尾
	jxa.append(" have");
	cout << "string& append(const char* s); " << jxa << endl;
	//-`string& append(const char* s, int n); `		// 把字符串s的前n个字符连接到当前字符串结尾
	jxa.append(" a hobby", 2);
	cout << "string& append(const char* s, int n); " << jxa << endl;
	//-`string& append(const string & s); `		// 同 `operator+=(const string& str)`
	jxa.append(str);
	cout << "string& append(const string & s); " << jxa << endl;
	//-`string& append(const string & s, int pos, int n); `		// 字符串s中从pos开始的n个字符连接到字符串结尾*/
	str = "I have a hobby that is coding!";
	jxa.append(str, 14, 16);
	cout << "string& append(const string & s, int pos, int n); " << jxa << endl;
	//		if `int n > len`,what will happen?
	jxa.append(str, 14, 26);
	cout << "string& append(const string & s, int pos, int n); " << jxa << endl;
	//		no error happend
}
```



### string查找和替换

函数原型：

- `int find(const string& str, int pos = 0) const;`		// 查找str第一次出现的位置，从pos开始查找
- `int find(const char* s, int pos = 0) const;`		// 查找s第一次出现的位置，从pos开始查找
- `int find(const char* s, int pos, int n) const;`		// 从pos位置查找s的前n个字符第一次位置
- `int find(const char c, int pos = 0) const;`		// 查找字符c第一次出现的位置
- `int rfind(const string& str, int pos = npos) const;`		// 查找str最后一次位置，从pos开始查找
- `int rfind(const char* s, int pos = npos) const;`		// 查找s最后一次位置，从pos开始查找
- `int rfind(const char* s, int pos, int n) const;`		// 从pos位置查找s的前n个字符最后一次位置
- `int rfind(const char c, int pos =0) const;`		// 查找字符c最后一次位置
- `string& replace(int pos, int n, const string& str);`		// 替换从pos开始n个字符为字符串str
- `string& replace(int pos, int n, cosnt char* s);`		// 替换从pos开始n个字符为字符串s

```cpp
void string_006()
{
	string jx = "aaabbbcccddd";
	int res;
	//`int find(const string& str, int pos = 0) const;`		// 查找str第一次出现的位置，从pos开始查找
	res = jx.find("bb");
	cout << "int find(const string& str, int pos = 0) const; " << res << endl;
	//-`int find(const char* s, int pos, int n) const; `		// 从pos位置查找s的前n个字符第一次位置
	res = jx.find("bb", 3);
	cout << "int find(const char* s, int pos, int n) const; " << res << endl;
	//		if nofonud, function will return -1;
	res = jx.find("bb", 5);
	cout << "int find(const char* s, int pos, int n) const; " << res << endl;
	//		返回的位置是位于整个string的位置，返回的结果与pos无关
	res = jx.find("bb", 5, 1);
	cout << "int find(const char* s, int pos, int n) const; " << res << endl;

	// rfind 从右往左查找
	//-`int rfind(const string & str, int pos = npos) const; `		// 查找str最后一次位置，从pos开始查找
	res = jx.rfind("bb");
	cout << "int rfind(const string & str, int pos = npos) const; " << res << endl;
	//		if `npos>len`;what will happen?
	//res = jx.rfind("bb",100);
	cout << "int rfind(const string & str, int pos = npos) const; " << res << endl;
	//		no error happend
	//		`npos<0`时 就是相当于找到最后，和python的index不相同。
	res = jx.rfind("ddd", -3);
	cout << "int rfind(const string & str, int pos = npos) const; " << res << endl;

	//-`string& replace(int pos, int n, const string & str); `		// 替换从pos开始n个字符为字符串str
	jx.replace(0, 10, "bb");
	cout << "string& replace(int pos, int n, const string & str); " << jx << endl;
}
```

### string字符串比较

字符串比较是按字符的ASCII码进行对比（= 0；> 1；< -1）

函数原型

- `int compare(const string& s) const;`
- `int compare(const char* s) const;`

```cpp
void string_007()
{
	string str01 = "hello world";
	string str02 = "hello ";
	string str03 = "world";
	cout << "第一次比较的返回值： " << str01.compare(str02) << endl;
	str02 += str03;
	cout << "第二次比较的返回值： " << str01.compare(str02) << endl;
}
```

### string字符存取

- string单个字符存取
  - `char& operator[](int n);`		// 通过 [] 方式取字符
  - `char& at(int n);`		// 通过 at 方法取字符

```cpp
void string_008()
{
	string str = "hello world";
	///*- `char& operator[](int n);`		// 通过 [] 方式取字符
	for (int i = 0; i < str.size(); i++)
	{
		cout << str[i];
	}
	cout << endl;

	//-`char& at(int n); `		// 通过 at 方法取字符*/
	for (int i = 0; i < str.size(); i++)
	{
		cout << str.at(i);
	}
	cout << endl;

	// 修改单个字符
	str[0] = 'x';
	cout << "更改第一个字符：" << str << endl;
}
```

### string插入和删除

函数原型:

- `string& insert(int pos, const char* s);`		// 插入字符串
- `string& insert(int pos, const string& str);`		// 插入字符串
- `string& insert(int pos, int n, char c);`		// 插入n个字符c
- `string& erase(int pos, int n = npos);`		// 删除从pos开始的n个字符

```cpp
void string_009()
{
	string str = "hello";
	// 插入
	str.insert(0, "Jx ");
	cout << "插入后结果：" << str << endl;
	// 删除
	str.erase(2, 100);
	cout << "删除后结果：" << str << endl;
	//		if 后面npos不写会产生什么效果
	str.erase(0);		// erase() == erase(0)
	cout << "只写起始位置删除：" << str << endl;
	//		会删除pos后面所有的字符
}
```

### string子串

函数原型：

- `string substr(int pos = 0, inte n = npos) const;`		// 返回由pos开始的n个字符组装成的字符串

```cpp
void string_010()
{
	string str = "abcdefg";
	string jx = str.substr(2, 2);
	cout << "获得的子串：" << jx << endl;
}
```

### string综合小案例

```cpp
void stringEg_001()
{
	string email = "zhangsan@sina.cn";
	int endIndex = email.find('@');
	cout << "邮箱用户名为：" << email.substr(0, endIndex) << endl;
}
```

## vector容器

### vector基本概念

最常用的数据类型之一

功能：

- vector数据结构和数组非常相似，也称为 **单端数组**

与数组的区别：

- 数组是静态空间，而vector可以 **动态扩展**

**动态扩展：**

- 并不是在原空间之后续接空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间

![image-20210804135748256](https://i.loli.net/2021/08/04/p1oBRbOxaqAwkXC.png)

- vector容器的迭代器是支持随机访问的迭代器

### vector构造函数

函数原型：

- `vector<T> v;`		// 采用模板实现类实现，默认构造函数
- `vector(v.begin(),v.end());`		// 将v[ begin(),end() ) 区间中的元素拷贝给本身
- `vector(n, elem);`				// 构造函数将n各elem拷贝给本身
- `vector(const vector& vec);`		// 拷贝构造函数

```cpp
void vector_008()
{
    // 默认构造函数，无参构造
    vector<int> v1;     
    for (int i = 0; i < 10; i++)
    {
        v1.push_back(i);        // 对 v1 添加数据
    }
    printVector(v1);        // 自写一个 print 函数进行输出

    // 区间方式构造
    vector<int> v2(v1.begin(), v1.end());       
    printVector(v2);

    // n个elem方式构造
    vector<int> v3(10, 100);
    printVector(v3);

    // 拷贝构造
    vector<int> v4(v3);
    printVector(v4);
}
```

### vector赋值操作

函数原型：

- `vector& operator=(const vector& vec);`		// 重载等号操作符
- `assign(beg,end);`		// [beg,end) 区间拷贝赋值
- `assign(n,elem);`		// n个elem拷贝赋值

```cpp
void vector_009()
{
    vector<int> v1;
    for (int i = 0; i < 10; i++)
    {
        v1.push_back(i);
    }

    // = 直接赋值
    cout << "= 直接赋值" << endl;
    vector<int> v2 = v1;
    printVector(v2);

    // 区间拷贝复制
    cout << "区间拷贝复制" << endl;
    v2.assign(v1.begin(), v1.end());
    printVector(v2);

    // n个elem拷贝赋值
    cout << "n个elem拷贝赋值" << endl;
    v2.assign(10, 10);
    printVector(v2);
}
```

### vector容量和大小

函数原型：

- `empty();`			// 判断容器是否为空
- `capacity();`			// 容器的容量
- `size();`				// 返回容器中元素的个数
- `resize(int num);`	// 重新定义容器的长度为num,
  // 如果容器变长，则以默认值填充新位置。
  // 如果容器变短，则末尾超出容器长度的元素被删除。
- `resize(int num, elem);`	// 默认值变为 elem

```cpp
void vector_010()
{
    vector<int> v1;
    cout << "空容器调用empty() 返回值为：" << v1.empty() << endl;
    cout << "空容器的容量为：" << v1.capacity() << endl;
    cout << "空容器中元素的个数：" << v1.size() << endl;

    cout << endl;

    for (int i = 0; i < 10; i++)
    {
        v1.push_back(i);
    }
    cout << "查看一下赋值后容器的数据" << endl;
    printVector(v1);

    // 可以发现，容器的容量比容器的个数要大，是因为vector会自动多分配空间
    cout << "此时容器调用empty() 返回值为：" << v1.empty() << endl;
    cout << "容器的容量为：" << v1.capacity() << endl;
    cout << "容器中元素的个数：" << v1.size() << endl;
    // 容器中元素个数为10个时，容器容量为13

    // 扩充一下容器的长度
    v1.resize(12);
    cout << endl << "元素个数扩充到12时：" << endl;
    cout << "查看一下扩充后容器的数据" << endl;
    printVector(v1);
    cout << "此时容器容量为：" << v1.capacity() << endl;
    cout << "此时容器中元素的个数为：" << v1.size() << endl;
    // 此时容器的容量还是13，说明元素个数不大于容器容量时，容器容量不会增加
    //      那么，会缩小吗？
    cout << endl << "元素个数缩小到6，容器容量会有变化吗？" << endl;
    v1.resize(6);
    cout << "查看一下缩减后容器的数据" << endl;
    printVector(v1);
    cout << "此时容器容量为：" << v1.capacity() << endl;
    cout << "此时容器中元素的个数为：" << v1.size() << endl;
    //      嗯..个数缩减时容量也不会发生变化，
    //      可以理解为，已经开辟了这么大的空间了，够用就不会再改变了
    cout << endl << "验证一下`容量==个数`时的情形" << endl;
    v1.resize(v1.capacity());
    cout << "此时容器容量为：" << v1.capacity() << endl;
    cout << "此时容器中元素的个数为：" << v1.size() << endl;
    //      验证结果：空间够用就不会再改变
    cout << endl << "验证一下`容量==个数+1`时的情形" << endl;
    v1.resize(v1.capacity()+1);
    cout << "此时容器容量为：" << v1.capacity() << endl;
    cout << "此时容器中元素的个数为：" << v1.size() << endl;
    //      此时，容器中元素个数为14，容量为19
    //      总之，会多开辟空间，但是每次多开辟多少是容器类自己决定的
}
```

### vector插入和删除

函数原型：

- `push_back(ele);`		// 尾部插入元素ele
- `pop_back();`			// 尾部删除一个元素
- `insert(const_iterator pos, ele);`		// 迭代器指向位置pos插入元素ele
- `insert(const_iterator pos, int count, ele);`		// 迭代器指向位置pos插入count个元素ele
- `erase(const_iterator pos);`		// 删除迭代器指向的元素
- `erase(const_iterator start, const_iterator end);`		// 删除迭代器从start到end之间的元素
- `clear();`			// 删除容器中所有元素

```cpp
void vector_011()
{
    vector<int> v1;
    for (int i = 0; i < 10; i++)
    {
        v1.push_back(i);
    }
    cout << "查看一下创建的vector数据" << endl;
    printVector(v1);

    for (int i = 0; i < 5; i++)
    {
        v1.pop_back();      // pop_back()并不返回数据
    }
    cout << "利用pop_back()删除5次" << endl;
    printVector(v1);

    // 迭代器的方式插入
    v1.insert(v1.begin() + 2, 99);
    cout << "在中间插入数据" << endl;
    printVector(v1);

    // 迭代器的方式删除
    v1.erase(v1.begin() + 2);
    cout << "删除之前插入的99" << endl;
    printVector(v1);

    // clear() 清除
    v1.clear();
    cout << "clear()清除" << endl;
    printVector(v1);
}
```

### vector数据存取

函数原型：

- `at(int idx);`		// 返回索引idx所指的数据
- `operator[];`			// 返回索引idx所指的数据
- `front();`			// 返回容器中第一个数据元素
- `back();`				// 返回容器中最后一个数据元素

```cpp
void vector_012()
{
    vector<int> v1;
    init_Dim1andCout(v1);

    cout << "利用for循环分别取索引输出：" << endl;
    for (int i = 0; i < v1.size(); i++)
    {
        cout << v1.at(i) << " ";
    }
    cout << endl;
    for (int i = 0; i < v1.size(); i++)
    {
        cout << v1[i] << " ";
    }
    cout << endl;

    cout << "第一个元素：" << v1.front() << endl;;
    cout << "第一个元素：" << v1.back() << endl;
}
```

### vector互换容器

函数原型：

- `swap(vec);`		// 将vec与本身的元素互换

```cpp
void vector_013()
{
    vector<int> v1;
    init_Dim1andCout(v1);

    vector<int> v2(10,0);       // 提前分配好空间
    for (int i = 0,j = v2.size()-1; i < v2.size(); i++,j--)
    {
        v2[i] = j;
    }
    cout << "v2创建的数据为：" << endl;
    printVector(v2);

    v2.swap(v1);
    cout << "swap()互换后" << endl;
    cout << "v1的数据为：" << endl;
    printVector(v1);
    cout << "v2的数据为：" << endl;
    printVector(v2);

    // 应用场景
    //      可以查看当前v2的容量
    cout << "当前v2的容量为：" << v2.capacity() << endl;
    cout << "当前v2的元素为：" << v2.size() << endl;
    //      运用 匿名对象拷贝构造 + swap 可以缩小内存空间让'容量=个数'
    vector<int>(v2).swap(v2);
    cout << "swap()后v2的容量为：" << v2.capacity() << endl;
    cout << "swap()后v2的元素为：" << v2.size() << endl;
    //      ps：匿名对象的容量=3
    printVector(v2);
}
```

### vector预留空间

减少vector在动态扩展容量时的扩展次数

函数原型：

- `reserve(int len);`		// 容器预留len个元素长度，预留位置不初始化，元素不可访问。

```cpp
void vector_014()
{
    vector<int> v;
    // 查看压入十万次数据时，内存开辟的次数
    int num = 0;
    int* p = NULL;
    for (int i = 0; i < 100000; i++)
    {
        v.push_back(i);
        if (p != &v[0])
        {
            p = &v[0];
            num++;
        }
    }
    cout << "开辟内存的次数：" << num << endl;

    vector<int> v1;
    v1.reserve(100000);
    num = 0;
    p = NULL;
    for (int i = 0; i < 100000; i++)
    {
        v1.push_back(i);
        if (p != &v1[0])
        {
            p = &v1[0];
            num++;
        }
    }
    cout << "开辟内存的次数：" << num << endl;
}
```

## TODO deque

