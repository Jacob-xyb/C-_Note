# 初始C语言

## 代码执行流程

编辑器：程序员写代码的过程

编译器：查看代码的语言错误，生成汇编语言

汇编器：将生成好的汇编语言 生成 二进制语言（目标文件 .obj 或 .o 文件）

连接器：将生成好 二进制语言 + 用到的库 + 启动代码 ==> 可执行文件

## 第一行代码

```c
#include <stdio.h>  // std 标准 i 输入 o 输出 （标准的输入输出头文件）

// main 是程序的入口，唯一存在 
int main(int argc, char *argv[])
{
    // 使用任何东西，必先存在；printf 来自系统库文件
    printf("hello world\n");
    return 0;
}
```

如果代码一闪而过，可以采用带阻塞的代码：

```c
// 1.获取字符串
getchar();
```

## 基础语法

### printf()

`printf()`不会在行尾自动添加换行符，运行结束后，光标就停留在输出结束的地方，不会自动换行。为了让光标移到下一行的开头，可以在输出文本的结尾，添加一个换行符`\n`。

`printf()`是在标准库的头文件`stdio.h`定义的。使用这个函数之前，必须在源码文件头部引入这个头文件。

```c
#include <stdio.h>
int main(void) {
  printf("Hello World\n");
}
```

#### printf 中的占位符

`printf()`可以在输出文本中指定占位符。所谓“占位符”，就是这个位置可以用其他值代入。

```c
printf("%s says it is %i o'clock\n", "Ben", 21);
// Ben says it is 21 o'clock
```

- `%a`：浮点数。
- `%A`：浮点数。
- `%c`：字符。
- `%d`：十进制整数。
- `%e`：使用科学计数法的浮点数，指数部分的`e`为小写。
- `%E`：使用科学计数法的浮点数，指数部分的`E`为大写。
- `%i`：整数，基本等同于`%d`。
- `%f`：小数（包含`float`类型和`double`类型）。
- `%g`：6个有效数字的浮点数。整数部分一旦超过6位，就会自动转为科学计数法，指数部分的`e`为小写。
- `%G`：等同于`%g`，唯一的区别是指数部分的`E`为大写。
- `%hd`：十进制 short int 类型。
- `%ho`：八进制 short int 类型。
- `%hx`：十六进制 short int 类型。
- `%hu`：unsigned short int 类型。
- `%ld`：十进制 long int 类型。
- `%lo`：八进制 long int 类型。
- `%lx`：十六进制 long int 类型。
- `%lu`：unsigned long int 类型。
- `%lld`：十进制 long long int 类型。
- `%llo`：八进制 long long int 类型。
- `%llx`：十六进制 long long int 类型。
- `%llu`：unsigned long long int 类型。
- `%Le`：科学计数法表示的 long double 类型浮点数。
- `%Lf`：long double 类型浮点数。
- `%n`：已输出的字符串数量。该占位符本身不输出，只将值存储在指定变量之中。
- `%o`：八进制整数。
- `%p`：指针。
- `%s`：字符串。
- `%u`：无符号整数（unsigned int）。
- `%x`：十六进制整数。
- `%zd` or ` %zu`：`size_t`类型。
- `%%`：输出一个百分号。

#### 格式化输出

`printf()`可以定制占位符的输出格式。

1. 限定宽度

   `printf()`允许限定占位符的最小宽度。

2. 总是显示正负号

   可以在占位符的`%`后面加一个`+`，确保输出的数值总带有正负号

   ```c
   // 默认右对齐，空格填充
   printf("%5d\n", 123);  // '  123'
   // 左对齐
   printf("%-5d\n", 123); // '123  '
   
   printf("%12f\n", 123.45);  // '  123.450000'
   printf("%6f\n", 123.45);  // '123.450000'
   
   // 总是显示正负号
   printf("%+d\n", 12); // 输出 +12
   printf("%+d\n", -12); // 输出 -12
   ```

3. 限定小数位数

   输出小数时，有时希望限定小数的位数。举例来说，希望小数点后面只保留两位，占位符可以写成`%.2f`。

   最小宽度和小数位数这两个限定值，都可以用`*`代替，通过`printf()`的参数传入。

   ```c
   printf("%*.*f\n", 6, 2, 0.5);
   // 等同于
   printf("%6.2f\n", 0.5);
   ```

   ---

   ```c
   void func_printf_limit_digits() {
   	printf("%.2f\n", 1.2345); // 1.23
   
   	// 限制位数只限制小数点后位数，对整数无效
   	printf("%.2d\n", 12345); // 12345
   
   	// 采用 * 代替限定值
   	printf("%.*f\n", 2, 1.2345); // 1.23
   	printf("%*.*f\n", 5, 2, 1.2345); // ' 1.23'
   	printf("%+*.*f\n", 5, 2, 1.2345); // +1.23
   }
   ```

4. 输出部分字符串

   `%s`占位符用来输出字符串，默认是全部输出。如果只想输出开头的部分，可以用`%.[m]s`指定输出的长度，其中`[m]`代表一个数字，表示所要输出的长度。

   ```c
   printf("%.5s\n", "hello world"); // hello
   ```

5. 进制数输出以及显式输出

   ```c
   int num = 100;
   
   //十进制 输出 %d %u %ld %lu
   printf("十进制：num=%d\n", num);//100
   //八进制 输出 %o 以0开头
   printf("八进制：num=%o\n", num);//144
   //十六进制 输出 %x 以0x开头
   printf("十六进制：num=%x\n", num);//64
   
   // %后追加# 可以显示输出对应进制标志符
   printf("八进制：num=%#o\n", num);//0144
   printf("十六进制：num=%#x\n", num);//0x64
   
   //不同进制 仅仅是数据的表现形式 不会修改数据本身
   ```

## 变量

C 语言会在变量声明时，就为它分配内存空间，但是不会清除内存里面原来的值。这导致声明变量以后，变量会是一个随机的值。所以，变量一定要赋值以后才能使用。

注意，赋值表达式有返回值，等于等号右边的值。

```c
int x, y;
x = 1;
y = (x = 2 * x);
```

上面代码中，变量`y`的值就是赋值表达式（`x = 2 * x`）的返回值`2`。

由于赋值表达式有返回值，所以 C 语言可以写出多重赋值表达式。

```c
int x, y, z, m, n;
x = y = z = m = n = 3;
```

## 运算符

### 加减乘除

运算符`/`用来完成除法。注意，两个整数相除，得到还是一个整数。

```c
float x = 6 / 4;
printf("%f\n", x); // 输出 1.000000
```

运算符`%`表示求模运算，即返回两个整数相除的余值。这个运算符只能用于整数，不能用于浮点数。

负数求模的规则是，结果的正负号由第一个运算数的正负号决定。

```c
11 % -5 // 1
-11 % -5 // -1
-11 % 5 // -1
```

### 自增自减

这两个运算符放在变量的前面或后面，结果是不一样的。`++var`和`--var`是先执行自增或自减操作，再返回操作后`var`的值；`var++`和`var--`则是先返回操作前`var`的值，再执行自增或自减操作。

### 逻辑运算符

逻辑运算符提供逻辑判断功能，用于构建更复杂的表达式，主要有下面三个运算符。

- `!`：否运算符（改变单个表达式的真伪）。
- `&&`：与运算符（两侧的表达式都为真，则为真，否则为伪）。
- `||`：或运算符（两侧至少有一个表达式为真，则为真，否则为伪）。

```c
if (!(x < 12))
    printf("x is not less than 12\n");
```

上面示例中，由于否运算符`!`具有比`<`更高的优先级，所以必须使用括号，才能对表达式`x < 12`进行否运算。当然，合理的写法是`if (x >= 12)`，这里只是为了举例。

### 位运算符

（1）与运算符`&`

与运算符`&`将两个值的每一个二进制位进行比较，返回一个新的值。当两个二进制位都为`1`，就返回`1`，否则返回`0`。

应用场景：将固定位 `清零` 。

（2）或运算符`|`

或运算符`|`将两个值的每一个二进制位进行比较，返回一个新的值。两个二进制位只要有一个为`1`（包含两个都为`1`的情况），就返回`1`，否则返回`0`。

应用场景：将固定位 `置一`。

（3）取反运算符`～`

a 取反的结果是 -(a+1)

（4）异或运算符`^`

异或运算符`^`将两个值的每一个二进制位进行比较，返回一个新的值。两个二进制位有且仅有一个为`1`，就返回`1`，否则返回`0`。

或者换种方式理解：和 0 异或保持不变；和 1 异或取反。

应用场景：将固定位 `发生高低电频翻转`。

（5）左移运算符`<<`

左移运算符`<<`将左侧运算数的每一位，向左移动指定的位数，尾部空出来的位置使用`0`填充。

```c
// 1000101000
10001010 << 2
```

（6）右移运算符`>>`

右移运算符`>>`将左侧运算数的每一位，向右移动指定的位数，尾部无法容纳的值将丢弃，头部空出来的位置使用`0`填充。

注意，右移运算符最好只用于无符号整数，不要用于负数。因为不同系统对于右移后如何处理负数的符号位，有不同的做法，可能会得到不一样的结果。

右移分为 `逻辑右移` 和 `算术右移`

发生逻辑右移时，右边丢弃，左边补零；

发生算术右移时，情况比较复杂：

- 无符号数：右边丢弃，左边补零；
- 有符号数：
  - 正数：右边丢弃，左边补零；
  - 负数：右边丢弃，左边补一。

**判断右移运算符类型：**

```c
char data = 0x80;
printf("data:%d\n", data);
if ((data >> 2) == (char)0x20)
{
    printf("逻辑右移");
}
else if ((data >> 2) == (char)0xe0)
{
    printf("算术右移");
}
else {
    printf("%d", (data >> 2));
}
```

### 逗号运算符

**逗号运算符用于将多个表达式写在一起，从左到右依次运行每个表达式。**

**逗号运算符返回最后一个表达式的值，作为整个语句的值。**

```c
int x;
x = 1, 2, 3;
// = 比 , 有更高的优先级，所以 x=1
printf("%d\n", x);  // 1

// 但是整个语句的返回值为最后一个表达式的值
int y;
y = (x = 1, 2, 3);
printf("%d\n", y);  // 3
```

### 运算符优先级

C语言中，运算符的运算优先级共分为15级，1级最高。

- 圆括号（`()`）`[]`、`.` 、 `->` 
- 自增运算符（`++`），自减运算符（`--`）
- 一元运算符（`+`和`-`）
- 乘法（`*`），除法（`/`）
- 加法（`+`），减法（`-`）
- 关系运算符（`<`、`>`等）
- 赋值运算符（`=`）

# 基础数据类型

[书栈-基础数据类型](https://www.bookstack.cn/read/wangdoc-clang-tutorial/docs-types.md)

## 内存基本常识

**一个字节 = 8位二进制** 

1B = 8b

1 KB = 1024 B

1 MB = 1024 KB

1 GB = 1024 MB

1 TB = 1024 GB

1 PB = 1024 TB

1 EB = 1024 PB

---

-------------------------在32位平台---------------------------------
char 字符类型 占1字节的空间（8位二进制位）
short 短整型 占2字节的空间（16位二进制位）
int 整型 占4字节的空间（32位二进制位）
long 长整型 占4字节的空间（32位二进制位）
float 单精度浮点型 占4字节的空间（32位二进制位）
double 双精度浮点型 占8字节的空间（64位二进制位）
-------------------------在64位平台---------------------------------
char 字符类型 占1字节的空间（8位二进制位）
short 短整型 占2字节的空间（16位二进制位）
int 整型 占4字节的空间（32位二进制位）
long 长整型 占8字节的空间（64位二进制位）
float 单精度浮点型 占4字节的空间（32位二进制位）
double 双精度浮点型 占8字节的空间（64位二进制位）

## 字符类型

C 语言规定，字符常量必须放在单引号里面。

在计算机内部，字符类型使用一个字节（8位）存储。C 语言将其当作整数处理，所以字符类型就是宽度为一个字节的整数。每个字符对应一个整数（由 ASCII 码确定），比如`B`对应整数`66`。

只要在字符类型的范围之内，整数与字符是可以互换的，都可以赋值给字符类型的变量。

```c
char c = 66;
// 等同于
char c = 'B';
```

### 字符变量的运算

两个字符类型的变量可以进行数学运算。

```c
char a = 'B'; // 等同于 char a = 66;
char b = 'C'; // 等同于 char b = 67;
printf("%d\n", a + b); // 输出 133
```

还可以直接用整数进行转换：

```c
char a = 20;
char b = 45;
char c = a + b;
printf("%d\n", c); // 65
printf("%c\n", c); // A
int x = c;
printf("%d\n", x); // 65
```

### 转义写法

`char a = 0;` === `char a = '\0';`

转义写法还能使用八进制和十六进制表示一个字符。

- `\nn`：字符的八进制写法，`nn`为八进制值。
- `\xnn`：字符的十六进制写法，`nn`为十六进制值。

```c
char x;
x = 'B';
printf("%c\n", x);
x = 66;
printf("%c\n", x);
x = '\102'; // 八进制
printf("%c\n", x);
x = '\x42'; // 十六进制 转义写法
printf("%c\n", x);
x = 0x42;  // 十六进制 进制写法
printf("%c\n", x);
//输出均是 'B'
```

## 整数类型

### 整数常量

**按进制类型分**

十进制：C 语言的整数默认都是十进制数；

二进制：有些编译器使用`0b`前缀，表示二进制数，但不是标准；

八进制：八进制使用`0`作为前缀，比如`017`、`0377`；

十六进制：十六进制使用`0x`或`0X`作为前缀，比如`0xf`、`0X10`；

```c
int x1 = 012; // 八进制，相当于十进制的10
int x2 = 0x1A2B; // 十六进制，相当于十进制的6699
int x3 = 0b10; // 二进制，相当于十进制的2 
```

## 浮点数类型

浮点数默认是 double 类型

```c
sizeof(3.14); // 8
sizeof(3.14f); // 4
```

## 字面量

### 字面量后缀

总结一下，常用的字面量后缀有下面这些。

- `f`和`F`：`float`类型。
- `l`和`L`：对于整数是`long int`类型，对于小数是`long double`类型。
- `ll`和`LL`：Long Long 类型，比如`3LL`。
- `u`和`U`：表示`unsigned int`，比如`15U`、`0377U`。

`u`还可以与其他整数后缀结合，放在前面或后面都可以，比如`10UL`、`10ULL`和`10LLU`都是合法的。

```c
int           x = 1234;
long int      x = 1234L;
long long int x = 1234LL
unsigned int           x = 1234U;
unsigned long int      x = 1234UL;
unsigned long long int x = 1234ULL;
float x       = 3.14f;
double x      = 3.14;
long double x = 3.14L;
```

## 类型的自动转换

### 赋值运算

（1）浮点数赋值给整数变量

浮点数赋予整数变量时，C 语言直接丢弃小数部分，而不是四舍五入。

```c
// 1.浮点数赋值给整数变量
// ++ 浮点数赋予整数变量时，C 语言直接丢弃小数部分，而不是四舍五入。
int x1 = 3.14;
printf("%d\n", x1); // 3
```

（2）整数赋值给浮点数变量

整数赋值给浮点数变量时，会自动转为浮点数。

（3）窄类型赋值给宽类型

字节宽度较小的整数类型，赋值给字节宽度较大的整数变量时，会发生类型提升，即窄类型自动转为宽类型。

比如，`char`或`short`类型赋值给`int`类型，会自动提升为`int`。

（4）宽类型赋值给窄类型

字节宽度较大的类型，赋值给字节宽度较小的变量时，会发生类型降级，自动转为后者的类型。这时可能会发生截值（truncation），系统会自动截去多余的二进制位，导致难以预料的结果。

```c
int i = 321;
char ch = i; // ch 的值是 65 （321 - 256）
```

上面例子中，变量`ch`是`char`类型，宽度是8个二进制位。变量`i`是`int`类型，将`i`赋值给`ch`，后者只能容纳`i`（二进制形式为`101000001`，共9位）的后八位，前面多出来的二进制位被丢弃，保留后八位就变成了`01000001`（十进制的65，相当于字符`A`）。

### 混合运算

（1）整数与浮点数混合运算时，整数转为浮点数类型，与另一个运算数类型相同。

（2）不同的浮点数类型混合运算时，宽度较小的类型转为宽度较大的类型，比如`float`转为`double`，`double`转为`long double`。

（3）不同的整数类型混合运算时，宽度较小的类型会提升为宽度较大的类型。比如`short`转为`int`，`int`转为`long`等，有时还会将带符号的类型`signed`转为无符号`unsigned`。

```c
// signed 和 unsigned 比较时，会将 signed 转换为 unsigned
int a = -2;      // 0xfffffffe
unsigned b = 1;  // 0x00000001
unsigned c = a;
if (a + b == -1)
{
    // -1补码是0xFFFFFFFF
    // ++ 但是 -1 时 signed，表达式中变量b是unsigned
    // ++ 所以-1当作unsigned时，为4294967295
    printf("a + b == -1\n"); // 会输出这条
}
else
{
    printf("a + b != -1\n");
}

if (a + b == 4294967295)
{
    printf("a + b == 4294967295\n"); // 会输出这条
}
else
{
    printf("a + b != 4294967295\n");
}
printf("%u", c);  // 4294967294
```

`a`会自动转成无符号整数`4294967294`（转换规则是`-2`加上无符号整数的最大值，再加1）

### 整数类型的运算

两个相同类型的整数运算时，或者单个整数的运算，一般来说，运算结果也属于同一类型。但是有一个例外，宽度小于`int`的类型，运算结果会自动提升为`int`。

# 流程控制

[书栈-流程控制](https://www.bookstack.cn/read/wangdoc-clang-tutorial/docs-flow-control.md)

# 指针

[书栈-指针](https://www.bookstack.cn/read/wangdoc-clang-tutorial/docs-pointer.md)

# 函数

[书栈-函数](https://www.bookstack.cn/read/wangdoc-clang-tutorial/docs-function.md)

## 函数指针

函数本身就是一段内存里面的代码，C 语言允许通过指针获取函数。

```c
void print(int a) {
  printf("%d\n", a);
}
void (*print_ptr)(int) = &print;
```

上面示例中，变量`print_ptr`是一个函数指针，它指向函数`print()`的地址。函数`print()`的地址可以用`&print`获得。注意，`(*print_ptr)`一定要写在圆括号里面，否则函数参数`(int)`的优先级高于`*`，整个式子就会变成`void* print_ptr(int)`。

有了函数指针，通过它也可以调用函数。

```c
(*print_ptr)(10);
// 等同于
print(10);
```

比较特殊的是，C 语言还规定，函数名本身就是指向函数代码的指针，通过函数名就能获取函数地址。也就是说，`print`和`&print`是一回事。

```c
if (print == &print) // true
```

因此，上面代码的`print_ptr`等同于`print`。

```c
void (*print_ptr)(int) = &print;

// 或
void (*print_ptr)(int) = print;

if (print_ptr == print) // true
```

## exit()

`exit()`函数用来终止整个程序的运行。一旦执行到该函数，程序就会立即结束。该函数的原型定义在头文件`stdlib.h`里面。

`exit()`可以向程序外部返回一个值，它的参数就是程序的返回值。一般来说，使用两个常量作为它的参数：`EXIT_SUCCESS`（相当于 0）表示程序运行成功，`EXIT_FAILURE`（相当于 1）表示程序异常中止。这两个常数也是定义在`stdlib.h`里面。

```c
// 程序运行成功
// 等同于 exit(0);
exit(EXIT_SUCCESS);
// 程序异常中止
// 等同于 exit(1);
exit(EXIT_FAILURE);
```

在`main()`函数里面，`exit()`等价于使用`return`语句。其他函数使用`exit()`，就是终止整个程序的运行，没有其他作用。

C 语言还提供了一个`atexit()`函数，用来登记`exit()`执行时额外执行的函数，用来做一些退出程序时的收尾工作。该函数的原型也是定义在头文件`stdlib.h`。

```c
int atexit(void (*func)(void));
```

`atexit()`的参数是一个函数指针。注意，它的参数函数（下例的`print`）不能接受参数，也不能有返回值。

```c
void print(void) {
  printf("something wrong!\n");
}
atexit(print);
exit(EXIT_FAILURE);
```

上面示例中，`exit()`执行时会先自动调用`atexit()`注册的`print()`函数，然后再终止程序。

## 可变参数

有些函数的参数数量是不确定的，声明函数的时候，可以使用省略号`...`表示可变数量的参数。

```c
int printf(const char* format, ...);
```

上面示例是`printf()`函数的原型，除了第一个参数，其他参数的数量是可变的，与格式字符串里面的占位符数量有关。这时，就可以用`...`表示可变数量的参数。

注意，`...`符号必须放在参数序列的结尾，否则会报错。

头文件`stdarg.h`定义了一些宏，可以操作可变参数。

（1）`va_list`：一个数据类型，用来定义一个可变参数对象。它必须在操作可变参数时，首先使用。

（2）`va_start`：一个函数，用来初始化可变参数对象。它接受两个参数，第一个参数是可变参数对象，第二个参数是原始函数里面，可变参数之前的那个参数，用来为可变参数定位。

（3）`va_arg`：一个函数，用来取出当前那个可变参数，每次调用后，内部指针就会指向下一个可变参数。它接受两个参数，第一个是可变参数对象，第二个是当前可变参数的类型。

（4）`va_end`：一个函数，用来清理可变参数对象。

下面是一个例子。

```c
double average(int i, ...) {
    double total = 0;
    va_list ap;
    va_start(ap, i);
    for (int j = 1; j <= i; ++j) {
        total += va_arg(ap, double);
    }
    va_end(ap);
    return total / i;
}
```

上面示例中，`va_list ap`定义`ap`为可变参数对象，`va_start(ap, i)`将参数`i`后面的参数统一放入`ap`，`va_arg(ap, double)`用来从`ap`依次取出一个参数，并且指定该参数为 double 类型，`va_end(ap)`用来清理可变参数对象。

# 数组

[书栈-数组](https://www.bookstack.cn/read/wangdoc-clang-tutorial/docs-array.md)

## 简介

数组是一组`相同类型`的值，按照顺序用 `连续的空间` 储存在一起。

如果大括号里面的值，少于数组的成员数量，那么未赋值的成员自动初始化为`0`。

```c
int a[5] = {22, 37, 3490};
// 等同于
int a[5] = {22, 37, 3490, 0, 0};
```

如果要将整个数组的每一个成员都设置为零，最简单的写法就是下面这样。

```c
int a[100] = {0};
```

其他声明方式：

```c
// 数组初始化时，可以指定为哪些位置的成员赋值。（只有gcc编译器支持）
int a[15] = {[2] = 29, [9] = 7, [14] = 48};
// 上面示例中，数组的2号、9号、14号位置被赋值，其他位置的值都自动设为0。

// 指定位置的赋值可以不按照顺序，下面的写法与上面的例子是等价的。（只有gcc编译器支持）
int a[15] = {[9] = 7, [14] = 48, [2] = 29};

// 指定位置的赋值与顺序赋值，可以结合使用。（只有gcc编译器支持）
int a[15] = {1, [5] = 10, 11, [10] = 20, 21}
// 上面示例中，0号、5号、6号、10号、11号被赋值。

// C 语言允许省略方括号里面的数组成员数量，这时将根据大括号里面的值的数量，自动确定数组的长度。
int a[] = {22, 37, 3490};
// 等同于
int a[3] = {22, 37, 3490};

// 省略成员数量时，如果同时采用指定位置的赋值，那么数组长度将是最大的指定位置再加1。（只有gcc编译器支持）
int a[] = {[2] = 6, [9] = 12};
// 上面示例中，数组a的最大指定位置是9，所以数组的长度是10。
```

## 数组长度

## 变长数组

C99 标准， Visual Studio 只支持C89。

## 数组指针

函数接受数组作为参数，函数原型可以写成下面这样。

```c
// 写法一
int sum(int arr[], int len);
// 写法二
int sum(int* arr, int len);
```

`*`和`&`运算符也可以用于多维数组。

```c
int a[4][2];
// 取出 a[0][0] 的值
*(a[0]);
// 等同于
**a
```

上面示例中，二维数组中，由于`a[0]`的值本身是一个指针，指向第二维数组的第一个成员`a[0][0]`。所以，`*(a[0])`取出的是`a[0][0]`的值。

至于`**a`，就是对`a`进行两次`*`运算，第一次取出的是`a[0]`，第二次取出的是`a[0][0]`。

同理，二维数组的`&a[0][0]`等同于`*a`。

## 数组指针的加减

C 语言里面，数组名可以进行加法和减法运算，等同于在数组成员之间前后移动，即从一个成员的内存地址移动到另一个成员的内存地址。比如，`a + 1`返回下一个成员的地址，`a - 1`返回上一个成员的地址。

```c
int a[5] = {11, 22, 33, 44, 55};
for (int i = 0; i < 5; i++) {
  printf("%d\n", *(a + i));
}
```

上面示例中，通过指针的移动遍历数组，`a + i`的每轮循环每次都会指向下一个成员的地址，`*(a + i)`取出该地址的值，等同于`a[i]`。对于数组的第一个成员，`*(a + 0)`（即`*a`）等同于`a[0]`。

由于数组名与指针是等价的，所以下面的等式总是成立。

```c
a[b] == *(a + b)
```

上面代码给出了数组成员的两种访问方式，一种是使用方括号`a[b]`，另一种是使用指针`*(a + b)`。

## 数组的复制

由于数组名是指针，所以复制数组不能简单地复制数组名。

```c
int* a;
int b[3] = {1, 2, 3};
a = b;
```

上面的写法，结果不是将数组`b`复制给数组`a`，而是让`a`和`b`指向同一个数组。

复制数组最简单的方法，还是使用循环，将数组元素逐个进行复制。

```c
for (i = 0; i < N; i++)  
    a[i] = b[i];
```

上面示例中，通过将数组`b`的成员逐个复制给数组`a`，从而实现数组的赋值。

另一种方法是使用`memcpy()`函数（定义在头文件`string.h`），直接把数组所在的那一段内存，再复制一份。

```c
memcpy(a, b, sizeof(b));
```

上面示例中，将数组`b`所在的那段内存，复制给数组`a`。这种方法要比循环复制数组成员要快。

# 字符串

[书栈-字符串](https://www.bookstack.cn/read/wangdoc-clang-tutorial/docs-string.md)

## 字符串变量的声明

为什么字符串声明为指针时不能修改，声明为数组时就可以修改？原因是系统会将字符串的字面量保存在内存的常量区，这个区是不允许用户修改的。声明为指针时，指针变量存储的值是一个指向常量区的内存地址，因此用户不能通过这个地址去修改常量区。但是，声明为数组时，编译器会给数组单独分配一段内存，字符串字面量会被编译器解释成字符数组，逐个字符写入这段新分配的内存之中，而这段新内存是允许修改的。

为什么数组变量不能赋值为另一个数组？原因是数组变量所在的地址无法改变，或者说，编译器一旦为数组变量分配地址后，这个地址就绑定这个数组变量了，这种绑定关系是不变的。C 语言也因此规定，数组变量是一个不可修改的左值，即不能用赋值运算符为它重新赋值。

想要重新赋值，必须使用 C 语言原生提供的`strcpy()`函数，通过字符串拷贝完成赋值。这样做以后，数组变量的地址还是不变的，即`strcpy()`只是在原地址写入新的字符串，而不是让数组变量指向新的地址。

```c
char s[10];
strcpy(s, "abc");
```

**注：**现在采用 strcpy_s() 更安全

# 内存管理

[书栈-内存管理](https://www.bookstack.cn/read/wangdoc-clang-tutorial/docs-memory.md)

## 简介

C 语言的内存管理，分成两部分。一部分是系统管理的，另一部分是用户手动管理的。

系统管理的内存，主要是函数内部的变量（局部变量）。这部分变量在函数运行时进入内存，函数运行结束后自动从内存卸载。这些变量存放的区域称为”栈“（stack），”栈“所在的内存是系统自动管理的。

用户手动管理的内存，主要是程序运行的整个过程中都存在的变量（全局变量），这些变量需要用户手动从内存释放。如果使用后忘记释放，它就一直占用内存，直到程序退出，这种情况称为”内存泄漏“（memory leak）。这些变量所在的内存称为”堆“（heap），”堆“所在的内存是用户手动管理的。

# 结构体

[书栈-结构体](https://www.bookstack.cn/read/wangdoc-clang-tutorial/docs-struct.md)

# typedef

[书栈-typedef](https://www.bookstack.cn/read/wangdoc-clang-tutorial/docs-typedef.md)

# union

[书栈-union](https://www.bookstack.cn/read/wangdoc-clang-tutorial/docs-union.md)
