# 初始C语言

## 基础语法

### printf()

`printf()`不会在行尾自动添加换行符，运行结束后，光标就停留在输出结束的地方，不会自动换行。为了让光标移到下一行的开头，可以在输出文本的结尾，添加一个换行符`\n`。

`printf()`是在标准库的头文件`stdio.h`定义的。使用这个函数之前，必须在源码文件头部引入这个头文件。

```c
#include <stdio.h>
int main(void) {
  printf("Hello World\n");
}
```

#### printf 中的占位符

`printf()`可以在输出文本中指定占位符。所谓“占位符”，就是这个位置可以用其他值代入。

```c
printf("%s says it is %i o'clock\n", "Ben", 21);
// Ben says it is 21 o'clock
```

- `%a`：浮点数。
- `%A`：浮点数。
- `%c`：字符。
- `%d`：十进制整数。
- `%e`：使用科学计数法的浮点数，指数部分的`e`为小写。
- `%E`：使用科学计数法的浮点数，指数部分的`E`为大写。
- `%i`：整数，基本等同于`%d`。
- `%f`：小数（包含`float`类型和`double`类型）。
- `%g`：6个有效数字的浮点数。整数部分一旦超过6位，就会自动转为科学计数法，指数部分的`e`为小写。
- `%G`：等同于`%g`，唯一的区别是指数部分的`E`为大写。
- `%hd`：十进制 short int 类型。
- `%ho`：八进制 short int 类型。
- `%hx`：十六进制 short int 类型。
- `%hu`：unsigned short int 类型。
- `%ld`：十进制 long int 类型。
- `%lo`：八进制 long int 类型。
- `%lx`：十六进制 long int 类型。
- `%lu`：unsigned long int 类型。
- `%lld`：十进制 long long int 类型。
- `%llo`：八进制 long long int 类型。
- `%llx`：十六进制 long long int 类型。
- `%llu`：unsigned long long int 类型。
- `%Le`：科学计数法表示的 long double 类型浮点数。
- `%Lf`：long double 类型浮点数。
- `%n`：已输出的字符串数量。该占位符本身不输出，只将值存储在指定变量之中。
- `%o`：八进制整数。
- `%p`：指针。
- `%s`：字符串。
- `%u`：无符号整数（unsigned int）。
- `%x`：十六进制整数。
- `%zd` or ` %zu`：`size_t`类型。
- `%%`：输出一个百分号。

#### 格式化输出

`printf()`可以定制占位符的输出格式。

1. 限定宽度

   `printf()`允许限定占位符的最小宽度。

2. 总是显示正负号

   可以在占位符的`%`后面加一个`+`，确保输出的数值总带有正负号

   ```c
   // 默认右对齐，空格填充
   printf("%5d\n", 123);  // '  123'
   // 左对齐
   printf("%-5d\n", 123); // '123  '
   
   printf("%12f\n", 123.45);  // '  123.450000'
   printf("%6f\n", 123.45);  // '123.450000'
   
   // 总是显示正负号
   printf("%+d\n", 12); // 输出 +12
   printf("%+d\n", -12); // 输出 -12
   ```

3. 限定小数位数

   输出小数时，有时希望限定小数的位数。举例来说，希望小数点后面只保留两位，占位符可以写成`%.2f`。

   最小宽度和小数位数这两个限定值，都可以用`*`代替，通过`printf()`的参数传入。

   ```c
   printf("%*.*f\n", 6, 2, 0.5);
   // 等同于
   printf("%6.2f\n", 0.5);
   ```

   ---

   ```c
   void func_printf_limit_digits() {
   	printf("%.2f\n", 1.2345); // 1.23
   
   	// 限制位数只限制小数点后位数，对整数无效
   	printf("%.2d\n", 12345); // 12345
   
   	// 采用 * 代替限定值
   	printf("%.*f\n", 2, 1.2345); // 1.23
   	printf("%*.*f\n", 5, 2, 1.2345); // ' 1.23'
   	printf("%+*.*f\n", 5, 2, 1.2345); // +1.23
   }
   ```

4. 输出部分字符串

   `%s`占位符用来输出字符串，默认是全部输出。如果只想输出开头的部分，可以用`%.[m]s`指定输出的长度，其中`[m]`代表一个数字，表示所要输出的长度。

   ```c
   printf("%.5s\n", "hello world"); // hello
   ```

## 变量

C 语言会在变量声明时，就为它分配内存空间，但是不会清除内存里面原来的值。这导致声明变量以后，变量会是一个随机的值。所以，变量一定要赋值以后才能使用。

注意，赋值表达式有返回值，等于等号右边的值。

```c
int x, y;
x = 1;
y = (x = 2 * x);
```

上面代码中，变量`y`的值就是赋值表达式（`x = 2 * x`）的返回值`2`。

由于赋值表达式有返回值，所以 C 语言可以写出多重赋值表达式。

```c
int x, y, z, m, n;
x = y = z = m = n = 3;
```

## 运算符

### 加减乘除

运算符`/`用来完成除法。注意，两个整数相除，得到还是一个整数。

```c
float x = 6 / 4;
printf("%f\n", x); // 输出 1.000000
```

运算符`%`表示求模运算，即返回两个整数相除的余值。这个运算符只能用于整数，不能用于浮点数。

负数求模的规则是，结果的正负号由第一个运算数的正负号决定。

```c
11 % -5 // 1
-11 % -5 // -1
-11 % 5 // -1
```

### 自增自减

这两个运算符放在变量的前面或后面，结果是不一样的。`++var`和`--var`是先执行自增或自减操作，再返回操作后`var`的值；`var++`和`var--`则是先返回操作前`var`的值，再执行自增或自减操作。

### 逻辑运算符

逻辑运算符提供逻辑判断功能，用于构建更复杂的表达式，主要有下面三个运算符。

- `!`：否运算符（改变单个表达式的真伪）。
- `&&`：与运算符（两侧的表达式都为真，则为真，否则为伪）。
- `||`：或运算符（两侧至少有一个表达式为真，则为真，否则为伪）。

```c
if (!(x < 12))
    printf("x is not less than 12\n");
```

上面示例中，由于否运算符`!`具有比`<`更高的优先级，所以必须使用括号，才能对表达式`x < 12`进行否运算。当然，合理的写法是`if (x >= 12)`，这里只是为了举例。

### 位运算符

1. 取反运算符`～`

   a 取反的结果是 -(a+1)

### 逗号运算符

逗号运算符用于将多个表达式写在一起，从左到右依次运行每个表达式。

```c
int x;
x = 1, 2, 3;
// = 比 , 有更高的优先级，所以 x=1
printf("%d\n", x);  // 1

// 但是整个语句的返回值为最后一个表达式的值
int y;
y = (x = 1, 2, 3);
printf("%d\n", y);  // 3
```

### 运算符优先级

- 圆括号（`()`）
- 自增运算符（`++`），自减运算符（`--`）
- 一元运算符（`+`和`-`）
- 乘法（`*`），除法（`/`）
- 加法（`+`），减法（`-`）
- 关系运算符（`<`、`>`等）
- 赋值运算符（`=`）

# 基础数据类型

[书栈-基础数据类型](https://www.bookstack.cn/read/wangdoc-clang-tutorial/docs-types.md)

## 字面量

### 字面量后缀

总结一下，常用的字面量后缀有下面这些。

- `f`和`F`：`float`类型。
- `l`和`L`：对于整数是`long int`类型，对于小数是`long double`类型。
- `ll`和`LL`：Long Long 类型，比如`3LL`。
- `u`和`U`：表示`unsigned int`，比如`15U`、`0377U`。

`u`还可以与其他整数后缀结合，放在前面或后面都可以，比如`10UL`、`10ULL`和`10LLU`都是合法的。

```c
int           x = 1234;
long int      x = 1234L;
long long int x = 1234LL
unsigned int           x = 1234U;
unsigned long int      x = 1234UL;
unsigned long long int x = 1234ULL;
float x       = 3.14f;
double x      = 3.14;
long double x = 3.14L;
```

# 流程控制

[书栈-流程控制](https://www.bookstack.cn/read/wangdoc-clang-tutorial/docs-flow-control.md)

# 指针

[书栈-指针](https://www.bookstack.cn/read/wangdoc-clang-tutorial/docs-pointer.md)

# 函数

[书栈-函数](https://www.bookstack.cn/read/wangdoc-clang-tutorial/docs-function.md)

## 函数指针

函数本身就是一段内存里面的代码，C 语言允许通过指针获取函数。

```c
void print(int a) {
  printf("%d\n", a);
}
void (*print_ptr)(int) = &print;
```

上面示例中，变量`print_ptr`是一个函数指针，它指向函数`print()`的地址。函数`print()`的地址可以用`&print`获得。注意，`(*print_ptr)`一定要写在圆括号里面，否则函数参数`(int)`的优先级高于`*`，整个式子就会变成`void* print_ptr(int)`。

有了函数指针，通过它也可以调用函数。

```c
(*print_ptr)(10);
// 等同于
print(10);
```

比较特殊的是，C 语言还规定，函数名本身就是指向函数代码的指针，通过函数名就能获取函数地址。也就是说，`print`和`&print`是一回事。

```c
if (print == &print) // true
```

因此，上面代码的`print_ptr`等同于`print`。

```c
void (*print_ptr)(int) = &print;

// 或
void (*print_ptr)(int) = print;

if (print_ptr == print) // true
```

## exit()

`exit()`函数用来终止整个程序的运行。一旦执行到该函数，程序就会立即结束。该函数的原型定义在头文件`stdlib.h`里面。

`exit()`可以向程序外部返回一个值，它的参数就是程序的返回值。一般来说，使用两个常量作为它的参数：`EXIT_SUCCESS`（相当于 0）表示程序运行成功，`EXIT_FAILURE`（相当于 1）表示程序异常中止。这两个常数也是定义在`stdlib.h`里面。

```c
// 程序运行成功
// 等同于 exit(0);
exit(EXIT_SUCCESS);
// 程序异常中止
// 等同于 exit(1);
exit(EXIT_FAILURE);
```

在`main()`函数里面，`exit()`等价于使用`return`语句。其他函数使用`exit()`，就是终止整个程序的运行，没有其他作用。

C 语言还提供了一个`atexit()`函数，用来登记`exit()`执行时额外执行的函数，用来做一些退出程序时的收尾工作。该函数的原型也是定义在头文件`stdlib.h`。

```c
int atexit(void (*func)(void));
```

`atexit()`的参数是一个函数指针。注意，它的参数函数（下例的`print`）不能接受参数，也不能有返回值。

```c
void print(void) {
  printf("something wrong!\n");
}
atexit(print);
exit(EXIT_FAILURE);
```

上面示例中，`exit()`执行时会先自动调用`atexit()`注册的`print()`函数，然后再终止程序。

## 可变参数

有些函数的参数数量是不确定的，声明函数的时候，可以使用省略号`...`表示可变数量的参数。

```c
int printf(const char* format, ...);
```

上面示例是`printf()`函数的原型，除了第一个参数，其他参数的数量是可变的，与格式字符串里面的占位符数量有关。这时，就可以用`...`表示可变数量的参数。

注意，`...`符号必须放在参数序列的结尾，否则会报错。

头文件`stdarg.h`定义了一些宏，可以操作可变参数。

（1）`va_list`：一个数据类型，用来定义一个可变参数对象。它必须在操作可变参数时，首先使用。

（2）`va_start`：一个函数，用来初始化可变参数对象。它接受两个参数，第一个参数是可变参数对象，第二个参数是原始函数里面，可变参数之前的那个参数，用来为可变参数定位。

（3）`va_arg`：一个函数，用来取出当前那个可变参数，每次调用后，内部指针就会指向下一个可变参数。它接受两个参数，第一个是可变参数对象，第二个是当前可变参数的类型。

（4）`va_end`：一个函数，用来清理可变参数对象。

下面是一个例子。

```c
double average(int i, ...) {
    double total = 0;
    va_list ap;
    va_start(ap, i);
    for (int j = 1; j <= i; ++j) {
        total += va_arg(ap, double);
    }
    va_end(ap);
    return total / i;
}
```

上面示例中，`va_list ap`定义`ap`为可变参数对象，`va_start(ap, i)`将参数`i`后面的参数统一放入`ap`，`va_arg(ap, double)`用来从`ap`依次取出一个参数，并且指定该参数为 double 类型，`va_end(ap)`用来清理可变参数对象。

# 数组

[书栈-数组](https://www.bookstack.cn/read/wangdoc-clang-tutorial/docs-array.md)

## 简介

如果大括号里面的值，少于数组的成员数量，那么未赋值的成员自动初始化为`0`。

```c
int a[5] = {22, 37, 3490};
// 等同于
int a[5] = {22, 37, 3490, 0, 0};
```

如果要将整个数组的每一个成员都设置为零，最简单的写法就是下面这样。

```c
int a[100] = {0};
```

其他声明方式：

```c
// 数组初始化时，可以指定为哪些位置的成员赋值。（只有gcc编译器支持）
int a[15] = {[2] = 29, [9] = 7, [14] = 48};
// 上面示例中，数组的2号、9号、14号位置被赋值，其他位置的值都自动设为0。

// 指定位置的赋值可以不按照顺序，下面的写法与上面的例子是等价的。（只有gcc编译器支持）
int a[15] = {[9] = 7, [14] = 48, [2] = 29};

// 指定位置的赋值与顺序赋值，可以结合使用。（只有gcc编译器支持）
int a[15] = {1, [5] = 10, 11, [10] = 20, 21}
// 上面示例中，0号、5号、6号、10号、11号被赋值。

// C 语言允许省略方括号里面的数组成员数量，这时将根据大括号里面的值的数量，自动确定数组的长度。
int a[] = {22, 37, 3490};
// 等同于
int a[3] = {22, 37, 3490};

// 省略成员数量时，如果同时采用指定位置的赋值，那么数组长度将是最大的指定位置再加1。（只有gcc编译器支持）
int a[] = {[2] = 6, [9] = 12};
// 上面示例中，数组a的最大指定位置是9，所以数组的长度是10。
```

## 数组长度

## 变长数组

C99 标准， Visual Studio 只支持C89。

## 数组指针

函数接受数组作为参数，函数原型可以写成下面这样。

```c
// 写法一
int sum(int arr[], int len);
// 写法二
int sum(int* arr, int len);
```

`*`和`&`运算符也可以用于多维数组。

```c
int a[4][2];
// 取出 a[0][0] 的值
*(a[0]);
// 等同于
**a
```

上面示例中，二维数组中，由于`a[0]`的值本身是一个指针，指向第二维数组的第一个成员`a[0][0]`。所以，`*(a[0])`取出的是`a[0][0]`的值。

至于`**a`，就是对`a`进行两次`*`运算，第一次取出的是`a[0]`，第二次取出的是`a[0][0]`。

同理，二维数组的`&a[0][0]`等同于`*a`。

## 数组指针的加减

C 语言里面，数组名可以进行加法和减法运算，等同于在数组成员之间前后移动，即从一个成员的内存地址移动到另一个成员的内存地址。比如，`a + 1`返回下一个成员的地址，`a - 1`返回上一个成员的地址。

```c
int a[5] = {11, 22, 33, 44, 55};
for (int i = 0; i < 5; i++) {
  printf("%d\n", *(a + i));
}
```

上面示例中，通过指针的移动遍历数组，`a + i`的每轮循环每次都会指向下一个成员的地址，`*(a + i)`取出该地址的值，等同于`a[i]`。对于数组的第一个成员，`*(a + 0)`（即`*a`）等同于`a[0]`。

由于数组名与指针是等价的，所以下面的等式总是成立。

```c
a[b] == *(a + b)
```

上面代码给出了数组成员的两种访问方式，一种是使用方括号`a[b]`，另一种是使用指针`*(a + b)`。

## 数组的复制

由于数组名是指针，所以复制数组不能简单地复制数组名。

```c
int* a;
int b[3] = {1, 2, 3};
a = b;
```

上面的写法，结果不是将数组`b`复制给数组`a`，而是让`a`和`b`指向同一个数组。

复制数组最简单的方法，还是使用循环，将数组元素逐个进行复制。

```c
for (i = 0; i < N; i++)  
    a[i] = b[i];
```

上面示例中，通过将数组`b`的成员逐个复制给数组`a`，从而实现数组的赋值。

另一种方法是使用`memcpy()`函数（定义在头文件`string.h`），直接把数组所在的那一段内存，再复制一份。

```c
memcpy(a, b, sizeof(b));
```

上面示例中，将数组`b`所在的那段内存，复制给数组`a`。这种方法要比循环复制数组成员要快。

# 字符串

[书栈-字符串](https://www.bookstack.cn/read/wangdoc-clang-tutorial/docs-string.md)

## 字符串变量的声明

为什么字符串声明为指针时不能修改，声明为数组时就可以修改？原因是系统会将字符串的字面量保存在内存的常量区，这个区是不允许用户修改的。声明为指针时，指针变量存储的值是一个指向常量区的内存地址，因此用户不能通过这个地址去修改常量区。但是，声明为数组时，编译器会给数组单独分配一段内存，字符串字面量会被编译器解释成字符数组，逐个字符写入这段新分配的内存之中，而这段新内存是允许修改的。

为什么数组变量不能赋值为另一个数组？原因是数组变量所在的地址无法改变，或者说，编译器一旦为数组变量分配地址后，这个地址就绑定这个数组变量了，这种绑定关系是不变的。C 语言也因此规定，数组变量是一个不可修改的左值，即不能用赋值运算符为它重新赋值。

想要重新赋值，必须使用 C 语言原生提供的`strcpy()`函数，通过字符串拷贝完成赋值。这样做以后，数组变量的地址还是不变的，即`strcpy()`只是在原地址写入新的字符串，而不是让数组变量指向新的地址。

```c
char s[10];
strcpy(s, "abc");
```

**注：**现在采用 strcpy_s() 更安全

# 内存管理

[书栈-内存管理](https://www.bookstack.cn/read/wangdoc-clang-tutorial/docs-memory.md)

## 简介

C 语言的内存管理，分成两部分。一部分是系统管理的，另一部分是用户手动管理的。

系统管理的内存，主要是函数内部的变量（局部变量）。这部分变量在函数运行时进入内存，函数运行结束后自动从内存卸载。这些变量存放的区域称为”栈“（stack），”栈“所在的内存是系统自动管理的。

用户手动管理的内存，主要是程序运行的整个过程中都存在的变量（全局变量），这些变量需要用户手动从内存释放。如果使用后忘记释放，它就一直占用内存，直到程序退出，这种情况称为”内存泄漏“（memory leak）。这些变量所在的内存称为”堆“（heap），”堆“所在的内存是用户手动管理的。

# 结构体

[书栈-结构体](https://www.bookstack.cn/read/wangdoc-clang-tutorial/docs-struct.md)

# typedef

[书栈-typedef](https://www.bookstack.cn/read/wangdoc-clang-tutorial/docs-typedef.md)

# union

[书栈-union](https://www.bookstack.cn/read/wangdoc-clang-tutorial/docs-union.md)
