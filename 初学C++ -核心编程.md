# C++ 核心编程

# 内存分区模型

C++程序执行时，将内存大方向划分为4个区域

- 代码区：存放函数体的二进制代码，由操作系统进行管理的
- 全局区：存放全局变量和静态变量以及常量
- 栈区：由编译器自动分配释放，存放函数的参数值、局部变量等
- 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收

内存四区意义：

​    不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程

## 程序运行前

在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域

- 代码区：

  存放CPU执行的机器指令

  代码区是`共享`的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可

  代码区是`只读`的，使其只读的原因是防止程序意外地修改了它的指令

- 全局区：

  全局变量和静态变量存放在此

  全局区还包含了常量区，字符串常量和其他常量也存放在此

  `该区域的数据在程序结束后由操作系统释放`

---

> 变量类型

```cpp
// 全局变量
int g_a = 1;

// const修饰的全局变量
const int c_g_a = 1;

int main()
{
    // 普通局部变量
    int a = 1;
    
    // 静态变量 在普通变量前面加static，属于静态变量
    static int s_a = 10;
    
    // 常量
    // 字符串常量
    "hello word";
    
    // const修饰的变量
    //	const修饰的全局变量
    //	const修饰的局部变量  // 局部的都不放在全局区
    const int c_a = 1;
    
}
```

**总结：**

**全局区：**全局变量、静态变量、常量（字符串常量、const修饰的全局变量）

**不在全局区：**局部变量、const修饰的局部变量

## 程序运行后

- 栈区：

  由编译器自动分配释放，存放函数的参数值，局部变量等；

  注意事项：不要返回局部变量的地址，栈开启的数据由编译器自动释放。、

- 堆区：

  由程序员分配释放，若程序员不释放，程序结束时由操作系统回收

  在C++中主要利用new在堆区开辟内存

## new操作符

C++中利用`new`操作符在堆区开辟数据

堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符`delete`

语法：`new 数据类型()`

利用`new`创建的数据，会返回该数据对应的类型的指针

  ```cpp
  // 堆操作
  int * func()
  {
      // 利用new关键字 可以将数据开辟到堆区
      // new 返回是 该数据类型的指针
      // 指针 本质也是局部变量，放在栈上，指针保存的数据放在了堆区
      int* p = new int(10);		
      return p;
  }
  
  int main()
  {
      // 在堆区开辟数据
      int *p = func();
      
      // delete 释放堆区的数据
      delete p;
      
      // 堆区创建数组
      //	创建10个整型数据的数组
      int * arr = new int[10];		// 10代表数组有10个元素
      
      // delete 释放堆区的数组
      delete[] arr;
  }
  ```

  # 引用

## 引用的基本使用

作用： 给变量起别名

语法： `数据类型 &别名 = 原名`

```cpp
int a = 10;
int &b = a;		// 引用 // a和b操作的是同一块内存
```

## 引用注意事项

- 引用必须初始化
- 引用在初始化后，不可以改变

```cpp
int a = 0;
// 引用必须初始化  // 错误写法 int &b；
int &b = a;
// 引用一旦初始化后，就不能更改 // 错误写法 int &b = c;
int c = 20;

b = c;		// 赋值操作，而不是更改引用
// a、b、c 结果都是20
cout << "a=" << a << endl;
cout << "b=" << b << endl;
cout << "c=" << c << endl;
```

  ## 引用做函数参数

作用：函数传参时，可以利用引用的技术让形参修饰实参

优点：可以简化指针修改实参

```cpp
// 交换函数

// 1、值传递
void mySwap01(int a, int b)
{
    int temp = a;
    a = b;
    b = temp;
}

// 2、地址传递
void mySwap02(int* a, int* b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

// 3、引用传递
void mySwap03(int &a, int &b)
{
    int temp = a;
    a = b;
    b = temp;
}
```

## 引用做函数返回值

注意：不要返回局部变量引用；函数的调用可以作为左值存在

```cpp
int& test01()
{
    int a = 10;		// 不要返回局部变量引用
    retrun a;
}

int& test02()
{
    static a = 10;		// 静态变量，存放在全局区，在程序结束后释放
    retrun a;
}

int main()
{
    test02 = 1000;		// 如果函数的返回值是引用，这个函数调用可以作为左值
}
```

## 引用的本质

本质：引用的本质在C++内部实现是一个**指针常量**。

```cpp
// 发现是引用，转换为 int* const ref = &a;
void func(int& ref)
{
    ref = 100;		// ref是引用，转换为*ref = 100
}

int main()
{
    int a = 10;
    
    // 自动转换为 int*const ref = &a; 指针常量是指针指向不可改，也说明为什么引用不可更改
    int& ref = a;
    ref = 20;		// 内部发现ref是引用，自动帮我们转换为：*ref=20;
    cout << "a:" << a << endl;
    cout << "ref" << ref << endl;
}
```

## 常量引用

```cpp
void showValue(const int & a)
{	
    val = 1000;
    cout << "val" << val << endl;
}

int main()
{
    // 常量使用
    // 使用场景；用来修饰形参，防止误操作
    
    // int a = 10；
    
    // int& ref = 10; 引用本身需要一个合法的内存空间，因此这行错误
    // 加上 const 之后 编码器将代码修改 int temp = 10； const int & ref = temp；
    const int & ref = 10;		// 引用必须引一块合法的内存空间
    
    // 防止误操作
    int v = 10;
    showValue(v);
    
    return 0;
}
```

# 函数的提高



